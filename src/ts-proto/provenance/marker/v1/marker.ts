// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: provenance/marker/v1/marker.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { BaseAccount } from "../../../cosmos/auth/v1beta1/auth";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { AccessGrant } from "./accessgrant";

export const protobufPackage = "provenance.marker.v1";

/** MarkerType defines the types of marker */
export enum MarkerType {
  /** MARKER_TYPE_UNSPECIFIED - MARKER_TYPE_UNSPECIFIED is an invalid/unknown marker type. */
  MARKER_TYPE_UNSPECIFIED = 0,
  /** MARKER_TYPE_COIN - MARKER_TYPE_COIN is a marker that represents a standard fungible coin (default). */
  MARKER_TYPE_COIN = 1,
  /** MARKER_TYPE_RESTRICTED - MARKER_TYPE_RESTRICTED is a marker that represents a denom with send_enabled = false. */
  MARKER_TYPE_RESTRICTED = 2,
  UNRECOGNIZED = -1,
}

export function markerTypeFromJSON(object: any): MarkerType {
  switch (object) {
    case 0:
    case "MARKER_TYPE_UNSPECIFIED":
      return MarkerType.MARKER_TYPE_UNSPECIFIED;
    case 1:
    case "MARKER_TYPE_COIN":
      return MarkerType.MARKER_TYPE_COIN;
    case 2:
    case "MARKER_TYPE_RESTRICTED":
      return MarkerType.MARKER_TYPE_RESTRICTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MarkerType.UNRECOGNIZED;
  }
}

export function markerTypeToJSON(object: MarkerType): string {
  switch (object) {
    case MarkerType.MARKER_TYPE_UNSPECIFIED:
      return "MARKER_TYPE_UNSPECIFIED";
    case MarkerType.MARKER_TYPE_COIN:
      return "MARKER_TYPE_COIN";
    case MarkerType.MARKER_TYPE_RESTRICTED:
      return "MARKER_TYPE_RESTRICTED";
    case MarkerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** MarkerStatus defines the various states a marker account can be in. */
export enum MarkerStatus {
  /** MARKER_STATUS_UNSPECIFIED - MARKER_STATUS_UNSPECIFIED - Unknown/Invalid Marker Status */
  MARKER_STATUS_UNSPECIFIED = 0,
  /** MARKER_STATUS_PROPOSED - MARKER_STATUS_PROPOSED - Initial configuration period, updates allowed, token supply not created. */
  MARKER_STATUS_PROPOSED = 1,
  /** MARKER_STATUS_FINALIZED - MARKER_STATUS_FINALIZED - Configuration finalized, ready for supply creation */
  MARKER_STATUS_FINALIZED = 2,
  /** MARKER_STATUS_ACTIVE - MARKER_STATUS_ACTIVE - Supply is created, rules are in force. */
  MARKER_STATUS_ACTIVE = 3,
  /** MARKER_STATUS_CANCELLED - MARKER_STATUS_CANCELLED - Marker has been cancelled, pending destroy */
  MARKER_STATUS_CANCELLED = 4,
  /**
   * MARKER_STATUS_DESTROYED - MARKER_STATUS_DESTROYED - Marker supply has all been recalled, marker is considered destroyed and no further
   * actions allowed.
   */
  MARKER_STATUS_DESTROYED = 5,
  UNRECOGNIZED = -1,
}

export function markerStatusFromJSON(object: any): MarkerStatus {
  switch (object) {
    case 0:
    case "MARKER_STATUS_UNSPECIFIED":
      return MarkerStatus.MARKER_STATUS_UNSPECIFIED;
    case 1:
    case "MARKER_STATUS_PROPOSED":
      return MarkerStatus.MARKER_STATUS_PROPOSED;
    case 2:
    case "MARKER_STATUS_FINALIZED":
      return MarkerStatus.MARKER_STATUS_FINALIZED;
    case 3:
    case "MARKER_STATUS_ACTIVE":
      return MarkerStatus.MARKER_STATUS_ACTIVE;
    case 4:
    case "MARKER_STATUS_CANCELLED":
      return MarkerStatus.MARKER_STATUS_CANCELLED;
    case 5:
    case "MARKER_STATUS_DESTROYED":
      return MarkerStatus.MARKER_STATUS_DESTROYED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MarkerStatus.UNRECOGNIZED;
  }
}

export function markerStatusToJSON(object: MarkerStatus): string {
  switch (object) {
    case MarkerStatus.MARKER_STATUS_UNSPECIFIED:
      return "MARKER_STATUS_UNSPECIFIED";
    case MarkerStatus.MARKER_STATUS_PROPOSED:
      return "MARKER_STATUS_PROPOSED";
    case MarkerStatus.MARKER_STATUS_FINALIZED:
      return "MARKER_STATUS_FINALIZED";
    case MarkerStatus.MARKER_STATUS_ACTIVE:
      return "MARKER_STATUS_ACTIVE";
    case MarkerStatus.MARKER_STATUS_CANCELLED:
      return "MARKER_STATUS_CANCELLED";
    case MarkerStatus.MARKER_STATUS_DESTROYED:
      return "MARKER_STATUS_DESTROYED";
    case MarkerStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Params defines the set of params for the account module. */
export interface Params {
  /**
   * Deprecated: Prefer to use `max_supply` instead. Maximum amount of supply to allow a marker to be created with
   *
   * @deprecated
   */
  maxTotalSupply: Long;
  /** indicates if governance based controls of markers is allowed. */
  enableGovernance: boolean;
  /**
   * a regular expression used to validate marker denom values from normal create requests (governance
   * requests are only subject to platform coin validation denom expression)
   */
  unrestrictedDenomRegex: string;
  /** maximum amount of supply to allow a marker to be created with */
  maxSupply: string;
}

/** MarkerAccount holds the marker configuration information in addition to a base account structure. */
export interface MarkerAccount {
  /** base cosmos account information including address and coin holdings. */
  baseAccount?:
    | BaseAccount
    | undefined;
  /**
   * Address that owns the marker configuration.  This account must sign any requests
   * to change marker config (only valid for statuses prior to finalization)
   */
  manager: string;
  /** Access control lists */
  accessControl: AccessGrant[];
  /** Indicates the current status of this marker record. */
  status: MarkerStatus;
  /** value denomination and total supply for the token. */
  denom: string;
  /** the total supply expected for a marker.  This is the amount that is minted when a marker is created. */
  supply: string;
  /** Marker type information */
  markerType: MarkerType;
  /**
   * A fixed supply will mint additional coin automatically if the total supply decreases below a set value.  This
   * may occur if the coin is burned or an account holding the coin is slashed. (default: true)
   */
  supplyFixed: boolean;
  /** indicates that governance based control is allowed for this marker */
  allowGovernanceControl: boolean;
  /** Whether an admin can transfer restricted coins from a 3rd-party account without their signature. */
  allowForcedTransfer: boolean;
  /**
   * list of required attributes on restricted marker in order to send and receive transfers if sender does not have
   * transfer authority
   */
  requiredAttributes: string[];
}

/** NetAssetValue defines a marker's net asset value */
export interface NetAssetValue {
  /** price is the complete value of the asset's volume */
  price?:
    | Coin
    | undefined;
  /** volume is the number of tokens of the marker that were purchased for the price */
  volume: Long;
  /** updated_block_height is the block height of last update */
  updatedBlockHeight: Long;
}

/** EventMarkerAdd event emitted when marker is added */
export interface EventMarkerAdd {
  denom: string;
  amount: string;
  status: string;
  manager: string;
  markerType: string;
  address: string;
}

/** EventMarkerAddAccess event emitted when marker access is added */
export interface EventMarkerAddAccess {
  access?: EventMarkerAccess | undefined;
  denom: string;
  administrator: string;
}

/** EventMarkerAccess event access permissions for address */
export interface EventMarkerAccess {
  address: string;
  permissions: string[];
}

/** EventMarkerDeleteAccess event emitted when marker access is revoked */
export interface EventMarkerDeleteAccess {
  removeAddress: string;
  denom: string;
  administrator: string;
}

/** EventMarkerFinalize event emitted when marker is finalized */
export interface EventMarkerFinalize {
  denom: string;
  administrator: string;
}

/** EventMarkerActivate event emitted when marker is activated */
export interface EventMarkerActivate {
  denom: string;
  administrator: string;
}

/** EventMarkerCancel event emitted when marker is cancelled */
export interface EventMarkerCancel {
  denom: string;
  administrator: string;
}

/** EventMarkerDelete event emitted when marker is deleted */
export interface EventMarkerDelete {
  denom: string;
  administrator: string;
}

/** EventMarkerMint event emitted when additional marker supply is minted */
export interface EventMarkerMint {
  amount: string;
  denom: string;
  administrator: string;
}

/** EventMarkerBurn event emitted when coin is burned from marker */
export interface EventMarkerBurn {
  amount: string;
  denom: string;
  administrator: string;
}

/** EventMarkerWithdraw event emitted when coins are withdrew from marker */
export interface EventMarkerWithdraw {
  coins: string;
  denom: string;
  administrator: string;
  toAddress: string;
}

/** EventMarkerTransfer event emitted when coins are transfered to from account to another */
export interface EventMarkerTransfer {
  amount: string;
  denom: string;
  administrator: string;
  toAddress: string;
  fromAddress: string;
}

/** EventMarkerSetDenomMetadata event emitted when metadata is set on marker with denom */
export interface EventMarkerSetDenomMetadata {
  metadataBase: string;
  metadataDescription: string;
  metadataDisplay: string;
  metadataDenomUnits: EventDenomUnit[];
  administrator: string;
  metadataName: string;
  metadataSymbol: string;
}

/** EventDenomUnit denom units for set denom metadata event */
export interface EventDenomUnit {
  denom: string;
  exponent: string;
  aliases: string[];
}

/** EventSetNetAssetValue event emitted when Net Asset Value for marker is update or added */
export interface EventSetNetAssetValue {
  denom: string;
  price: string;
  volume: string;
  source: string;
}

/** EventMarkerParamsUpdated event emitted when marker params are updated. */
export interface EventMarkerParamsUpdated {
  enableGovernance: string;
  unrestrictedDenomRegex: string;
  maxSupply: string;
}

function createBaseParams(): Params {
  return { maxTotalSupply: Long.UZERO, enableGovernance: false, unrestrictedDenomRegex: "", maxSupply: "" };
}

export const Params: MessageFns<Params> = {
  encode(message: Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.maxTotalSupply.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.maxTotalSupply.toString());
    }
    if (message.enableGovernance !== false) {
      writer.uint32(16).bool(message.enableGovernance);
    }
    if (message.unrestrictedDenomRegex !== "") {
      writer.uint32(26).string(message.unrestrictedDenomRegex);
    }
    if (message.maxSupply !== "") {
      writer.uint32(34).string(message.maxSupply);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.maxTotalSupply = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enableGovernance = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.unrestrictedDenomRegex = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.maxSupply = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Params {
    return {
      maxTotalSupply: isSet(object.maxTotalSupply) ? Long.fromValue(object.maxTotalSupply) : Long.UZERO,
      enableGovernance: isSet(object.enableGovernance) ? globalThis.Boolean(object.enableGovernance) : false,
      unrestrictedDenomRegex: isSet(object.unrestrictedDenomRegex)
        ? globalThis.String(object.unrestrictedDenomRegex)
        : "",
      maxSupply: isSet(object.maxSupply) ? globalThis.String(object.maxSupply) : "",
    };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    if (!message.maxTotalSupply.equals(Long.UZERO)) {
      obj.maxTotalSupply = (message.maxTotalSupply || Long.UZERO).toString();
    }
    if (message.enableGovernance !== false) {
      obj.enableGovernance = message.enableGovernance;
    }
    if (message.unrestrictedDenomRegex !== "") {
      obj.unrestrictedDenomRegex = message.unrestrictedDenomRegex;
    }
    if (message.maxSupply !== "") {
      obj.maxSupply = message.maxSupply;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Params>, I>>(base?: I): Params {
    return Params.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Params>, I>>(object: I): Params {
    const message = createBaseParams();
    message.maxTotalSupply = (object.maxTotalSupply !== undefined && object.maxTotalSupply !== null)
      ? Long.fromValue(object.maxTotalSupply)
      : Long.UZERO;
    message.enableGovernance = object.enableGovernance ?? false;
    message.unrestrictedDenomRegex = object.unrestrictedDenomRegex ?? "";
    message.maxSupply = object.maxSupply ?? "";
    return message;
  },
};

function createBaseMarkerAccount(): MarkerAccount {
  return {
    baseAccount: undefined,
    manager: "",
    accessControl: [],
    status: 0,
    denom: "",
    supply: "",
    markerType: 0,
    supplyFixed: false,
    allowGovernanceControl: false,
    allowForcedTransfer: false,
    requiredAttributes: [],
  };
}

export const MarkerAccount: MessageFns<MarkerAccount> = {
  encode(message: MarkerAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseAccount !== undefined) {
      BaseAccount.encode(message.baseAccount, writer.uint32(10).fork()).join();
    }
    if (message.manager !== "") {
      writer.uint32(18).string(message.manager);
    }
    for (const v of message.accessControl) {
      AccessGrant.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.denom !== "") {
      writer.uint32(42).string(message.denom);
    }
    if (message.supply !== "") {
      writer.uint32(50).string(message.supply);
    }
    if (message.markerType !== 0) {
      writer.uint32(56).int32(message.markerType);
    }
    if (message.supplyFixed !== false) {
      writer.uint32(64).bool(message.supplyFixed);
    }
    if (message.allowGovernanceControl !== false) {
      writer.uint32(72).bool(message.allowGovernanceControl);
    }
    if (message.allowForcedTransfer !== false) {
      writer.uint32(80).bool(message.allowForcedTransfer);
    }
    for (const v of message.requiredAttributes) {
      writer.uint32(90).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarkerAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkerAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseAccount = BaseAccount.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.manager = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.accessControl.push(AccessGrant.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.supply = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.markerType = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.supplyFixed = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.allowGovernanceControl = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.allowForcedTransfer = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.requiredAttributes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarkerAccount {
    return {
      baseAccount: isSet(object.baseAccount) ? BaseAccount.fromJSON(object.baseAccount) : undefined,
      manager: isSet(object.manager) ? globalThis.String(object.manager) : "",
      accessControl: globalThis.Array.isArray(object?.accessControl)
        ? object.accessControl.map((e: any) => AccessGrant.fromJSON(e))
        : [],
      status: isSet(object.status) ? markerStatusFromJSON(object.status) : 0,
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      supply: isSet(object.supply) ? globalThis.String(object.supply) : "",
      markerType: isSet(object.markerType) ? markerTypeFromJSON(object.markerType) : 0,
      supplyFixed: isSet(object.supplyFixed) ? globalThis.Boolean(object.supplyFixed) : false,
      allowGovernanceControl: isSet(object.allowGovernanceControl)
        ? globalThis.Boolean(object.allowGovernanceControl)
        : false,
      allowForcedTransfer: isSet(object.allowForcedTransfer) ? globalThis.Boolean(object.allowForcedTransfer) : false,
      requiredAttributes: globalThis.Array.isArray(object?.requiredAttributes)
        ? object.requiredAttributes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MarkerAccount): unknown {
    const obj: any = {};
    if (message.baseAccount !== undefined) {
      obj.baseAccount = BaseAccount.toJSON(message.baseAccount);
    }
    if (message.manager !== "") {
      obj.manager = message.manager;
    }
    if (message.accessControl?.length) {
      obj.accessControl = message.accessControl.map((e) => AccessGrant.toJSON(e));
    }
    if (message.status !== 0) {
      obj.status = markerStatusToJSON(message.status);
    }
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.supply !== "") {
      obj.supply = message.supply;
    }
    if (message.markerType !== 0) {
      obj.markerType = markerTypeToJSON(message.markerType);
    }
    if (message.supplyFixed !== false) {
      obj.supplyFixed = message.supplyFixed;
    }
    if (message.allowGovernanceControl !== false) {
      obj.allowGovernanceControl = message.allowGovernanceControl;
    }
    if (message.allowForcedTransfer !== false) {
      obj.allowForcedTransfer = message.allowForcedTransfer;
    }
    if (message.requiredAttributes?.length) {
      obj.requiredAttributes = message.requiredAttributes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarkerAccount>, I>>(base?: I): MarkerAccount {
    return MarkerAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarkerAccount>, I>>(object: I): MarkerAccount {
    const message = createBaseMarkerAccount();
    message.baseAccount = (object.baseAccount !== undefined && object.baseAccount !== null)
      ? BaseAccount.fromPartial(object.baseAccount)
      : undefined;
    message.manager = object.manager ?? "";
    message.accessControl = object.accessControl?.map((e) => AccessGrant.fromPartial(e)) || [];
    message.status = object.status ?? 0;
    message.denom = object.denom ?? "";
    message.supply = object.supply ?? "";
    message.markerType = object.markerType ?? 0;
    message.supplyFixed = object.supplyFixed ?? false;
    message.allowGovernanceControl = object.allowGovernanceControl ?? false;
    message.allowForcedTransfer = object.allowForcedTransfer ?? false;
    message.requiredAttributes = object.requiredAttributes?.map((e) => e) || [];
    return message;
  },
};

function createBaseNetAssetValue(): NetAssetValue {
  return { price: undefined, volume: Long.UZERO, updatedBlockHeight: Long.UZERO };
}

export const NetAssetValue: MessageFns<NetAssetValue> = {
  encode(message: NetAssetValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.price !== undefined) {
      Coin.encode(message.price, writer.uint32(10).fork()).join();
    }
    if (!message.volume.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.volume.toString());
    }
    if (!message.updatedBlockHeight.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.updatedBlockHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NetAssetValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNetAssetValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.price = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.volume = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.updatedBlockHeight = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NetAssetValue {
    return {
      price: isSet(object.price) ? Coin.fromJSON(object.price) : undefined,
      volume: isSet(object.volume) ? Long.fromValue(object.volume) : Long.UZERO,
      updatedBlockHeight: isSet(object.updatedBlockHeight) ? Long.fromValue(object.updatedBlockHeight) : Long.UZERO,
    };
  },

  toJSON(message: NetAssetValue): unknown {
    const obj: any = {};
    if (message.price !== undefined) {
      obj.price = Coin.toJSON(message.price);
    }
    if (!message.volume.equals(Long.UZERO)) {
      obj.volume = (message.volume || Long.UZERO).toString();
    }
    if (!message.updatedBlockHeight.equals(Long.UZERO)) {
      obj.updatedBlockHeight = (message.updatedBlockHeight || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NetAssetValue>, I>>(base?: I): NetAssetValue {
    return NetAssetValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NetAssetValue>, I>>(object: I): NetAssetValue {
    const message = createBaseNetAssetValue();
    message.price = (object.price !== undefined && object.price !== null) ? Coin.fromPartial(object.price) : undefined;
    message.volume = (object.volume !== undefined && object.volume !== null)
      ? Long.fromValue(object.volume)
      : Long.UZERO;
    message.updatedBlockHeight = (object.updatedBlockHeight !== undefined && object.updatedBlockHeight !== null)
      ? Long.fromValue(object.updatedBlockHeight)
      : Long.UZERO;
    return message;
  },
};

function createBaseEventMarkerAdd(): EventMarkerAdd {
  return { denom: "", amount: "", status: "", manager: "", markerType: "", address: "" };
}

export const EventMarkerAdd: MessageFns<EventMarkerAdd> = {
  encode(message: EventMarkerAdd, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.status !== "") {
      writer.uint32(26).string(message.status);
    }
    if (message.manager !== "") {
      writer.uint32(34).string(message.manager);
    }
    if (message.markerType !== "") {
      writer.uint32(42).string(message.markerType);
    }
    if (message.address !== "") {
      writer.uint32(50).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarkerAdd {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarkerAdd();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.manager = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.markerType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarkerAdd {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      manager: isSet(object.manager) ? globalThis.String(object.manager) : "",
      markerType: isSet(object.markerType) ? globalThis.String(object.markerType) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: EventMarkerAdd): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.manager !== "") {
      obj.manager = message.manager;
    }
    if (message.markerType !== "") {
      obj.markerType = message.markerType;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarkerAdd>, I>>(base?: I): EventMarkerAdd {
    return EventMarkerAdd.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarkerAdd>, I>>(object: I): EventMarkerAdd {
    const message = createBaseEventMarkerAdd();
    message.denom = object.denom ?? "";
    message.amount = object.amount ?? "";
    message.status = object.status ?? "";
    message.manager = object.manager ?? "";
    message.markerType = object.markerType ?? "";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseEventMarkerAddAccess(): EventMarkerAddAccess {
  return { access: undefined, denom: "", administrator: "" };
}

export const EventMarkerAddAccess: MessageFns<EventMarkerAddAccess> = {
  encode(message: EventMarkerAddAccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.access !== undefined) {
      EventMarkerAccess.encode(message.access, writer.uint32(10).fork()).join();
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    if (message.administrator !== "") {
      writer.uint32(26).string(message.administrator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarkerAddAccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarkerAddAccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.access = EventMarkerAccess.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarkerAddAccess {
    return {
      access: isSet(object.access) ? EventMarkerAccess.fromJSON(object.access) : undefined,
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
    };
  },

  toJSON(message: EventMarkerAddAccess): unknown {
    const obj: any = {};
    if (message.access !== undefined) {
      obj.access = EventMarkerAccess.toJSON(message.access);
    }
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarkerAddAccess>, I>>(base?: I): EventMarkerAddAccess {
    return EventMarkerAddAccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarkerAddAccess>, I>>(object: I): EventMarkerAddAccess {
    const message = createBaseEventMarkerAddAccess();
    message.access = (object.access !== undefined && object.access !== null)
      ? EventMarkerAccess.fromPartial(object.access)
      : undefined;
    message.denom = object.denom ?? "";
    message.administrator = object.administrator ?? "";
    return message;
  },
};

function createBaseEventMarkerAccess(): EventMarkerAccess {
  return { address: "", permissions: [] };
}

export const EventMarkerAccess: MessageFns<EventMarkerAccess> = {
  encode(message: EventMarkerAccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    for (const v of message.permissions) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarkerAccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarkerAccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.permissions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarkerAccess {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      permissions: globalThis.Array.isArray(object?.permissions)
        ? object.permissions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: EventMarkerAccess): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.permissions?.length) {
      obj.permissions = message.permissions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarkerAccess>, I>>(base?: I): EventMarkerAccess {
    return EventMarkerAccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarkerAccess>, I>>(object: I): EventMarkerAccess {
    const message = createBaseEventMarkerAccess();
    message.address = object.address ?? "";
    message.permissions = object.permissions?.map((e) => e) || [];
    return message;
  },
};

function createBaseEventMarkerDeleteAccess(): EventMarkerDeleteAccess {
  return { removeAddress: "", denom: "", administrator: "" };
}

export const EventMarkerDeleteAccess: MessageFns<EventMarkerDeleteAccess> = {
  encode(message: EventMarkerDeleteAccess, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.removeAddress !== "") {
      writer.uint32(10).string(message.removeAddress);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    if (message.administrator !== "") {
      writer.uint32(26).string(message.administrator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarkerDeleteAccess {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarkerDeleteAccess();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.removeAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarkerDeleteAccess {
    return {
      removeAddress: isSet(object.removeAddress) ? globalThis.String(object.removeAddress) : "",
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
    };
  },

  toJSON(message: EventMarkerDeleteAccess): unknown {
    const obj: any = {};
    if (message.removeAddress !== "") {
      obj.removeAddress = message.removeAddress;
    }
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarkerDeleteAccess>, I>>(base?: I): EventMarkerDeleteAccess {
    return EventMarkerDeleteAccess.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarkerDeleteAccess>, I>>(object: I): EventMarkerDeleteAccess {
    const message = createBaseEventMarkerDeleteAccess();
    message.removeAddress = object.removeAddress ?? "";
    message.denom = object.denom ?? "";
    message.administrator = object.administrator ?? "";
    return message;
  },
};

function createBaseEventMarkerFinalize(): EventMarkerFinalize {
  return { denom: "", administrator: "" };
}

export const EventMarkerFinalize: MessageFns<EventMarkerFinalize> = {
  encode(message: EventMarkerFinalize, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.administrator !== "") {
      writer.uint32(18).string(message.administrator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarkerFinalize {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarkerFinalize();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarkerFinalize {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
    };
  },

  toJSON(message: EventMarkerFinalize): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarkerFinalize>, I>>(base?: I): EventMarkerFinalize {
    return EventMarkerFinalize.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarkerFinalize>, I>>(object: I): EventMarkerFinalize {
    const message = createBaseEventMarkerFinalize();
    message.denom = object.denom ?? "";
    message.administrator = object.administrator ?? "";
    return message;
  },
};

function createBaseEventMarkerActivate(): EventMarkerActivate {
  return { denom: "", administrator: "" };
}

export const EventMarkerActivate: MessageFns<EventMarkerActivate> = {
  encode(message: EventMarkerActivate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.administrator !== "") {
      writer.uint32(18).string(message.administrator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarkerActivate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarkerActivate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarkerActivate {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
    };
  },

  toJSON(message: EventMarkerActivate): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarkerActivate>, I>>(base?: I): EventMarkerActivate {
    return EventMarkerActivate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarkerActivate>, I>>(object: I): EventMarkerActivate {
    const message = createBaseEventMarkerActivate();
    message.denom = object.denom ?? "";
    message.administrator = object.administrator ?? "";
    return message;
  },
};

function createBaseEventMarkerCancel(): EventMarkerCancel {
  return { denom: "", administrator: "" };
}

export const EventMarkerCancel: MessageFns<EventMarkerCancel> = {
  encode(message: EventMarkerCancel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.administrator !== "") {
      writer.uint32(18).string(message.administrator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarkerCancel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarkerCancel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarkerCancel {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
    };
  },

  toJSON(message: EventMarkerCancel): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarkerCancel>, I>>(base?: I): EventMarkerCancel {
    return EventMarkerCancel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarkerCancel>, I>>(object: I): EventMarkerCancel {
    const message = createBaseEventMarkerCancel();
    message.denom = object.denom ?? "";
    message.administrator = object.administrator ?? "";
    return message;
  },
};

function createBaseEventMarkerDelete(): EventMarkerDelete {
  return { denom: "", administrator: "" };
}

export const EventMarkerDelete: MessageFns<EventMarkerDelete> = {
  encode(message: EventMarkerDelete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.administrator !== "") {
      writer.uint32(18).string(message.administrator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarkerDelete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarkerDelete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarkerDelete {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
    };
  },

  toJSON(message: EventMarkerDelete): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarkerDelete>, I>>(base?: I): EventMarkerDelete {
    return EventMarkerDelete.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarkerDelete>, I>>(object: I): EventMarkerDelete {
    const message = createBaseEventMarkerDelete();
    message.denom = object.denom ?? "";
    message.administrator = object.administrator ?? "";
    return message;
  },
};

function createBaseEventMarkerMint(): EventMarkerMint {
  return { amount: "", denom: "", administrator: "" };
}

export const EventMarkerMint: MessageFns<EventMarkerMint> = {
  encode(message: EventMarkerMint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    if (message.administrator !== "") {
      writer.uint32(26).string(message.administrator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarkerMint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarkerMint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarkerMint {
    return {
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
    };
  },

  toJSON(message: EventMarkerMint): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarkerMint>, I>>(base?: I): EventMarkerMint {
    return EventMarkerMint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarkerMint>, I>>(object: I): EventMarkerMint {
    const message = createBaseEventMarkerMint();
    message.amount = object.amount ?? "";
    message.denom = object.denom ?? "";
    message.administrator = object.administrator ?? "";
    return message;
  },
};

function createBaseEventMarkerBurn(): EventMarkerBurn {
  return { amount: "", denom: "", administrator: "" };
}

export const EventMarkerBurn: MessageFns<EventMarkerBurn> = {
  encode(message: EventMarkerBurn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    if (message.administrator !== "") {
      writer.uint32(26).string(message.administrator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarkerBurn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarkerBurn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarkerBurn {
    return {
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
    };
  },

  toJSON(message: EventMarkerBurn): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarkerBurn>, I>>(base?: I): EventMarkerBurn {
    return EventMarkerBurn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarkerBurn>, I>>(object: I): EventMarkerBurn {
    const message = createBaseEventMarkerBurn();
    message.amount = object.amount ?? "";
    message.denom = object.denom ?? "";
    message.administrator = object.administrator ?? "";
    return message;
  },
};

function createBaseEventMarkerWithdraw(): EventMarkerWithdraw {
  return { coins: "", denom: "", administrator: "", toAddress: "" };
}

export const EventMarkerWithdraw: MessageFns<EventMarkerWithdraw> = {
  encode(message: EventMarkerWithdraw, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coins !== "") {
      writer.uint32(10).string(message.coins);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    if (message.administrator !== "") {
      writer.uint32(26).string(message.administrator);
    }
    if (message.toAddress !== "") {
      writer.uint32(34).string(message.toAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarkerWithdraw {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarkerWithdraw();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.coins = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarkerWithdraw {
    return {
      coins: isSet(object.coins) ? globalThis.String(object.coins) : "",
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
      toAddress: isSet(object.toAddress) ? globalThis.String(object.toAddress) : "",
    };
  },

  toJSON(message: EventMarkerWithdraw): unknown {
    const obj: any = {};
    if (message.coins !== "") {
      obj.coins = message.coins;
    }
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    if (message.toAddress !== "") {
      obj.toAddress = message.toAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarkerWithdraw>, I>>(base?: I): EventMarkerWithdraw {
    return EventMarkerWithdraw.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarkerWithdraw>, I>>(object: I): EventMarkerWithdraw {
    const message = createBaseEventMarkerWithdraw();
    message.coins = object.coins ?? "";
    message.denom = object.denom ?? "";
    message.administrator = object.administrator ?? "";
    message.toAddress = object.toAddress ?? "";
    return message;
  },
};

function createBaseEventMarkerTransfer(): EventMarkerTransfer {
  return { amount: "", denom: "", administrator: "", toAddress: "", fromAddress: "" };
}

export const EventMarkerTransfer: MessageFns<EventMarkerTransfer> = {
  encode(message: EventMarkerTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== "") {
      writer.uint32(10).string(message.amount);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    if (message.administrator !== "") {
      writer.uint32(26).string(message.administrator);
    }
    if (message.toAddress !== "") {
      writer.uint32(34).string(message.toAddress);
    }
    if (message.fromAddress !== "") {
      writer.uint32(42).string(message.fromAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarkerTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarkerTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fromAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarkerTransfer {
    return {
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
      toAddress: isSet(object.toAddress) ? globalThis.String(object.toAddress) : "",
      fromAddress: isSet(object.fromAddress) ? globalThis.String(object.fromAddress) : "",
    };
  },

  toJSON(message: EventMarkerTransfer): unknown {
    const obj: any = {};
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    if (message.toAddress !== "") {
      obj.toAddress = message.toAddress;
    }
    if (message.fromAddress !== "") {
      obj.fromAddress = message.fromAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarkerTransfer>, I>>(base?: I): EventMarkerTransfer {
    return EventMarkerTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarkerTransfer>, I>>(object: I): EventMarkerTransfer {
    const message = createBaseEventMarkerTransfer();
    message.amount = object.amount ?? "";
    message.denom = object.denom ?? "";
    message.administrator = object.administrator ?? "";
    message.toAddress = object.toAddress ?? "";
    message.fromAddress = object.fromAddress ?? "";
    return message;
  },
};

function createBaseEventMarkerSetDenomMetadata(): EventMarkerSetDenomMetadata {
  return {
    metadataBase: "",
    metadataDescription: "",
    metadataDisplay: "",
    metadataDenomUnits: [],
    administrator: "",
    metadataName: "",
    metadataSymbol: "",
  };
}

export const EventMarkerSetDenomMetadata: MessageFns<EventMarkerSetDenomMetadata> = {
  encode(message: EventMarkerSetDenomMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadataBase !== "") {
      writer.uint32(10).string(message.metadataBase);
    }
    if (message.metadataDescription !== "") {
      writer.uint32(18).string(message.metadataDescription);
    }
    if (message.metadataDisplay !== "") {
      writer.uint32(26).string(message.metadataDisplay);
    }
    for (const v of message.metadataDenomUnits) {
      EventDenomUnit.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.administrator !== "") {
      writer.uint32(42).string(message.administrator);
    }
    if (message.metadataName !== "") {
      writer.uint32(50).string(message.metadataName);
    }
    if (message.metadataSymbol !== "") {
      writer.uint32(58).string(message.metadataSymbol);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarkerSetDenomMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarkerSetDenomMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadataBase = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadataDescription = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadataDisplay = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadataDenomUnits.push(EventDenomUnit.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadataName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.metadataSymbol = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarkerSetDenomMetadata {
    return {
      metadataBase: isSet(object.metadataBase) ? globalThis.String(object.metadataBase) : "",
      metadataDescription: isSet(object.metadataDescription) ? globalThis.String(object.metadataDescription) : "",
      metadataDisplay: isSet(object.metadataDisplay) ? globalThis.String(object.metadataDisplay) : "",
      metadataDenomUnits: globalThis.Array.isArray(object?.metadataDenomUnits)
        ? object.metadataDenomUnits.map((e: any) => EventDenomUnit.fromJSON(e))
        : [],
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
      metadataName: isSet(object.metadataName) ? globalThis.String(object.metadataName) : "",
      metadataSymbol: isSet(object.metadataSymbol) ? globalThis.String(object.metadataSymbol) : "",
    };
  },

  toJSON(message: EventMarkerSetDenomMetadata): unknown {
    const obj: any = {};
    if (message.metadataBase !== "") {
      obj.metadataBase = message.metadataBase;
    }
    if (message.metadataDescription !== "") {
      obj.metadataDescription = message.metadataDescription;
    }
    if (message.metadataDisplay !== "") {
      obj.metadataDisplay = message.metadataDisplay;
    }
    if (message.metadataDenomUnits?.length) {
      obj.metadataDenomUnits = message.metadataDenomUnits.map((e) => EventDenomUnit.toJSON(e));
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    if (message.metadataName !== "") {
      obj.metadataName = message.metadataName;
    }
    if (message.metadataSymbol !== "") {
      obj.metadataSymbol = message.metadataSymbol;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarkerSetDenomMetadata>, I>>(base?: I): EventMarkerSetDenomMetadata {
    return EventMarkerSetDenomMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarkerSetDenomMetadata>, I>>(object: I): EventMarkerSetDenomMetadata {
    const message = createBaseEventMarkerSetDenomMetadata();
    message.metadataBase = object.metadataBase ?? "";
    message.metadataDescription = object.metadataDescription ?? "";
    message.metadataDisplay = object.metadataDisplay ?? "";
    message.metadataDenomUnits = object.metadataDenomUnits?.map((e) => EventDenomUnit.fromPartial(e)) || [];
    message.administrator = object.administrator ?? "";
    message.metadataName = object.metadataName ?? "";
    message.metadataSymbol = object.metadataSymbol ?? "";
    return message;
  },
};

function createBaseEventDenomUnit(): EventDenomUnit {
  return { denom: "", exponent: "", aliases: [] };
}

export const EventDenomUnit: MessageFns<EventDenomUnit> = {
  encode(message: EventDenomUnit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.exponent !== "") {
      writer.uint32(18).string(message.exponent);
    }
    for (const v of message.aliases) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventDenomUnit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventDenomUnit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.exponent = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.aliases.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventDenomUnit {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      exponent: isSet(object.exponent) ? globalThis.String(object.exponent) : "",
      aliases: globalThis.Array.isArray(object?.aliases) ? object.aliases.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: EventDenomUnit): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.exponent !== "") {
      obj.exponent = message.exponent;
    }
    if (message.aliases?.length) {
      obj.aliases = message.aliases;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventDenomUnit>, I>>(base?: I): EventDenomUnit {
    return EventDenomUnit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventDenomUnit>, I>>(object: I): EventDenomUnit {
    const message = createBaseEventDenomUnit();
    message.denom = object.denom ?? "";
    message.exponent = object.exponent ?? "";
    message.aliases = object.aliases?.map((e) => e) || [];
    return message;
  },
};

function createBaseEventSetNetAssetValue(): EventSetNetAssetValue {
  return { denom: "", price: "", volume: "", source: "" };
}

export const EventSetNetAssetValue: MessageFns<EventSetNetAssetValue> = {
  encode(message: EventSetNetAssetValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.price !== "") {
      writer.uint32(18).string(message.price);
    }
    if (message.volume !== "") {
      writer.uint32(26).string(message.volume);
    }
    if (message.source !== "") {
      writer.uint32(34).string(message.source);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventSetNetAssetValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventSetNetAssetValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.price = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.volume = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.source = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventSetNetAssetValue {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      volume: isSet(object.volume) ? globalThis.String(object.volume) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
    };
  },

  toJSON(message: EventSetNetAssetValue): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.price !== "") {
      obj.price = message.price;
    }
    if (message.volume !== "") {
      obj.volume = message.volume;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventSetNetAssetValue>, I>>(base?: I): EventSetNetAssetValue {
    return EventSetNetAssetValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventSetNetAssetValue>, I>>(object: I): EventSetNetAssetValue {
    const message = createBaseEventSetNetAssetValue();
    message.denom = object.denom ?? "";
    message.price = object.price ?? "";
    message.volume = object.volume ?? "";
    message.source = object.source ?? "";
    return message;
  },
};

function createBaseEventMarkerParamsUpdated(): EventMarkerParamsUpdated {
  return { enableGovernance: "", unrestrictedDenomRegex: "", maxSupply: "" };
}

export const EventMarkerParamsUpdated: MessageFns<EventMarkerParamsUpdated> = {
  encode(message: EventMarkerParamsUpdated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enableGovernance !== "") {
      writer.uint32(10).string(message.enableGovernance);
    }
    if (message.unrestrictedDenomRegex !== "") {
      writer.uint32(18).string(message.unrestrictedDenomRegex);
    }
    if (message.maxSupply !== "") {
      writer.uint32(26).string(message.maxSupply);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarkerParamsUpdated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarkerParamsUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.enableGovernance = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.unrestrictedDenomRegex = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.maxSupply = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarkerParamsUpdated {
    return {
      enableGovernance: isSet(object.enableGovernance) ? globalThis.String(object.enableGovernance) : "",
      unrestrictedDenomRegex: isSet(object.unrestrictedDenomRegex)
        ? globalThis.String(object.unrestrictedDenomRegex)
        : "",
      maxSupply: isSet(object.maxSupply) ? globalThis.String(object.maxSupply) : "",
    };
  },

  toJSON(message: EventMarkerParamsUpdated): unknown {
    const obj: any = {};
    if (message.enableGovernance !== "") {
      obj.enableGovernance = message.enableGovernance;
    }
    if (message.unrestrictedDenomRegex !== "") {
      obj.unrestrictedDenomRegex = message.unrestrictedDenomRegex;
    }
    if (message.maxSupply !== "") {
      obj.maxSupply = message.maxSupply;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarkerParamsUpdated>, I>>(base?: I): EventMarkerParamsUpdated {
    return EventMarkerParamsUpdated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarkerParamsUpdated>, I>>(object: I): EventMarkerParamsUpdated {
    const message = createBaseEventMarkerParamsUpdated();
    message.enableGovernance = object.enableGovernance ?? "";
    message.unrestrictedDenomRegex = object.unrestrictedDenomRegex ?? "";
    message.maxSupply = object.maxSupply ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
