// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: provenance/marker/v1/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Metadata } from "../../../cosmos/bank/v1beta1/bank";
import { PageRequest, PageResponse } from "../../../cosmos/base/query/v1beta1/pagination";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { Any } from "../../../google/protobuf/any";
import { AccessGrant } from "./accessgrant";
import { MarkerStatus, markerStatusFromJSON, markerStatusToJSON, NetAssetValue, Params } from "./marker";

export const protobufPackage = "provenance.marker.v1";

/** QueryParamsRequest is the request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}

/** QueryParamsResponse is the response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
  /** params defines the parameters of the module. */
  params?: Params | undefined;
}

/** QueryAllMarkersRequest is the request type for the Query/AllMarkers method. */
export interface QueryAllMarkersRequest {
  /** Optional status to filter request */
  status: MarkerStatus;
  /** pagination defines an optional pagination for the request. */
  pagination?: PageRequest | undefined;
}

/** QueryAllMarkersResponse is the response type for the Query/AllMarkers method. */
export interface QueryAllMarkersResponse {
  markers: Any[];
  /** pagination defines an optional pagination for the request. */
  pagination?: PageResponse | undefined;
}

/** QueryMarkerRequest is the request type for the Query/Marker method. */
export interface QueryMarkerRequest {
  /** the address or denom of the marker */
  id: string;
}

/** QueryMarkerResponse is the response type for the Query/Marker method. */
export interface QueryMarkerResponse {
  marker?: Any | undefined;
}

/** QueryHoldingRequest is the request type for the Query/MarkerHolders method. */
export interface QueryHoldingRequest {
  /** the address or denom of the marker */
  id: string;
  /** pagination defines an optional pagination for the request. */
  pagination?: PageRequest | undefined;
}

/** QueryHoldingResponse is the response type for the Query/MarkerHolders method. */
export interface QueryHoldingResponse {
  balances: Balance[];
  /** pagination defines an optional pagination for the request. */
  pagination?: PageResponse | undefined;
}

/** QuerySupplyRequest is the request type for the Query/MarkerSupply method. */
export interface QuerySupplyRequest {
  /** address or denom for the marker */
  id: string;
}

/** QuerySupplyResponse is the response type for the Query/MarkerSupply method. */
export interface QuerySupplyResponse {
  /** amount is the supply of the marker. */
  amount?: Coin | undefined;
}

/** QueryEscrowRequest is the request type for the Query/MarkerEscrow method. */
export interface QueryEscrowRequest {
  /** address or denom for the marker */
  id: string;
}

/** QueryEscrowResponse is the response type for the Query/MarkerEscrow method. */
export interface QueryEscrowResponse {
  escrow: Coin[];
}

/** QueryAccessRequest is the request type for the Query/MarkerAccess method. */
export interface QueryAccessRequest {
  /** address or denom for the marker */
  id: string;
}

/** QueryAccessResponse is the response type for the Query/MarkerAccess method. */
export interface QueryAccessResponse {
  accounts: AccessGrant[];
}

/** QueryDenomMetadataRequest is the request type for Query/DenomMetadata */
export interface QueryDenomMetadataRequest {
  denom: string;
}

/** QueryDenomMetadataResponse is the response type for the Query/DenomMetadata */
export interface QueryDenomMetadataResponse {
  metadata?: Metadata | undefined;
}

/** QueryAccountDataRequest is the request type for the Query/AccountData */
export interface QueryAccountDataRequest {
  /** The denomination to look up. */
  denom: string;
}

/** QueryAccountDataResponse is the response type for the Query/AccountData */
export interface QueryAccountDataResponse {
  /** The accountdata for the requested denom. */
  value: string;
}

/** Balance defines an account address and balance pair used in queries for accounts holding a marker */
export interface Balance {
  /** address is the address of the balance holder. */
  address: string;
  /** coins defines the different coins this balance holds. */
  coins: Coin[];
}

/** QueryNetAssetValuesRequest is the request type for the Query/NetAssetValues method. */
export interface QueryNetAssetValuesRequest {
  /** address or denom for the marker */
  id: string;
}

/** QueryNetAssetValuesRequest is the response type for the Query/NetAssetValues method. */
export interface QueryNetAssetValuesResponse {
  /** net asset values for marker denom */
  netAssetValues: NetAssetValue[];
}

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(_: QueryParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(base?: I): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(_: I): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(message: QueryParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(base?: I): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(object: I): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryAllMarkersRequest(): QueryAllMarkersRequest {
  return { status: 0, pagination: undefined };
}

export const QueryAllMarkersRequest: MessageFns<QueryAllMarkersRequest> = {
  encode(message: QueryAllMarkersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllMarkersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllMarkersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllMarkersRequest {
    return {
      status: isSet(object.status) ? markerStatusFromJSON(object.status) : 0,
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAllMarkersRequest): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = markerStatusToJSON(message.status);
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllMarkersRequest>, I>>(base?: I): QueryAllMarkersRequest {
    return QueryAllMarkersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllMarkersRequest>, I>>(object: I): QueryAllMarkersRequest {
    const message = createBaseQueryAllMarkersRequest();
    message.status = object.status ?? 0;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAllMarkersResponse(): QueryAllMarkersResponse {
  return { markers: [], pagination: undefined };
}

export const QueryAllMarkersResponse: MessageFns<QueryAllMarkersResponse> = {
  encode(message: QueryAllMarkersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.markers) {
      Any.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAllMarkersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAllMarkersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.markers.push(Any.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAllMarkersResponse {
    return {
      markers: globalThis.Array.isArray(object?.markers) ? object.markers.map((e: any) => Any.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAllMarkersResponse): unknown {
    const obj: any = {};
    if (message.markers?.length) {
      obj.markers = message.markers.map((e) => Any.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAllMarkersResponse>, I>>(base?: I): QueryAllMarkersResponse {
    return QueryAllMarkersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAllMarkersResponse>, I>>(object: I): QueryAllMarkersResponse {
    const message = createBaseQueryAllMarkersResponse();
    message.markers = object.markers?.map((e) => Any.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryMarkerRequest(): QueryMarkerRequest {
  return { id: "" };
}

export const QueryMarkerRequest: MessageFns<QueryMarkerRequest> = {
  encode(message: QueryMarkerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryMarkerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryMarkerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryMarkerRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: QueryMarkerRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryMarkerRequest>, I>>(base?: I): QueryMarkerRequest {
    return QueryMarkerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryMarkerRequest>, I>>(object: I): QueryMarkerRequest {
    const message = createBaseQueryMarkerRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseQueryMarkerResponse(): QueryMarkerResponse {
  return { marker: undefined };
}

export const QueryMarkerResponse: MessageFns<QueryMarkerResponse> = {
  encode(message: QueryMarkerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marker !== undefined) {
      Any.encode(message.marker, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryMarkerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryMarkerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.marker = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryMarkerResponse {
    return { marker: isSet(object.marker) ? Any.fromJSON(object.marker) : undefined };
  },

  toJSON(message: QueryMarkerResponse): unknown {
    const obj: any = {};
    if (message.marker !== undefined) {
      obj.marker = Any.toJSON(message.marker);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryMarkerResponse>, I>>(base?: I): QueryMarkerResponse {
    return QueryMarkerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryMarkerResponse>, I>>(object: I): QueryMarkerResponse {
    const message = createBaseQueryMarkerResponse();
    message.marker = (object.marker !== undefined && object.marker !== null)
      ? Any.fromPartial(object.marker)
      : undefined;
    return message;
  },
};

function createBaseQueryHoldingRequest(): QueryHoldingRequest {
  return { id: "", pagination: undefined };
}

export const QueryHoldingRequest: MessageFns<QueryHoldingRequest> = {
  encode(message: QueryHoldingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryHoldingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryHoldingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryHoldingRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryHoldingRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryHoldingRequest>, I>>(base?: I): QueryHoldingRequest {
    return QueryHoldingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryHoldingRequest>, I>>(object: I): QueryHoldingRequest {
    const message = createBaseQueryHoldingRequest();
    message.id = object.id ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryHoldingResponse(): QueryHoldingResponse {
  return { balances: [], pagination: undefined };
}

export const QueryHoldingResponse: MessageFns<QueryHoldingResponse> = {
  encode(message: QueryHoldingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.balances) {
      Balance.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryHoldingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryHoldingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.balances.push(Balance.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryHoldingResponse {
    return {
      balances: globalThis.Array.isArray(object?.balances) ? object.balances.map((e: any) => Balance.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryHoldingResponse): unknown {
    const obj: any = {};
    if (message.balances?.length) {
      obj.balances = message.balances.map((e) => Balance.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryHoldingResponse>, I>>(base?: I): QueryHoldingResponse {
    return QueryHoldingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryHoldingResponse>, I>>(object: I): QueryHoldingResponse {
    const message = createBaseQueryHoldingResponse();
    message.balances = object.balances?.map((e) => Balance.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQuerySupplyRequest(): QuerySupplyRequest {
  return { id: "" };
}

export const QuerySupplyRequest: MessageFns<QuerySupplyRequest> = {
  encode(message: QuerySupplyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySupplyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySupplyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySupplyRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: QuerySupplyRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySupplyRequest>, I>>(base?: I): QuerySupplyRequest {
    return QuerySupplyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySupplyRequest>, I>>(object: I): QuerySupplyRequest {
    const message = createBaseQuerySupplyRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseQuerySupplyResponse(): QuerySupplyResponse {
  return { amount: undefined };
}

export const QuerySupplyResponse: MessageFns<QuerySupplyResponse> = {
  encode(message: QuerySupplyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySupplyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySupplyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySupplyResponse {
    return { amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined };
  },

  toJSON(message: QuerySupplyResponse): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = Coin.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySupplyResponse>, I>>(base?: I): QuerySupplyResponse {
    return QuerySupplyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySupplyResponse>, I>>(object: I): QuerySupplyResponse {
    const message = createBaseQuerySupplyResponse();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseQueryEscrowRequest(): QueryEscrowRequest {
  return { id: "" };
}

export const QueryEscrowRequest: MessageFns<QueryEscrowRequest> = {
  encode(message: QueryEscrowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEscrowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEscrowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEscrowRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: QueryEscrowRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEscrowRequest>, I>>(base?: I): QueryEscrowRequest {
    return QueryEscrowRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEscrowRequest>, I>>(object: I): QueryEscrowRequest {
    const message = createBaseQueryEscrowRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseQueryEscrowResponse(): QueryEscrowResponse {
  return { escrow: [] };
}

export const QueryEscrowResponse: MessageFns<QueryEscrowResponse> = {
  encode(message: QueryEscrowResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.escrow) {
      Coin.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEscrowResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEscrowResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.escrow.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEscrowResponse {
    return { escrow: globalThis.Array.isArray(object?.escrow) ? object.escrow.map((e: any) => Coin.fromJSON(e)) : [] };
  },

  toJSON(message: QueryEscrowResponse): unknown {
    const obj: any = {};
    if (message.escrow?.length) {
      obj.escrow = message.escrow.map((e) => Coin.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEscrowResponse>, I>>(base?: I): QueryEscrowResponse {
    return QueryEscrowResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEscrowResponse>, I>>(object: I): QueryEscrowResponse {
    const message = createBaseQueryEscrowResponse();
    message.escrow = object.escrow?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryAccessRequest(): QueryAccessRequest {
  return { id: "" };
}

export const QueryAccessRequest: MessageFns<QueryAccessRequest> = {
  encode(message: QueryAccessRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAccessRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAccessRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAccessRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: QueryAccessRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAccessRequest>, I>>(base?: I): QueryAccessRequest {
    return QueryAccessRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAccessRequest>, I>>(object: I): QueryAccessRequest {
    const message = createBaseQueryAccessRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseQueryAccessResponse(): QueryAccessResponse {
  return { accounts: [] };
}

export const QueryAccessResponse: MessageFns<QueryAccessResponse> = {
  encode(message: QueryAccessResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.accounts) {
      AccessGrant.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAccessResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAccessResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accounts.push(AccessGrant.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAccessResponse {
    return {
      accounts: globalThis.Array.isArray(object?.accounts)
        ? object.accounts.map((e: any) => AccessGrant.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryAccessResponse): unknown {
    const obj: any = {};
    if (message.accounts?.length) {
      obj.accounts = message.accounts.map((e) => AccessGrant.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAccessResponse>, I>>(base?: I): QueryAccessResponse {
    return QueryAccessResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAccessResponse>, I>>(object: I): QueryAccessResponse {
    const message = createBaseQueryAccessResponse();
    message.accounts = object.accounts?.map((e) => AccessGrant.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryDenomMetadataRequest(): QueryDenomMetadataRequest {
  return { denom: "" };
}

export const QueryDenomMetadataRequest: MessageFns<QueryDenomMetadataRequest> = {
  encode(message: QueryDenomMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryDenomMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDenomMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryDenomMetadataRequest {
    return { denom: isSet(object.denom) ? globalThis.String(object.denom) : "" };
  },

  toJSON(message: QueryDenomMetadataRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryDenomMetadataRequest>, I>>(base?: I): QueryDenomMetadataRequest {
    return QueryDenomMetadataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryDenomMetadataRequest>, I>>(object: I): QueryDenomMetadataRequest {
    const message = createBaseQueryDenomMetadataRequest();
    message.denom = object.denom ?? "";
    return message;
  },
};

function createBaseQueryDenomMetadataResponse(): QueryDenomMetadataResponse {
  return { metadata: undefined };
}

export const QueryDenomMetadataResponse: MessageFns<QueryDenomMetadataResponse> = {
  encode(message: QueryDenomMetadataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryDenomMetadataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDenomMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryDenomMetadataResponse {
    return { metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined };
  },

  toJSON(message: QueryDenomMetadataResponse): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryDenomMetadataResponse>, I>>(base?: I): QueryDenomMetadataResponse {
    return QueryDenomMetadataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryDenomMetadataResponse>, I>>(object: I): QueryDenomMetadataResponse {
    const message = createBaseQueryDenomMetadataResponse();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseQueryAccountDataRequest(): QueryAccountDataRequest {
  return { denom: "" };
}

export const QueryAccountDataRequest: MessageFns<QueryAccountDataRequest> = {
  encode(message: QueryAccountDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAccountDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAccountDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAccountDataRequest {
    return { denom: isSet(object.denom) ? globalThis.String(object.denom) : "" };
  },

  toJSON(message: QueryAccountDataRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAccountDataRequest>, I>>(base?: I): QueryAccountDataRequest {
    return QueryAccountDataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAccountDataRequest>, I>>(object: I): QueryAccountDataRequest {
    const message = createBaseQueryAccountDataRequest();
    message.denom = object.denom ?? "";
    return message;
  },
};

function createBaseQueryAccountDataResponse(): QueryAccountDataResponse {
  return { value: "" };
}

export const QueryAccountDataResponse: MessageFns<QueryAccountDataResponse> = {
  encode(message: QueryAccountDataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAccountDataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAccountDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAccountDataResponse {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: QueryAccountDataResponse): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryAccountDataResponse>, I>>(base?: I): QueryAccountDataResponse {
    return QueryAccountDataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryAccountDataResponse>, I>>(object: I): QueryAccountDataResponse {
    const message = createBaseQueryAccountDataResponse();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBalance(): Balance {
  return { address: "", coins: [] };
}

export const Balance: MessageFns<Balance> = {
  encode(message: Balance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    for (const v of message.coins) {
      Coin.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Balance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.coins.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Balance {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      coins: globalThis.Array.isArray(object?.coins) ? object.coins.map((e: any) => Coin.fromJSON(e)) : [],
    };
  },

  toJSON(message: Balance): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.coins?.length) {
      obj.coins = message.coins.map((e) => Coin.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Balance>, I>>(base?: I): Balance {
    return Balance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Balance>, I>>(object: I): Balance {
    const message = createBaseBalance();
    message.address = object.address ?? "";
    message.coins = object.coins?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryNetAssetValuesRequest(): QueryNetAssetValuesRequest {
  return { id: "" };
}

export const QueryNetAssetValuesRequest: MessageFns<QueryNetAssetValuesRequest> = {
  encode(message: QueryNetAssetValuesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryNetAssetValuesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryNetAssetValuesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryNetAssetValuesRequest {
    return { id: isSet(object.id) ? globalThis.String(object.id) : "" };
  },

  toJSON(message: QueryNetAssetValuesRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryNetAssetValuesRequest>, I>>(base?: I): QueryNetAssetValuesRequest {
    return QueryNetAssetValuesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryNetAssetValuesRequest>, I>>(object: I): QueryNetAssetValuesRequest {
    const message = createBaseQueryNetAssetValuesRequest();
    message.id = object.id ?? "";
    return message;
  },
};

function createBaseQueryNetAssetValuesResponse(): QueryNetAssetValuesResponse {
  return { netAssetValues: [] };
}

export const QueryNetAssetValuesResponse: MessageFns<QueryNetAssetValuesResponse> = {
  encode(message: QueryNetAssetValuesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.netAssetValues) {
      NetAssetValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryNetAssetValuesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryNetAssetValuesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.netAssetValues.push(NetAssetValue.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryNetAssetValuesResponse {
    return {
      netAssetValues: globalThis.Array.isArray(object?.netAssetValues)
        ? object.netAssetValues.map((e: any) => NetAssetValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryNetAssetValuesResponse): unknown {
    const obj: any = {};
    if (message.netAssetValues?.length) {
      obj.netAssetValues = message.netAssetValues.map((e) => NetAssetValue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryNetAssetValuesResponse>, I>>(base?: I): QueryNetAssetValuesResponse {
    return QueryNetAssetValuesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryNetAssetValuesResponse>, I>>(object: I): QueryNetAssetValuesResponse {
    const message = createBaseQueryNetAssetValuesResponse();
    message.netAssetValues = object.netAssetValues?.map((e) => NetAssetValue.fromPartial(e)) || [];
    return message;
  },
};

/** Query defines the gRPC querier service for marker module. */
export interface Query {
  /** Params queries the parameters of x/bank module. */
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
  /** Returns a list of all markers on the blockchain */
  AllMarkers(request: QueryAllMarkersRequest): Promise<QueryAllMarkersResponse>;
  /** query for a single marker by denom or address */
  Marker(request: QueryMarkerRequest): Promise<QueryMarkerResponse>;
  /** query for all accounts holding the given marker coins */
  Holding(request: QueryHoldingRequest): Promise<QueryHoldingResponse>;
  /** query for supply of coin on a marker account */
  Supply(request: QuerySupplyRequest): Promise<QuerySupplyResponse>;
  /** query for coins on a marker account */
  Escrow(request: QueryEscrowRequest): Promise<QueryEscrowResponse>;
  /** query for access records on an account */
  Access(request: QueryAccessRequest): Promise<QueryAccessResponse>;
  /** query for access records on an account */
  DenomMetadata(request: QueryDenomMetadataRequest): Promise<QueryDenomMetadataResponse>;
  /** query for account data associated with a denom */
  AccountData(request: QueryAccountDataRequest): Promise<QueryAccountDataResponse>;
  /** NetAssetValues returns net asset values for marker */
  NetAssetValues(request: QueryNetAssetValuesRequest): Promise<QueryNetAssetValuesResponse>;
}

export const QueryServiceName = "provenance.marker.v1.Query";
export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceName;
    this.rpc = rpc;
    this.Params = this.Params.bind(this);
    this.AllMarkers = this.AllMarkers.bind(this);
    this.Marker = this.Marker.bind(this);
    this.Holding = this.Holding.bind(this);
    this.Supply = this.Supply.bind(this);
    this.Escrow = this.Escrow.bind(this);
    this.Access = this.Access.bind(this);
    this.DenomMetadata = this.DenomMetadata.bind(this);
    this.AccountData = this.AccountData.bind(this);
    this.NetAssetValues = this.NetAssetValues.bind(this);
  }
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse> {
    const data = QueryParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Params", data);
    return promise.then((data) => QueryParamsResponse.decode(new BinaryReader(data)));
  }

  AllMarkers(request: QueryAllMarkersRequest): Promise<QueryAllMarkersResponse> {
    const data = QueryAllMarkersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AllMarkers", data);
    return promise.then((data) => QueryAllMarkersResponse.decode(new BinaryReader(data)));
  }

  Marker(request: QueryMarkerRequest): Promise<QueryMarkerResponse> {
    const data = QueryMarkerRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Marker", data);
    return promise.then((data) => QueryMarkerResponse.decode(new BinaryReader(data)));
  }

  Holding(request: QueryHoldingRequest): Promise<QueryHoldingResponse> {
    const data = QueryHoldingRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Holding", data);
    return promise.then((data) => QueryHoldingResponse.decode(new BinaryReader(data)));
  }

  Supply(request: QuerySupplyRequest): Promise<QuerySupplyResponse> {
    const data = QuerySupplyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Supply", data);
    return promise.then((data) => QuerySupplyResponse.decode(new BinaryReader(data)));
  }

  Escrow(request: QueryEscrowRequest): Promise<QueryEscrowResponse> {
    const data = QueryEscrowRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Escrow", data);
    return promise.then((data) => QueryEscrowResponse.decode(new BinaryReader(data)));
  }

  Access(request: QueryAccessRequest): Promise<QueryAccessResponse> {
    const data = QueryAccessRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Access", data);
    return promise.then((data) => QueryAccessResponse.decode(new BinaryReader(data)));
  }

  DenomMetadata(request: QueryDenomMetadataRequest): Promise<QueryDenomMetadataResponse> {
    const data = QueryDenomMetadataRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DenomMetadata", data);
    return promise.then((data) => QueryDenomMetadataResponse.decode(new BinaryReader(data)));
  }

  AccountData(request: QueryAccountDataRequest): Promise<QueryAccountDataResponse> {
    const data = QueryAccountDataRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AccountData", data);
    return promise.then((data) => QueryAccountDataResponse.decode(new BinaryReader(data)));
  }

  NetAssetValues(request: QueryNetAssetValuesRequest): Promise<QueryNetAssetValuesResponse> {
    const data = QueryNetAssetValuesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NetAssetValues", data);
    return promise.then((data) => QueryNetAssetValuesResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
