// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: provenance/marker/v1/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Metadata } from "../../../cosmos/bank/v1beta1/bank";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { Any } from "../../../google/protobuf/any";
import { MsgTransfer } from "../../../ibc/applications/transfer/v1/tx";
import { AccessGrant } from "./accessgrant";
import {
  MarkerStatus,
  markerStatusFromJSON,
  markerStatusToJSON,
  MarkerType,
  markerTypeFromJSON,
  markerTypeToJSON,
  NetAssetValue,
  Params,
} from "./marker";

export const protobufPackage = "provenance.marker.v1";

/**
 * MsgGrantAllowanceRequest validates permission to create a fee grant based on marker admin access. If
 * successful a feegrant is recorded where the marker account itself is the grantor
 */
export interface MsgGrantAllowanceRequest {
  denom: string;
  administrator: string;
  /** grantee is the address of the user being granted an allowance of another user's funds. */
  grantee: string;
  /** allowance can be any of basic and filtered fee allowance (fee FeeGrant module). */
  allowance?: Any | undefined;
}

/** MsgGrantAllowanceResponse defines the Msg/GrantAllowanceResponse response type. */
export interface MsgGrantAllowanceResponse {
}

/**
 * MsgAddMarkerRequest defines the Msg/AddMarker request type.
 * If being provided as a governance proposal, set the from_address to the gov module's account address.
 */
export interface MsgAddMarkerRequest {
  amount?: Coin | undefined;
  manager: string;
  fromAddress: string;
  status: MarkerStatus;
  markerType: MarkerType;
  accessList: AccessGrant[];
  supplyFixed: boolean;
  allowGovernanceControl: boolean;
  allowForcedTransfer: boolean;
  requiredAttributes: string[];
  /** @deprecated */
  usdCents: Long;
  volume: Long;
  usdMills: Long;
}

/** MsgAddMarkerResponse defines the Msg/AddMarker response type */
export interface MsgAddMarkerResponse {
}

/** MsgAddAccessRequest defines the Msg/AddAccess request type */
export interface MsgAddAccessRequest {
  denom: string;
  administrator: string;
  access: AccessGrant[];
}

/** MsgAddAccessResponse defines the Msg/AddAccess response type */
export interface MsgAddAccessResponse {
}

/** MsgDeleteAccessRequest defines the Msg/DeleteAccess request type */
export interface MsgDeleteAccessRequest {
  denom: string;
  administrator: string;
  removedAddress: string;
}

/** MsgDeleteAccessResponse defines the Msg/DeleteAccess response type */
export interface MsgDeleteAccessResponse {
}

/** MsgFinalizeRequest defines the Msg/Finalize request type */
export interface MsgFinalizeRequest {
  denom: string;
  administrator: string;
}

/** MsgFinalizeResponse defines the Msg/Finalize response type */
export interface MsgFinalizeResponse {
}

/** MsgActivateRequest defines the Msg/Activate request type */
export interface MsgActivateRequest {
  denom: string;
  administrator: string;
}

/** MsgActivateResponse defines the Msg/Activate response type */
export interface MsgActivateResponse {
}

/** MsgCancelRequest defines the Msg/Cancel request type */
export interface MsgCancelRequest {
  denom: string;
  administrator: string;
}

/** MsgCancelResponse defines the Msg/Cancel response type */
export interface MsgCancelResponse {
}

/** MsgDeleteRequest defines the Msg/Delete request type */
export interface MsgDeleteRequest {
  denom: string;
  administrator: string;
}

/** MsgDeleteResponse defines the Msg/Delete response type */
export interface MsgDeleteResponse {
}

/** MsgMintRequest defines the Msg/Mint request type */
export interface MsgMintRequest {
  amount?: Coin | undefined;
  administrator: string;
}

/** MsgMintResponse defines the Msg/Mint response type */
export interface MsgMintResponse {
}

/** MsgBurnRequest defines the Msg/Burn request type */
export interface MsgBurnRequest {
  amount?: Coin | undefined;
  administrator: string;
}

/** MsgBurnResponse defines the Msg/Burn response type */
export interface MsgBurnResponse {
}

/** MsgWithdrawRequest defines the Msg/Withdraw request type */
export interface MsgWithdrawRequest {
  denom: string;
  administrator: string;
  toAddress: string;
  amount: Coin[];
}

/** MsgWithdrawResponse defines the Msg/Withdraw response type */
export interface MsgWithdrawResponse {
}

/** MsgTransferRequest defines the Msg/Transfer request type */
export interface MsgTransferRequest {
  amount?: Coin | undefined;
  administrator: string;
  fromAddress: string;
  toAddress: string;
}

/** MsgTransferResponse defines the Msg/Transfer response type */
export interface MsgTransferResponse {
}

/** MsgIbcTransferRequest defines the Msg/IbcTransfer request type for markers. */
export interface MsgIbcTransferRequest {
  transfer?: MsgTransfer | undefined;
  administrator: string;
}

/** MsgIbcTransferResponse defines the Msg/IbcTransfer response type */
export interface MsgIbcTransferResponse {
}

/** MsgSetDenomMetadataRequest defines the Msg/SetDenomMetadata request type */
export interface MsgSetDenomMetadataRequest {
  metadata?: Metadata | undefined;
  administrator: string;
}

/** MsgSetDenomMetadataResponse defines the Msg/SetDenomMetadata response type */
export interface MsgSetDenomMetadataResponse {
}

/** MsgAddFinalizeActivateMarkerRequest defines the Msg/AddFinalizeActivateMarker request type */
export interface MsgAddFinalizeActivateMarkerRequest {
  amount?: Coin | undefined;
  manager: string;
  fromAddress: string;
  markerType: MarkerType;
  accessList: AccessGrant[];
  supplyFixed: boolean;
  allowGovernanceControl: boolean;
  allowForcedTransfer: boolean;
  requiredAttributes: string[];
  /** @deprecated */
  usdCents: Long;
  volume: Long;
  usdMills: Long;
}

/** MsgAddFinalizeActivateMarkerResponse defines the Msg/AddFinalizeActivateMarker response type */
export interface MsgAddFinalizeActivateMarkerResponse {
}

/**
 * MsgSupplyIncreaseProposalRequest defines a governance proposal to administer a marker and increase total supply of
 * the marker through minting coin and placing it within the marker or assigning it directly to an account
 */
export interface MsgSupplyIncreaseProposalRequest {
  amount?:
    | Coin
    | undefined;
  /** an optional target address for the minted coin from this request */
  targetAddress: string;
  /** signer of the proposal */
  authority: string;
}

/** MsgSupplyIncreaseProposalResponse defines the Msg/SupplyIncreaseProposal response type */
export interface MsgSupplyIncreaseProposalResponse {
}

/** MsgSupplyDecreaseProposalRequest defines a governance proposal to decrease total supply of the marker */
export interface MsgSupplyDecreaseProposalRequest {
  amount?:
    | Coin
    | undefined;
  /** signer of the proposal */
  authority: string;
}

/** MsgSupplyIncreaseProposalResponse defines the Msg/SupplyDecreaseProposal response type */
export interface MsgSupplyDecreaseProposalResponse {
}

/**
 * MsgUpdateRequiredAttributesRequest defines a msg to update/add/remove required attributes from a resticted marker
 * signer must have transfer authority to change attributes, to update attribute add current to remove list and new to
 * add list
 */
export interface MsgUpdateRequiredAttributesRequest {
  /** The denomination of the marker to update. */
  denom: string;
  /** List of required attributes to remove from marker. */
  removeRequiredAttributes: string[];
  /** List of required attributes to add to marker. */
  addRequiredAttributes: string[];
  /** The signer of the message.  Must have transfer authority to marker or be governance module account address. */
  transferAuthority: string;
}

/** MsgUpdateRequiredAttributesResponse defines the Msg/UpdateRequiredAttributes response type */
export interface MsgUpdateRequiredAttributesResponse {
}

/**
 * MsgUpdateForcedTransferRequest defines a msg to update the allow_forced_transfer field of a marker.
 * It is only usable via governance proposal.
 */
export interface MsgUpdateForcedTransferRequest {
  /** The denomination of the marker to update. */
  denom: string;
  /** Whether an admin can transfer restricted coins from a 3rd-party account without their signature. */
  allowForcedTransfer: boolean;
  /** The signer of this message. Must be the governance module account address. */
  authority: string;
}

/** MsgUpdateForcedTransferResponse defines the Msg/UpdateForcedTransfer response type */
export interface MsgUpdateForcedTransferResponse {
}

/**
 * MsgSetAccountDataRequest defines a msg to set/update/delete the account data for a marker.
 * Signer must have deposit authority or be a gov proposal.
 */
export interface MsgSetAccountDataRequest {
  /** The denomination of the marker to update. */
  denom: string;
  /** The desired accountdata value. */
  value: string;
  /** The signer of this message. Must have deposit authority or be the governance module account address. */
  signer: string;
}

/** MsgSetAccountDataResponse defines the Msg/SetAccountData response type */
export interface MsgSetAccountDataResponse {
}

/**
 * MsgUpdateSendDenyListRequest defines a msg to add/remove addresses to send deny list for a resticted marker
 * signer must have transfer authority
 */
export interface MsgUpdateSendDenyListRequest {
  /** The denomination of the marker to update. */
  denom: string;
  /** List of bech32 addresses to remove from the deny send list. */
  removeDeniedAddresses: string[];
  /** List of bech32 addresses to add to the deny send list. */
  addDeniedAddresses: string[];
  /** The signer of the message.  Must have admin authority to marker or be governance module account address. */
  authority: string;
}

/** MsgUpdateSendDenyListResponse defines the Msg/UpdateSendDenyList response type */
export interface MsgUpdateSendDenyListResponse {
}

/** MsgAddNetAssetValuesRequest defines the Msg/AddNetAssetValues request type */
export interface MsgAddNetAssetValuesRequest {
  denom: string;
  administrator: string;
  netAssetValues: NetAssetValue[];
}

/** MsgAddNetAssetValuesResponse defines the Msg/AddNetAssetValue response type */
export interface MsgAddNetAssetValuesResponse {
}

/** MsgSetAdministratorProposalRequest defines the Msg/SetAdministratorProposal request type */
export interface MsgSetAdministratorProposalRequest {
  denom: string;
  access: AccessGrant[];
  /** The signer of the message.  Must have admin authority to marker or be governance module account address. */
  authority: string;
}

/** MsgSetAdministratorProposalResponse defines the Msg/SetAdministratorProposal response type */
export interface MsgSetAdministratorProposalResponse {
}

/** MsgRemoveAdministratorProposalRequest defines the Msg/RemoveAdministratorProposal request type */
export interface MsgRemoveAdministratorProposalRequest {
  denom: string;
  removedAddress: string[];
  /** The signer of the message.  Must have admin authority to marker or be governance module account address. */
  authority: string;
}

/** MsgRemoveAdministratorProposalResponse defines the Msg/RemoveAdministratorProposal response type */
export interface MsgRemoveAdministratorProposalResponse {
}

/** MsgChangeStatusProposalRequest defines the Msg/ChangeStatusProposal request type */
export interface MsgChangeStatusProposalRequest {
  denom: string;
  newStatus: MarkerStatus;
  /** The signer of the message.  Must have admin authority to marker or be governance module account address. */
  authority: string;
}

/** MsgChangeStatusProposalResponse defines the Msg/ChangeStatusProposal response type */
export interface MsgChangeStatusProposalResponse {
}

/** MsgWithdrawEscrowProposalRequest defines the Msg/WithdrawEscrowProposal request type */
export interface MsgWithdrawEscrowProposalRequest {
  denom: string;
  amount: Coin[];
  targetAddress: string;
  /** The signer of the message.  Must have admin authority to marker or be governance module account address. */
  authority: string;
}

/** MsgWithdrawEscrowProposalResponse defines the Msg/WithdrawEscrowProposal response type */
export interface MsgWithdrawEscrowProposalResponse {
}

/** MsgSetDenomMetadataProposalRequest defines the Msg/SetDenomMetadataProposal request type */
export interface MsgSetDenomMetadataProposalRequest {
  metadata?:
    | Metadata
    | undefined;
  /** The signer of the message.  Must have admin authority to marker or be governance module account address. */
  authority: string;
}

/** MsgSetDenomMetadataProposalResponse defines the Msg/SetDenomMetadataProposal response type */
export interface MsgSetDenomMetadataProposalResponse {
}

/** MsgUpdateParamsRequest is a request message for the UpdateParams endpoint. */
export interface MsgUpdateParamsRequest {
  /** authority should be the governance module account address. */
  authority: string;
  /** params are the new param values to set. */
  params?: Params | undefined;
}

/** MsgUpdateParamsResponse is a response message for the UpdateParams endpoint. */
export interface MsgUpdateParamsResponse {
}

function createBaseMsgGrantAllowanceRequest(): MsgGrantAllowanceRequest {
  return { denom: "", administrator: "", grantee: "", allowance: undefined };
}

export const MsgGrantAllowanceRequest: MessageFns<MsgGrantAllowanceRequest> = {
  encode(message: MsgGrantAllowanceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.administrator !== "") {
      writer.uint32(18).string(message.administrator);
    }
    if (message.grantee !== "") {
      writer.uint32(26).string(message.grantee);
    }
    if (message.allowance !== undefined) {
      Any.encode(message.allowance, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGrantAllowanceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGrantAllowanceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.grantee = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.allowance = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGrantAllowanceRequest {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
      grantee: isSet(object.grantee) ? globalThis.String(object.grantee) : "",
      allowance: isSet(object.allowance) ? Any.fromJSON(object.allowance) : undefined,
    };
  },

  toJSON(message: MsgGrantAllowanceRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    if (message.grantee !== "") {
      obj.grantee = message.grantee;
    }
    if (message.allowance !== undefined) {
      obj.allowance = Any.toJSON(message.allowance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGrantAllowanceRequest>, I>>(base?: I): MsgGrantAllowanceRequest {
    return MsgGrantAllowanceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGrantAllowanceRequest>, I>>(object: I): MsgGrantAllowanceRequest {
    const message = createBaseMsgGrantAllowanceRequest();
    message.denom = object.denom ?? "";
    message.administrator = object.administrator ?? "";
    message.grantee = object.grantee ?? "";
    message.allowance = (object.allowance !== undefined && object.allowance !== null)
      ? Any.fromPartial(object.allowance)
      : undefined;
    return message;
  },
};

function createBaseMsgGrantAllowanceResponse(): MsgGrantAllowanceResponse {
  return {};
}

export const MsgGrantAllowanceResponse: MessageFns<MsgGrantAllowanceResponse> = {
  encode(_: MsgGrantAllowanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGrantAllowanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGrantAllowanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgGrantAllowanceResponse {
    return {};
  },

  toJSON(_: MsgGrantAllowanceResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGrantAllowanceResponse>, I>>(base?: I): MsgGrantAllowanceResponse {
    return MsgGrantAllowanceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGrantAllowanceResponse>, I>>(_: I): MsgGrantAllowanceResponse {
    const message = createBaseMsgGrantAllowanceResponse();
    return message;
  },
};

function createBaseMsgAddMarkerRequest(): MsgAddMarkerRequest {
  return {
    amount: undefined,
    manager: "",
    fromAddress: "",
    status: 0,
    markerType: 0,
    accessList: [],
    supplyFixed: false,
    allowGovernanceControl: false,
    allowForcedTransfer: false,
    requiredAttributes: [],
    usdCents: Long.UZERO,
    volume: Long.UZERO,
    usdMills: Long.UZERO,
  };
}

export const MsgAddMarkerRequest: MessageFns<MsgAddMarkerRequest> = {
  encode(message: MsgAddMarkerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(10).fork()).join();
    }
    if (message.manager !== "") {
      writer.uint32(26).string(message.manager);
    }
    if (message.fromAddress !== "") {
      writer.uint32(34).string(message.fromAddress);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.markerType !== 0) {
      writer.uint32(48).int32(message.markerType);
    }
    for (const v of message.accessList) {
      AccessGrant.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.supplyFixed !== false) {
      writer.uint32(64).bool(message.supplyFixed);
    }
    if (message.allowGovernanceControl !== false) {
      writer.uint32(72).bool(message.allowGovernanceControl);
    }
    if (message.allowForcedTransfer !== false) {
      writer.uint32(80).bool(message.allowForcedTransfer);
    }
    for (const v of message.requiredAttributes) {
      writer.uint32(90).string(v!);
    }
    if (!message.usdCents.equals(Long.UZERO)) {
      writer.uint32(96).uint64(message.usdCents.toString());
    }
    if (!message.volume.equals(Long.UZERO)) {
      writer.uint32(104).uint64(message.volume.toString());
    }
    if (!message.usdMills.equals(Long.UZERO)) {
      writer.uint32(112).uint64(message.usdMills.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddMarkerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddMarkerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.manager = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fromAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.markerType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.accessList.push(AccessGrant.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.supplyFixed = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.allowGovernanceControl = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.allowForcedTransfer = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.requiredAttributes.push(reader.string());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.usdCents = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.volume = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.usdMills = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddMarkerRequest {
    return {
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
      manager: isSet(object.manager) ? globalThis.String(object.manager) : "",
      fromAddress: isSet(object.fromAddress) ? globalThis.String(object.fromAddress) : "",
      status: isSet(object.status) ? markerStatusFromJSON(object.status) : 0,
      markerType: isSet(object.markerType) ? markerTypeFromJSON(object.markerType) : 0,
      accessList: globalThis.Array.isArray(object?.accessList)
        ? object.accessList.map((e: any) => AccessGrant.fromJSON(e))
        : [],
      supplyFixed: isSet(object.supplyFixed) ? globalThis.Boolean(object.supplyFixed) : false,
      allowGovernanceControl: isSet(object.allowGovernanceControl)
        ? globalThis.Boolean(object.allowGovernanceControl)
        : false,
      allowForcedTransfer: isSet(object.allowForcedTransfer) ? globalThis.Boolean(object.allowForcedTransfer) : false,
      requiredAttributes: globalThis.Array.isArray(object?.requiredAttributes)
        ? object.requiredAttributes.map((e: any) => globalThis.String(e))
        : [],
      usdCents: isSet(object.usdCents) ? Long.fromValue(object.usdCents) : Long.UZERO,
      volume: isSet(object.volume) ? Long.fromValue(object.volume) : Long.UZERO,
      usdMills: isSet(object.usdMills) ? Long.fromValue(object.usdMills) : Long.UZERO,
    };
  },

  toJSON(message: MsgAddMarkerRequest): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = Coin.toJSON(message.amount);
    }
    if (message.manager !== "") {
      obj.manager = message.manager;
    }
    if (message.fromAddress !== "") {
      obj.fromAddress = message.fromAddress;
    }
    if (message.status !== 0) {
      obj.status = markerStatusToJSON(message.status);
    }
    if (message.markerType !== 0) {
      obj.markerType = markerTypeToJSON(message.markerType);
    }
    if (message.accessList?.length) {
      obj.accessList = message.accessList.map((e) => AccessGrant.toJSON(e));
    }
    if (message.supplyFixed !== false) {
      obj.supplyFixed = message.supplyFixed;
    }
    if (message.allowGovernanceControl !== false) {
      obj.allowGovernanceControl = message.allowGovernanceControl;
    }
    if (message.allowForcedTransfer !== false) {
      obj.allowForcedTransfer = message.allowForcedTransfer;
    }
    if (message.requiredAttributes?.length) {
      obj.requiredAttributes = message.requiredAttributes;
    }
    if (!message.usdCents.equals(Long.UZERO)) {
      obj.usdCents = (message.usdCents || Long.UZERO).toString();
    }
    if (!message.volume.equals(Long.UZERO)) {
      obj.volume = (message.volume || Long.UZERO).toString();
    }
    if (!message.usdMills.equals(Long.UZERO)) {
      obj.usdMills = (message.usdMills || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddMarkerRequest>, I>>(base?: I): MsgAddMarkerRequest {
    return MsgAddMarkerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddMarkerRequest>, I>>(object: I): MsgAddMarkerRequest {
    const message = createBaseMsgAddMarkerRequest();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    message.manager = object.manager ?? "";
    message.fromAddress = object.fromAddress ?? "";
    message.status = object.status ?? 0;
    message.markerType = object.markerType ?? 0;
    message.accessList = object.accessList?.map((e) => AccessGrant.fromPartial(e)) || [];
    message.supplyFixed = object.supplyFixed ?? false;
    message.allowGovernanceControl = object.allowGovernanceControl ?? false;
    message.allowForcedTransfer = object.allowForcedTransfer ?? false;
    message.requiredAttributes = object.requiredAttributes?.map((e) => e) || [];
    message.usdCents = (object.usdCents !== undefined && object.usdCents !== null)
      ? Long.fromValue(object.usdCents)
      : Long.UZERO;
    message.volume = (object.volume !== undefined && object.volume !== null)
      ? Long.fromValue(object.volume)
      : Long.UZERO;
    message.usdMills = (object.usdMills !== undefined && object.usdMills !== null)
      ? Long.fromValue(object.usdMills)
      : Long.UZERO;
    return message;
  },
};

function createBaseMsgAddMarkerResponse(): MsgAddMarkerResponse {
  return {};
}

export const MsgAddMarkerResponse: MessageFns<MsgAddMarkerResponse> = {
  encode(_: MsgAddMarkerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddMarkerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddMarkerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAddMarkerResponse {
    return {};
  },

  toJSON(_: MsgAddMarkerResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddMarkerResponse>, I>>(base?: I): MsgAddMarkerResponse {
    return MsgAddMarkerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddMarkerResponse>, I>>(_: I): MsgAddMarkerResponse {
    const message = createBaseMsgAddMarkerResponse();
    return message;
  },
};

function createBaseMsgAddAccessRequest(): MsgAddAccessRequest {
  return { denom: "", administrator: "", access: [] };
}

export const MsgAddAccessRequest: MessageFns<MsgAddAccessRequest> = {
  encode(message: MsgAddAccessRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.administrator !== "") {
      writer.uint32(18).string(message.administrator);
    }
    for (const v of message.access) {
      AccessGrant.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddAccessRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddAccessRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.access.push(AccessGrant.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddAccessRequest {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
      access: globalThis.Array.isArray(object?.access) ? object.access.map((e: any) => AccessGrant.fromJSON(e)) : [],
    };
  },

  toJSON(message: MsgAddAccessRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    if (message.access?.length) {
      obj.access = message.access.map((e) => AccessGrant.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddAccessRequest>, I>>(base?: I): MsgAddAccessRequest {
    return MsgAddAccessRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddAccessRequest>, I>>(object: I): MsgAddAccessRequest {
    const message = createBaseMsgAddAccessRequest();
    message.denom = object.denom ?? "";
    message.administrator = object.administrator ?? "";
    message.access = object.access?.map((e) => AccessGrant.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgAddAccessResponse(): MsgAddAccessResponse {
  return {};
}

export const MsgAddAccessResponse: MessageFns<MsgAddAccessResponse> = {
  encode(_: MsgAddAccessResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddAccessResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddAccessResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAddAccessResponse {
    return {};
  },

  toJSON(_: MsgAddAccessResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddAccessResponse>, I>>(base?: I): MsgAddAccessResponse {
    return MsgAddAccessResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddAccessResponse>, I>>(_: I): MsgAddAccessResponse {
    const message = createBaseMsgAddAccessResponse();
    return message;
  },
};

function createBaseMsgDeleteAccessRequest(): MsgDeleteAccessRequest {
  return { denom: "", administrator: "", removedAddress: "" };
}

export const MsgDeleteAccessRequest: MessageFns<MsgDeleteAccessRequest> = {
  encode(message: MsgDeleteAccessRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.administrator !== "") {
      writer.uint32(18).string(message.administrator);
    }
    if (message.removedAddress !== "") {
      writer.uint32(26).string(message.removedAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteAccessRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteAccessRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.removedAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteAccessRequest {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
      removedAddress: isSet(object.removedAddress) ? globalThis.String(object.removedAddress) : "",
    };
  },

  toJSON(message: MsgDeleteAccessRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    if (message.removedAddress !== "") {
      obj.removedAddress = message.removedAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteAccessRequest>, I>>(base?: I): MsgDeleteAccessRequest {
    return MsgDeleteAccessRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteAccessRequest>, I>>(object: I): MsgDeleteAccessRequest {
    const message = createBaseMsgDeleteAccessRequest();
    message.denom = object.denom ?? "";
    message.administrator = object.administrator ?? "";
    message.removedAddress = object.removedAddress ?? "";
    return message;
  },
};

function createBaseMsgDeleteAccessResponse(): MsgDeleteAccessResponse {
  return {};
}

export const MsgDeleteAccessResponse: MessageFns<MsgDeleteAccessResponse> = {
  encode(_: MsgDeleteAccessResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteAccessResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteAccessResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDeleteAccessResponse {
    return {};
  },

  toJSON(_: MsgDeleteAccessResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteAccessResponse>, I>>(base?: I): MsgDeleteAccessResponse {
    return MsgDeleteAccessResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteAccessResponse>, I>>(_: I): MsgDeleteAccessResponse {
    const message = createBaseMsgDeleteAccessResponse();
    return message;
  },
};

function createBaseMsgFinalizeRequest(): MsgFinalizeRequest {
  return { denom: "", administrator: "" };
}

export const MsgFinalizeRequest: MessageFns<MsgFinalizeRequest> = {
  encode(message: MsgFinalizeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.administrator !== "") {
      writer.uint32(18).string(message.administrator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFinalizeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFinalizeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgFinalizeRequest {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
    };
  },

  toJSON(message: MsgFinalizeRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFinalizeRequest>, I>>(base?: I): MsgFinalizeRequest {
    return MsgFinalizeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFinalizeRequest>, I>>(object: I): MsgFinalizeRequest {
    const message = createBaseMsgFinalizeRequest();
    message.denom = object.denom ?? "";
    message.administrator = object.administrator ?? "";
    return message;
  },
};

function createBaseMsgFinalizeResponse(): MsgFinalizeResponse {
  return {};
}

export const MsgFinalizeResponse: MessageFns<MsgFinalizeResponse> = {
  encode(_: MsgFinalizeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFinalizeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFinalizeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgFinalizeResponse {
    return {};
  },

  toJSON(_: MsgFinalizeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFinalizeResponse>, I>>(base?: I): MsgFinalizeResponse {
    return MsgFinalizeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFinalizeResponse>, I>>(_: I): MsgFinalizeResponse {
    const message = createBaseMsgFinalizeResponse();
    return message;
  },
};

function createBaseMsgActivateRequest(): MsgActivateRequest {
  return { denom: "", administrator: "" };
}

export const MsgActivateRequest: MessageFns<MsgActivateRequest> = {
  encode(message: MsgActivateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.administrator !== "") {
      writer.uint32(18).string(message.administrator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgActivateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgActivateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgActivateRequest {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
    };
  },

  toJSON(message: MsgActivateRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgActivateRequest>, I>>(base?: I): MsgActivateRequest {
    return MsgActivateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgActivateRequest>, I>>(object: I): MsgActivateRequest {
    const message = createBaseMsgActivateRequest();
    message.denom = object.denom ?? "";
    message.administrator = object.administrator ?? "";
    return message;
  },
};

function createBaseMsgActivateResponse(): MsgActivateResponse {
  return {};
}

export const MsgActivateResponse: MessageFns<MsgActivateResponse> = {
  encode(_: MsgActivateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgActivateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgActivateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgActivateResponse {
    return {};
  },

  toJSON(_: MsgActivateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgActivateResponse>, I>>(base?: I): MsgActivateResponse {
    return MsgActivateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgActivateResponse>, I>>(_: I): MsgActivateResponse {
    const message = createBaseMsgActivateResponse();
    return message;
  },
};

function createBaseMsgCancelRequest(): MsgCancelRequest {
  return { denom: "", administrator: "" };
}

export const MsgCancelRequest: MessageFns<MsgCancelRequest> = {
  encode(message: MsgCancelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.administrator !== "") {
      writer.uint32(18).string(message.administrator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCancelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCancelRequest {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
    };
  },

  toJSON(message: MsgCancelRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCancelRequest>, I>>(base?: I): MsgCancelRequest {
    return MsgCancelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCancelRequest>, I>>(object: I): MsgCancelRequest {
    const message = createBaseMsgCancelRequest();
    message.denom = object.denom ?? "";
    message.administrator = object.administrator ?? "";
    return message;
  },
};

function createBaseMsgCancelResponse(): MsgCancelResponse {
  return {};
}

export const MsgCancelResponse: MessageFns<MsgCancelResponse> = {
  encode(_: MsgCancelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCancelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCancelResponse {
    return {};
  },

  toJSON(_: MsgCancelResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCancelResponse>, I>>(base?: I): MsgCancelResponse {
    return MsgCancelResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCancelResponse>, I>>(_: I): MsgCancelResponse {
    const message = createBaseMsgCancelResponse();
    return message;
  },
};

function createBaseMsgDeleteRequest(): MsgDeleteRequest {
  return { denom: "", administrator: "" };
}

export const MsgDeleteRequest: MessageFns<MsgDeleteRequest> = {
  encode(message: MsgDeleteRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.administrator !== "") {
      writer.uint32(18).string(message.administrator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteRequest {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
    };
  },

  toJSON(message: MsgDeleteRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteRequest>, I>>(base?: I): MsgDeleteRequest {
    return MsgDeleteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteRequest>, I>>(object: I): MsgDeleteRequest {
    const message = createBaseMsgDeleteRequest();
    message.denom = object.denom ?? "";
    message.administrator = object.administrator ?? "";
    return message;
  },
};

function createBaseMsgDeleteResponse(): MsgDeleteResponse {
  return {};
}

export const MsgDeleteResponse: MessageFns<MsgDeleteResponse> = {
  encode(_: MsgDeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDeleteResponse {
    return {};
  },

  toJSON(_: MsgDeleteResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteResponse>, I>>(base?: I): MsgDeleteResponse {
    return MsgDeleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteResponse>, I>>(_: I): MsgDeleteResponse {
    const message = createBaseMsgDeleteResponse();
    return message;
  },
};

function createBaseMsgMintRequest(): MsgMintRequest {
  return { amount: undefined, administrator: "" };
}

export const MsgMintRequest: MessageFns<MsgMintRequest> = {
  encode(message: MsgMintRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(10).fork()).join();
    }
    if (message.administrator !== "") {
      writer.uint32(18).string(message.administrator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMintRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMintRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMintRequest {
    return {
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
    };
  },

  toJSON(message: MsgMintRequest): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = Coin.toJSON(message.amount);
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMintRequest>, I>>(base?: I): MsgMintRequest {
    return MsgMintRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMintRequest>, I>>(object: I): MsgMintRequest {
    const message = createBaseMsgMintRequest();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    message.administrator = object.administrator ?? "";
    return message;
  },
};

function createBaseMsgMintResponse(): MsgMintResponse {
  return {};
}

export const MsgMintResponse: MessageFns<MsgMintResponse> = {
  encode(_: MsgMintResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMintResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMintResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgMintResponse {
    return {};
  },

  toJSON(_: MsgMintResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMintResponse>, I>>(base?: I): MsgMintResponse {
    return MsgMintResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMintResponse>, I>>(_: I): MsgMintResponse {
    const message = createBaseMsgMintResponse();
    return message;
  },
};

function createBaseMsgBurnRequest(): MsgBurnRequest {
  return { amount: undefined, administrator: "" };
}

export const MsgBurnRequest: MessageFns<MsgBurnRequest> = {
  encode(message: MsgBurnRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(10).fork()).join();
    }
    if (message.administrator !== "") {
      writer.uint32(18).string(message.administrator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBurnRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBurnRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgBurnRequest {
    return {
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
    };
  },

  toJSON(message: MsgBurnRequest): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = Coin.toJSON(message.amount);
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBurnRequest>, I>>(base?: I): MsgBurnRequest {
    return MsgBurnRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBurnRequest>, I>>(object: I): MsgBurnRequest {
    const message = createBaseMsgBurnRequest();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    message.administrator = object.administrator ?? "";
    return message;
  },
};

function createBaseMsgBurnResponse(): MsgBurnResponse {
  return {};
}

export const MsgBurnResponse: MessageFns<MsgBurnResponse> = {
  encode(_: MsgBurnResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgBurnResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgBurnResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgBurnResponse {
    return {};
  },

  toJSON(_: MsgBurnResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgBurnResponse>, I>>(base?: I): MsgBurnResponse {
    return MsgBurnResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgBurnResponse>, I>>(_: I): MsgBurnResponse {
    const message = createBaseMsgBurnResponse();
    return message;
  },
};

function createBaseMsgWithdrawRequest(): MsgWithdrawRequest {
  return { denom: "", administrator: "", toAddress: "", amount: [] };
}

export const MsgWithdrawRequest: MessageFns<MsgWithdrawRequest> = {
  encode(message: MsgWithdrawRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.administrator !== "") {
      writer.uint32(18).string(message.administrator);
    }
    if (message.toAddress !== "") {
      writer.uint32(26).string(message.toAddress);
    }
    for (const v of message.amount) {
      Coin.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgWithdrawRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgWithdrawRequest {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
      toAddress: isSet(object.toAddress) ? globalThis.String(object.toAddress) : "",
      amount: globalThis.Array.isArray(object?.amount) ? object.amount.map((e: any) => Coin.fromJSON(e)) : [],
    };
  },

  toJSON(message: MsgWithdrawRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    if (message.toAddress !== "") {
      obj.toAddress = message.toAddress;
    }
    if (message.amount?.length) {
      obj.amount = message.amount.map((e) => Coin.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgWithdrawRequest>, I>>(base?: I): MsgWithdrawRequest {
    return MsgWithdrawRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgWithdrawRequest>, I>>(object: I): MsgWithdrawRequest {
    const message = createBaseMsgWithdrawRequest();
    message.denom = object.denom ?? "";
    message.administrator = object.administrator ?? "";
    message.toAddress = object.toAddress ?? "";
    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgWithdrawResponse(): MsgWithdrawResponse {
  return {};
}

export const MsgWithdrawResponse: MessageFns<MsgWithdrawResponse> = {
  encode(_: MsgWithdrawResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgWithdrawResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgWithdrawResponse {
    return {};
  },

  toJSON(_: MsgWithdrawResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgWithdrawResponse>, I>>(base?: I): MsgWithdrawResponse {
    return MsgWithdrawResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgWithdrawResponse>, I>>(_: I): MsgWithdrawResponse {
    const message = createBaseMsgWithdrawResponse();
    return message;
  },
};

function createBaseMsgTransferRequest(): MsgTransferRequest {
  return { amount: undefined, administrator: "", fromAddress: "", toAddress: "" };
}

export const MsgTransferRequest: MessageFns<MsgTransferRequest> = {
  encode(message: MsgTransferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(10).fork()).join();
    }
    if (message.administrator !== "") {
      writer.uint32(26).string(message.administrator);
    }
    if (message.fromAddress !== "") {
      writer.uint32(34).string(message.fromAddress);
    }
    if (message.toAddress !== "") {
      writer.uint32(42).string(message.toAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTransferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fromAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.toAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgTransferRequest {
    return {
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
      fromAddress: isSet(object.fromAddress) ? globalThis.String(object.fromAddress) : "",
      toAddress: isSet(object.toAddress) ? globalThis.String(object.toAddress) : "",
    };
  },

  toJSON(message: MsgTransferRequest): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = Coin.toJSON(message.amount);
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    if (message.fromAddress !== "") {
      obj.fromAddress = message.fromAddress;
    }
    if (message.toAddress !== "") {
      obj.toAddress = message.toAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgTransferRequest>, I>>(base?: I): MsgTransferRequest {
    return MsgTransferRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgTransferRequest>, I>>(object: I): MsgTransferRequest {
    const message = createBaseMsgTransferRequest();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    message.administrator = object.administrator ?? "";
    message.fromAddress = object.fromAddress ?? "";
    message.toAddress = object.toAddress ?? "";
    return message;
  },
};

function createBaseMsgTransferResponse(): MsgTransferResponse {
  return {};
}

export const MsgTransferResponse: MessageFns<MsgTransferResponse> = {
  encode(_: MsgTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgTransferResponse {
    return {};
  },

  toJSON(_: MsgTransferResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgTransferResponse>, I>>(base?: I): MsgTransferResponse {
    return MsgTransferResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgTransferResponse>, I>>(_: I): MsgTransferResponse {
    const message = createBaseMsgTransferResponse();
    return message;
  },
};

function createBaseMsgIbcTransferRequest(): MsgIbcTransferRequest {
  return { transfer: undefined, administrator: "" };
}

export const MsgIbcTransferRequest: MessageFns<MsgIbcTransferRequest> = {
  encode(message: MsgIbcTransferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transfer !== undefined) {
      MsgTransfer.encode(message.transfer, writer.uint32(10).fork()).join();
    }
    if (message.administrator !== "") {
      writer.uint32(18).string(message.administrator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgIbcTransferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgIbcTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transfer = MsgTransfer.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgIbcTransferRequest {
    return {
      transfer: isSet(object.transfer) ? MsgTransfer.fromJSON(object.transfer) : undefined,
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
    };
  },

  toJSON(message: MsgIbcTransferRequest): unknown {
    const obj: any = {};
    if (message.transfer !== undefined) {
      obj.transfer = MsgTransfer.toJSON(message.transfer);
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgIbcTransferRequest>, I>>(base?: I): MsgIbcTransferRequest {
    return MsgIbcTransferRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgIbcTransferRequest>, I>>(object: I): MsgIbcTransferRequest {
    const message = createBaseMsgIbcTransferRequest();
    message.transfer = (object.transfer !== undefined && object.transfer !== null)
      ? MsgTransfer.fromPartial(object.transfer)
      : undefined;
    message.administrator = object.administrator ?? "";
    return message;
  },
};

function createBaseMsgIbcTransferResponse(): MsgIbcTransferResponse {
  return {};
}

export const MsgIbcTransferResponse: MessageFns<MsgIbcTransferResponse> = {
  encode(_: MsgIbcTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgIbcTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgIbcTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgIbcTransferResponse {
    return {};
  },

  toJSON(_: MsgIbcTransferResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgIbcTransferResponse>, I>>(base?: I): MsgIbcTransferResponse {
    return MsgIbcTransferResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgIbcTransferResponse>, I>>(_: I): MsgIbcTransferResponse {
    const message = createBaseMsgIbcTransferResponse();
    return message;
  },
};

function createBaseMsgSetDenomMetadataRequest(): MsgSetDenomMetadataRequest {
  return { metadata: undefined, administrator: "" };
}

export const MsgSetDenomMetadataRequest: MessageFns<MsgSetDenomMetadataRequest> = {
  encode(message: MsgSetDenomMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    if (message.administrator !== "") {
      writer.uint32(18).string(message.administrator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetDenomMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetDenomMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetDenomMetadataRequest {
    return {
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
    };
  },

  toJSON(message: MsgSetDenomMetadataRequest): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetDenomMetadataRequest>, I>>(base?: I): MsgSetDenomMetadataRequest {
    return MsgSetDenomMetadataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetDenomMetadataRequest>, I>>(object: I): MsgSetDenomMetadataRequest {
    const message = createBaseMsgSetDenomMetadataRequest();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.administrator = object.administrator ?? "";
    return message;
  },
};

function createBaseMsgSetDenomMetadataResponse(): MsgSetDenomMetadataResponse {
  return {};
}

export const MsgSetDenomMetadataResponse: MessageFns<MsgSetDenomMetadataResponse> = {
  encode(_: MsgSetDenomMetadataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetDenomMetadataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetDenomMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetDenomMetadataResponse {
    return {};
  },

  toJSON(_: MsgSetDenomMetadataResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetDenomMetadataResponse>, I>>(base?: I): MsgSetDenomMetadataResponse {
    return MsgSetDenomMetadataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetDenomMetadataResponse>, I>>(_: I): MsgSetDenomMetadataResponse {
    const message = createBaseMsgSetDenomMetadataResponse();
    return message;
  },
};

function createBaseMsgAddFinalizeActivateMarkerRequest(): MsgAddFinalizeActivateMarkerRequest {
  return {
    amount: undefined,
    manager: "",
    fromAddress: "",
    markerType: 0,
    accessList: [],
    supplyFixed: false,
    allowGovernanceControl: false,
    allowForcedTransfer: false,
    requiredAttributes: [],
    usdCents: Long.UZERO,
    volume: Long.UZERO,
    usdMills: Long.UZERO,
  };
}

export const MsgAddFinalizeActivateMarkerRequest: MessageFns<MsgAddFinalizeActivateMarkerRequest> = {
  encode(message: MsgAddFinalizeActivateMarkerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(10).fork()).join();
    }
    if (message.manager !== "") {
      writer.uint32(26).string(message.manager);
    }
    if (message.fromAddress !== "") {
      writer.uint32(34).string(message.fromAddress);
    }
    if (message.markerType !== 0) {
      writer.uint32(40).int32(message.markerType);
    }
    for (const v of message.accessList) {
      AccessGrant.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.supplyFixed !== false) {
      writer.uint32(56).bool(message.supplyFixed);
    }
    if (message.allowGovernanceControl !== false) {
      writer.uint32(64).bool(message.allowGovernanceControl);
    }
    if (message.allowForcedTransfer !== false) {
      writer.uint32(72).bool(message.allowForcedTransfer);
    }
    for (const v of message.requiredAttributes) {
      writer.uint32(82).string(v!);
    }
    if (!message.usdCents.equals(Long.UZERO)) {
      writer.uint32(88).uint64(message.usdCents.toString());
    }
    if (!message.volume.equals(Long.UZERO)) {
      writer.uint32(96).uint64(message.volume.toString());
    }
    if (!message.usdMills.equals(Long.UZERO)) {
      writer.uint32(104).uint64(message.usdMills.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddFinalizeActivateMarkerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddFinalizeActivateMarkerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.manager = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fromAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.markerType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.accessList.push(AccessGrant.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.supplyFixed = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.allowGovernanceControl = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.allowForcedTransfer = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.requiredAttributes.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.usdCents = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.volume = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.usdMills = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddFinalizeActivateMarkerRequest {
    return {
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
      manager: isSet(object.manager) ? globalThis.String(object.manager) : "",
      fromAddress: isSet(object.fromAddress) ? globalThis.String(object.fromAddress) : "",
      markerType: isSet(object.markerType) ? markerTypeFromJSON(object.markerType) : 0,
      accessList: globalThis.Array.isArray(object?.accessList)
        ? object.accessList.map((e: any) => AccessGrant.fromJSON(e))
        : [],
      supplyFixed: isSet(object.supplyFixed) ? globalThis.Boolean(object.supplyFixed) : false,
      allowGovernanceControl: isSet(object.allowGovernanceControl)
        ? globalThis.Boolean(object.allowGovernanceControl)
        : false,
      allowForcedTransfer: isSet(object.allowForcedTransfer) ? globalThis.Boolean(object.allowForcedTransfer) : false,
      requiredAttributes: globalThis.Array.isArray(object?.requiredAttributes)
        ? object.requiredAttributes.map((e: any) => globalThis.String(e))
        : [],
      usdCents: isSet(object.usdCents) ? Long.fromValue(object.usdCents) : Long.UZERO,
      volume: isSet(object.volume) ? Long.fromValue(object.volume) : Long.UZERO,
      usdMills: isSet(object.usdMills) ? Long.fromValue(object.usdMills) : Long.UZERO,
    };
  },

  toJSON(message: MsgAddFinalizeActivateMarkerRequest): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = Coin.toJSON(message.amount);
    }
    if (message.manager !== "") {
      obj.manager = message.manager;
    }
    if (message.fromAddress !== "") {
      obj.fromAddress = message.fromAddress;
    }
    if (message.markerType !== 0) {
      obj.markerType = markerTypeToJSON(message.markerType);
    }
    if (message.accessList?.length) {
      obj.accessList = message.accessList.map((e) => AccessGrant.toJSON(e));
    }
    if (message.supplyFixed !== false) {
      obj.supplyFixed = message.supplyFixed;
    }
    if (message.allowGovernanceControl !== false) {
      obj.allowGovernanceControl = message.allowGovernanceControl;
    }
    if (message.allowForcedTransfer !== false) {
      obj.allowForcedTransfer = message.allowForcedTransfer;
    }
    if (message.requiredAttributes?.length) {
      obj.requiredAttributes = message.requiredAttributes;
    }
    if (!message.usdCents.equals(Long.UZERO)) {
      obj.usdCents = (message.usdCents || Long.UZERO).toString();
    }
    if (!message.volume.equals(Long.UZERO)) {
      obj.volume = (message.volume || Long.UZERO).toString();
    }
    if (!message.usdMills.equals(Long.UZERO)) {
      obj.usdMills = (message.usdMills || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddFinalizeActivateMarkerRequest>, I>>(
    base?: I,
  ): MsgAddFinalizeActivateMarkerRequest {
    return MsgAddFinalizeActivateMarkerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddFinalizeActivateMarkerRequest>, I>>(
    object: I,
  ): MsgAddFinalizeActivateMarkerRequest {
    const message = createBaseMsgAddFinalizeActivateMarkerRequest();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    message.manager = object.manager ?? "";
    message.fromAddress = object.fromAddress ?? "";
    message.markerType = object.markerType ?? 0;
    message.accessList = object.accessList?.map((e) => AccessGrant.fromPartial(e)) || [];
    message.supplyFixed = object.supplyFixed ?? false;
    message.allowGovernanceControl = object.allowGovernanceControl ?? false;
    message.allowForcedTransfer = object.allowForcedTransfer ?? false;
    message.requiredAttributes = object.requiredAttributes?.map((e) => e) || [];
    message.usdCents = (object.usdCents !== undefined && object.usdCents !== null)
      ? Long.fromValue(object.usdCents)
      : Long.UZERO;
    message.volume = (object.volume !== undefined && object.volume !== null)
      ? Long.fromValue(object.volume)
      : Long.UZERO;
    message.usdMills = (object.usdMills !== undefined && object.usdMills !== null)
      ? Long.fromValue(object.usdMills)
      : Long.UZERO;
    return message;
  },
};

function createBaseMsgAddFinalizeActivateMarkerResponse(): MsgAddFinalizeActivateMarkerResponse {
  return {};
}

export const MsgAddFinalizeActivateMarkerResponse: MessageFns<MsgAddFinalizeActivateMarkerResponse> = {
  encode(_: MsgAddFinalizeActivateMarkerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddFinalizeActivateMarkerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddFinalizeActivateMarkerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAddFinalizeActivateMarkerResponse {
    return {};
  },

  toJSON(_: MsgAddFinalizeActivateMarkerResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddFinalizeActivateMarkerResponse>, I>>(
    base?: I,
  ): MsgAddFinalizeActivateMarkerResponse {
    return MsgAddFinalizeActivateMarkerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddFinalizeActivateMarkerResponse>, I>>(
    _: I,
  ): MsgAddFinalizeActivateMarkerResponse {
    const message = createBaseMsgAddFinalizeActivateMarkerResponse();
    return message;
  },
};

function createBaseMsgSupplyIncreaseProposalRequest(): MsgSupplyIncreaseProposalRequest {
  return { amount: undefined, targetAddress: "", authority: "" };
}

export const MsgSupplyIncreaseProposalRequest: MessageFns<MsgSupplyIncreaseProposalRequest> = {
  encode(message: MsgSupplyIncreaseProposalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(10).fork()).join();
    }
    if (message.targetAddress !== "") {
      writer.uint32(18).string(message.targetAddress);
    }
    if (message.authority !== "") {
      writer.uint32(26).string(message.authority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSupplyIncreaseProposalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSupplyIncreaseProposalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSupplyIncreaseProposalRequest {
    return {
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
      targetAddress: isSet(object.targetAddress) ? globalThis.String(object.targetAddress) : "",
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
    };
  },

  toJSON(message: MsgSupplyIncreaseProposalRequest): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = Coin.toJSON(message.amount);
    }
    if (message.targetAddress !== "") {
      obj.targetAddress = message.targetAddress;
    }
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSupplyIncreaseProposalRequest>, I>>(
    base?: I,
  ): MsgSupplyIncreaseProposalRequest {
    return MsgSupplyIncreaseProposalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSupplyIncreaseProposalRequest>, I>>(
    object: I,
  ): MsgSupplyIncreaseProposalRequest {
    const message = createBaseMsgSupplyIncreaseProposalRequest();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    message.targetAddress = object.targetAddress ?? "";
    message.authority = object.authority ?? "";
    return message;
  },
};

function createBaseMsgSupplyIncreaseProposalResponse(): MsgSupplyIncreaseProposalResponse {
  return {};
}

export const MsgSupplyIncreaseProposalResponse: MessageFns<MsgSupplyIncreaseProposalResponse> = {
  encode(_: MsgSupplyIncreaseProposalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSupplyIncreaseProposalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSupplyIncreaseProposalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSupplyIncreaseProposalResponse {
    return {};
  },

  toJSON(_: MsgSupplyIncreaseProposalResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSupplyIncreaseProposalResponse>, I>>(
    base?: I,
  ): MsgSupplyIncreaseProposalResponse {
    return MsgSupplyIncreaseProposalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSupplyIncreaseProposalResponse>, I>>(
    _: I,
  ): MsgSupplyIncreaseProposalResponse {
    const message = createBaseMsgSupplyIncreaseProposalResponse();
    return message;
  },
};

function createBaseMsgSupplyDecreaseProposalRequest(): MsgSupplyDecreaseProposalRequest {
  return { amount: undefined, authority: "" };
}

export const MsgSupplyDecreaseProposalRequest: MessageFns<MsgSupplyDecreaseProposalRequest> = {
  encode(message: MsgSupplyDecreaseProposalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(10).fork()).join();
    }
    if (message.authority !== "") {
      writer.uint32(18).string(message.authority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSupplyDecreaseProposalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSupplyDecreaseProposalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSupplyDecreaseProposalRequest {
    return {
      amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
    };
  },

  toJSON(message: MsgSupplyDecreaseProposalRequest): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = Coin.toJSON(message.amount);
    }
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSupplyDecreaseProposalRequest>, I>>(
    base?: I,
  ): MsgSupplyDecreaseProposalRequest {
    return MsgSupplyDecreaseProposalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSupplyDecreaseProposalRequest>, I>>(
    object: I,
  ): MsgSupplyDecreaseProposalRequest {
    const message = createBaseMsgSupplyDecreaseProposalRequest();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    message.authority = object.authority ?? "";
    return message;
  },
};

function createBaseMsgSupplyDecreaseProposalResponse(): MsgSupplyDecreaseProposalResponse {
  return {};
}

export const MsgSupplyDecreaseProposalResponse: MessageFns<MsgSupplyDecreaseProposalResponse> = {
  encode(_: MsgSupplyDecreaseProposalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSupplyDecreaseProposalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSupplyDecreaseProposalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSupplyDecreaseProposalResponse {
    return {};
  },

  toJSON(_: MsgSupplyDecreaseProposalResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSupplyDecreaseProposalResponse>, I>>(
    base?: I,
  ): MsgSupplyDecreaseProposalResponse {
    return MsgSupplyDecreaseProposalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSupplyDecreaseProposalResponse>, I>>(
    _: I,
  ): MsgSupplyDecreaseProposalResponse {
    const message = createBaseMsgSupplyDecreaseProposalResponse();
    return message;
  },
};

function createBaseMsgUpdateRequiredAttributesRequest(): MsgUpdateRequiredAttributesRequest {
  return { denom: "", removeRequiredAttributes: [], addRequiredAttributes: [], transferAuthority: "" };
}

export const MsgUpdateRequiredAttributesRequest: MessageFns<MsgUpdateRequiredAttributesRequest> = {
  encode(message: MsgUpdateRequiredAttributesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    for (const v of message.removeRequiredAttributes) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.addRequiredAttributes) {
      writer.uint32(26).string(v!);
    }
    if (message.transferAuthority !== "") {
      writer.uint32(34).string(message.transferAuthority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateRequiredAttributesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateRequiredAttributesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.removeRequiredAttributes.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addRequiredAttributes.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.transferAuthority = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateRequiredAttributesRequest {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      removeRequiredAttributes: globalThis.Array.isArray(object?.removeRequiredAttributes)
        ? object.removeRequiredAttributes.map((e: any) => globalThis.String(e))
        : [],
      addRequiredAttributes: globalThis.Array.isArray(object?.addRequiredAttributes)
        ? object.addRequiredAttributes.map((e: any) => globalThis.String(e))
        : [],
      transferAuthority: isSet(object.transferAuthority) ? globalThis.String(object.transferAuthority) : "",
    };
  },

  toJSON(message: MsgUpdateRequiredAttributesRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.removeRequiredAttributes?.length) {
      obj.removeRequiredAttributes = message.removeRequiredAttributes;
    }
    if (message.addRequiredAttributes?.length) {
      obj.addRequiredAttributes = message.addRequiredAttributes;
    }
    if (message.transferAuthority !== "") {
      obj.transferAuthority = message.transferAuthority;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateRequiredAttributesRequest>, I>>(
    base?: I,
  ): MsgUpdateRequiredAttributesRequest {
    return MsgUpdateRequiredAttributesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateRequiredAttributesRequest>, I>>(
    object: I,
  ): MsgUpdateRequiredAttributesRequest {
    const message = createBaseMsgUpdateRequiredAttributesRequest();
    message.denom = object.denom ?? "";
    message.removeRequiredAttributes = object.removeRequiredAttributes?.map((e) => e) || [];
    message.addRequiredAttributes = object.addRequiredAttributes?.map((e) => e) || [];
    message.transferAuthority = object.transferAuthority ?? "";
    return message;
  },
};

function createBaseMsgUpdateRequiredAttributesResponse(): MsgUpdateRequiredAttributesResponse {
  return {};
}

export const MsgUpdateRequiredAttributesResponse: MessageFns<MsgUpdateRequiredAttributesResponse> = {
  encode(_: MsgUpdateRequiredAttributesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateRequiredAttributesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateRequiredAttributesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateRequiredAttributesResponse {
    return {};
  },

  toJSON(_: MsgUpdateRequiredAttributesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateRequiredAttributesResponse>, I>>(
    base?: I,
  ): MsgUpdateRequiredAttributesResponse {
    return MsgUpdateRequiredAttributesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateRequiredAttributesResponse>, I>>(
    _: I,
  ): MsgUpdateRequiredAttributesResponse {
    const message = createBaseMsgUpdateRequiredAttributesResponse();
    return message;
  },
};

function createBaseMsgUpdateForcedTransferRequest(): MsgUpdateForcedTransferRequest {
  return { denom: "", allowForcedTransfer: false, authority: "" };
}

export const MsgUpdateForcedTransferRequest: MessageFns<MsgUpdateForcedTransferRequest> = {
  encode(message: MsgUpdateForcedTransferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.allowForcedTransfer !== false) {
      writer.uint32(16).bool(message.allowForcedTransfer);
    }
    if (message.authority !== "") {
      writer.uint32(26).string(message.authority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateForcedTransferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateForcedTransferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.allowForcedTransfer = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateForcedTransferRequest {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      allowForcedTransfer: isSet(object.allowForcedTransfer) ? globalThis.Boolean(object.allowForcedTransfer) : false,
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
    };
  },

  toJSON(message: MsgUpdateForcedTransferRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.allowForcedTransfer !== false) {
      obj.allowForcedTransfer = message.allowForcedTransfer;
    }
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateForcedTransferRequest>, I>>(base?: I): MsgUpdateForcedTransferRequest {
    return MsgUpdateForcedTransferRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateForcedTransferRequest>, I>>(
    object: I,
  ): MsgUpdateForcedTransferRequest {
    const message = createBaseMsgUpdateForcedTransferRequest();
    message.denom = object.denom ?? "";
    message.allowForcedTransfer = object.allowForcedTransfer ?? false;
    message.authority = object.authority ?? "";
    return message;
  },
};

function createBaseMsgUpdateForcedTransferResponse(): MsgUpdateForcedTransferResponse {
  return {};
}

export const MsgUpdateForcedTransferResponse: MessageFns<MsgUpdateForcedTransferResponse> = {
  encode(_: MsgUpdateForcedTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateForcedTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateForcedTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateForcedTransferResponse {
    return {};
  },

  toJSON(_: MsgUpdateForcedTransferResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateForcedTransferResponse>, I>>(base?: I): MsgUpdateForcedTransferResponse {
    return MsgUpdateForcedTransferResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateForcedTransferResponse>, I>>(_: I): MsgUpdateForcedTransferResponse {
    const message = createBaseMsgUpdateForcedTransferResponse();
    return message;
  },
};

function createBaseMsgSetAccountDataRequest(): MsgSetAccountDataRequest {
  return { denom: "", value: "", signer: "" };
}

export const MsgSetAccountDataRequest: MessageFns<MsgSetAccountDataRequest> = {
  encode(message: MsgSetAccountDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.signer !== "") {
      writer.uint32(26).string(message.signer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetAccountDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetAccountDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signer = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetAccountDataRequest {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
    };
  },

  toJSON(message: MsgSetAccountDataRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.signer !== "") {
      obj.signer = message.signer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetAccountDataRequest>, I>>(base?: I): MsgSetAccountDataRequest {
    return MsgSetAccountDataRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetAccountDataRequest>, I>>(object: I): MsgSetAccountDataRequest {
    const message = createBaseMsgSetAccountDataRequest();
    message.denom = object.denom ?? "";
    message.value = object.value ?? "";
    message.signer = object.signer ?? "";
    return message;
  },
};

function createBaseMsgSetAccountDataResponse(): MsgSetAccountDataResponse {
  return {};
}

export const MsgSetAccountDataResponse: MessageFns<MsgSetAccountDataResponse> = {
  encode(_: MsgSetAccountDataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetAccountDataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetAccountDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetAccountDataResponse {
    return {};
  },

  toJSON(_: MsgSetAccountDataResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetAccountDataResponse>, I>>(base?: I): MsgSetAccountDataResponse {
    return MsgSetAccountDataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetAccountDataResponse>, I>>(_: I): MsgSetAccountDataResponse {
    const message = createBaseMsgSetAccountDataResponse();
    return message;
  },
};

function createBaseMsgUpdateSendDenyListRequest(): MsgUpdateSendDenyListRequest {
  return { denom: "", removeDeniedAddresses: [], addDeniedAddresses: [], authority: "" };
}

export const MsgUpdateSendDenyListRequest: MessageFns<MsgUpdateSendDenyListRequest> = {
  encode(message: MsgUpdateSendDenyListRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    for (const v of message.removeDeniedAddresses) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.addDeniedAddresses) {
      writer.uint32(26).string(v!);
    }
    if (message.authority !== "") {
      writer.uint32(34).string(message.authority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateSendDenyListRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateSendDenyListRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.removeDeniedAddresses.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addDeniedAddresses.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateSendDenyListRequest {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      removeDeniedAddresses: globalThis.Array.isArray(object?.removeDeniedAddresses)
        ? object.removeDeniedAddresses.map((e: any) => globalThis.String(e))
        : [],
      addDeniedAddresses: globalThis.Array.isArray(object?.addDeniedAddresses)
        ? object.addDeniedAddresses.map((e: any) => globalThis.String(e))
        : [],
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
    };
  },

  toJSON(message: MsgUpdateSendDenyListRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.removeDeniedAddresses?.length) {
      obj.removeDeniedAddresses = message.removeDeniedAddresses;
    }
    if (message.addDeniedAddresses?.length) {
      obj.addDeniedAddresses = message.addDeniedAddresses;
    }
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateSendDenyListRequest>, I>>(base?: I): MsgUpdateSendDenyListRequest {
    return MsgUpdateSendDenyListRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateSendDenyListRequest>, I>>(object: I): MsgUpdateSendDenyListRequest {
    const message = createBaseMsgUpdateSendDenyListRequest();
    message.denom = object.denom ?? "";
    message.removeDeniedAddresses = object.removeDeniedAddresses?.map((e) => e) || [];
    message.addDeniedAddresses = object.addDeniedAddresses?.map((e) => e) || [];
    message.authority = object.authority ?? "";
    return message;
  },
};

function createBaseMsgUpdateSendDenyListResponse(): MsgUpdateSendDenyListResponse {
  return {};
}

export const MsgUpdateSendDenyListResponse: MessageFns<MsgUpdateSendDenyListResponse> = {
  encode(_: MsgUpdateSendDenyListResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateSendDenyListResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateSendDenyListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateSendDenyListResponse {
    return {};
  },

  toJSON(_: MsgUpdateSendDenyListResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateSendDenyListResponse>, I>>(base?: I): MsgUpdateSendDenyListResponse {
    return MsgUpdateSendDenyListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateSendDenyListResponse>, I>>(_: I): MsgUpdateSendDenyListResponse {
    const message = createBaseMsgUpdateSendDenyListResponse();
    return message;
  },
};

function createBaseMsgAddNetAssetValuesRequest(): MsgAddNetAssetValuesRequest {
  return { denom: "", administrator: "", netAssetValues: [] };
}

export const MsgAddNetAssetValuesRequest: MessageFns<MsgAddNetAssetValuesRequest> = {
  encode(message: MsgAddNetAssetValuesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.administrator !== "") {
      writer.uint32(18).string(message.administrator);
    }
    for (const v of message.netAssetValues) {
      NetAssetValue.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddNetAssetValuesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddNetAssetValuesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.administrator = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.netAssetValues.push(NetAssetValue.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddNetAssetValuesRequest {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      administrator: isSet(object.administrator) ? globalThis.String(object.administrator) : "",
      netAssetValues: globalThis.Array.isArray(object?.netAssetValues)
        ? object.netAssetValues.map((e: any) => NetAssetValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MsgAddNetAssetValuesRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.administrator !== "") {
      obj.administrator = message.administrator;
    }
    if (message.netAssetValues?.length) {
      obj.netAssetValues = message.netAssetValues.map((e) => NetAssetValue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddNetAssetValuesRequest>, I>>(base?: I): MsgAddNetAssetValuesRequest {
    return MsgAddNetAssetValuesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddNetAssetValuesRequest>, I>>(object: I): MsgAddNetAssetValuesRequest {
    const message = createBaseMsgAddNetAssetValuesRequest();
    message.denom = object.denom ?? "";
    message.administrator = object.administrator ?? "";
    message.netAssetValues = object.netAssetValues?.map((e) => NetAssetValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgAddNetAssetValuesResponse(): MsgAddNetAssetValuesResponse {
  return {};
}

export const MsgAddNetAssetValuesResponse: MessageFns<MsgAddNetAssetValuesResponse> = {
  encode(_: MsgAddNetAssetValuesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddNetAssetValuesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddNetAssetValuesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAddNetAssetValuesResponse {
    return {};
  },

  toJSON(_: MsgAddNetAssetValuesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddNetAssetValuesResponse>, I>>(base?: I): MsgAddNetAssetValuesResponse {
    return MsgAddNetAssetValuesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddNetAssetValuesResponse>, I>>(_: I): MsgAddNetAssetValuesResponse {
    const message = createBaseMsgAddNetAssetValuesResponse();
    return message;
  },
};

function createBaseMsgSetAdministratorProposalRequest(): MsgSetAdministratorProposalRequest {
  return { denom: "", access: [], authority: "" };
}

export const MsgSetAdministratorProposalRequest: MessageFns<MsgSetAdministratorProposalRequest> = {
  encode(message: MsgSetAdministratorProposalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    for (const v of message.access) {
      AccessGrant.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.authority !== "") {
      writer.uint32(26).string(message.authority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetAdministratorProposalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetAdministratorProposalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.access.push(AccessGrant.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetAdministratorProposalRequest {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      access: globalThis.Array.isArray(object?.access) ? object.access.map((e: any) => AccessGrant.fromJSON(e)) : [],
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
    };
  },

  toJSON(message: MsgSetAdministratorProposalRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.access?.length) {
      obj.access = message.access.map((e) => AccessGrant.toJSON(e));
    }
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetAdministratorProposalRequest>, I>>(
    base?: I,
  ): MsgSetAdministratorProposalRequest {
    return MsgSetAdministratorProposalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetAdministratorProposalRequest>, I>>(
    object: I,
  ): MsgSetAdministratorProposalRequest {
    const message = createBaseMsgSetAdministratorProposalRequest();
    message.denom = object.denom ?? "";
    message.access = object.access?.map((e) => AccessGrant.fromPartial(e)) || [];
    message.authority = object.authority ?? "";
    return message;
  },
};

function createBaseMsgSetAdministratorProposalResponse(): MsgSetAdministratorProposalResponse {
  return {};
}

export const MsgSetAdministratorProposalResponse: MessageFns<MsgSetAdministratorProposalResponse> = {
  encode(_: MsgSetAdministratorProposalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetAdministratorProposalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetAdministratorProposalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetAdministratorProposalResponse {
    return {};
  },

  toJSON(_: MsgSetAdministratorProposalResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetAdministratorProposalResponse>, I>>(
    base?: I,
  ): MsgSetAdministratorProposalResponse {
    return MsgSetAdministratorProposalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetAdministratorProposalResponse>, I>>(
    _: I,
  ): MsgSetAdministratorProposalResponse {
    const message = createBaseMsgSetAdministratorProposalResponse();
    return message;
  },
};

function createBaseMsgRemoveAdministratorProposalRequest(): MsgRemoveAdministratorProposalRequest {
  return { denom: "", removedAddress: [], authority: "" };
}

export const MsgRemoveAdministratorProposalRequest: MessageFns<MsgRemoveAdministratorProposalRequest> = {
  encode(message: MsgRemoveAdministratorProposalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    for (const v of message.removedAddress) {
      writer.uint32(18).string(v!);
    }
    if (message.authority !== "") {
      writer.uint32(26).string(message.authority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveAdministratorProposalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveAdministratorProposalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.removedAddress.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRemoveAdministratorProposalRequest {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      removedAddress: globalThis.Array.isArray(object?.removedAddress)
        ? object.removedAddress.map((e: any) => globalThis.String(e))
        : [],
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
    };
  },

  toJSON(message: MsgRemoveAdministratorProposalRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.removedAddress?.length) {
      obj.removedAddress = message.removedAddress;
    }
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRemoveAdministratorProposalRequest>, I>>(
    base?: I,
  ): MsgRemoveAdministratorProposalRequest {
    return MsgRemoveAdministratorProposalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRemoveAdministratorProposalRequest>, I>>(
    object: I,
  ): MsgRemoveAdministratorProposalRequest {
    const message = createBaseMsgRemoveAdministratorProposalRequest();
    message.denom = object.denom ?? "";
    message.removedAddress = object.removedAddress?.map((e) => e) || [];
    message.authority = object.authority ?? "";
    return message;
  },
};

function createBaseMsgRemoveAdministratorProposalResponse(): MsgRemoveAdministratorProposalResponse {
  return {};
}

export const MsgRemoveAdministratorProposalResponse: MessageFns<MsgRemoveAdministratorProposalResponse> = {
  encode(_: MsgRemoveAdministratorProposalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRemoveAdministratorProposalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRemoveAdministratorProposalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRemoveAdministratorProposalResponse {
    return {};
  },

  toJSON(_: MsgRemoveAdministratorProposalResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRemoveAdministratorProposalResponse>, I>>(
    base?: I,
  ): MsgRemoveAdministratorProposalResponse {
    return MsgRemoveAdministratorProposalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRemoveAdministratorProposalResponse>, I>>(
    _: I,
  ): MsgRemoveAdministratorProposalResponse {
    const message = createBaseMsgRemoveAdministratorProposalResponse();
    return message;
  },
};

function createBaseMsgChangeStatusProposalRequest(): MsgChangeStatusProposalRequest {
  return { denom: "", newStatus: 0, authority: "" };
}

export const MsgChangeStatusProposalRequest: MessageFns<MsgChangeStatusProposalRequest> = {
  encode(message: MsgChangeStatusProposalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.newStatus !== 0) {
      writer.uint32(16).int32(message.newStatus);
    }
    if (message.authority !== "") {
      writer.uint32(26).string(message.authority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgChangeStatusProposalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgChangeStatusProposalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.newStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgChangeStatusProposalRequest {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      newStatus: isSet(object.newStatus) ? markerStatusFromJSON(object.newStatus) : 0,
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
    };
  },

  toJSON(message: MsgChangeStatusProposalRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.newStatus !== 0) {
      obj.newStatus = markerStatusToJSON(message.newStatus);
    }
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgChangeStatusProposalRequest>, I>>(base?: I): MsgChangeStatusProposalRequest {
    return MsgChangeStatusProposalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgChangeStatusProposalRequest>, I>>(
    object: I,
  ): MsgChangeStatusProposalRequest {
    const message = createBaseMsgChangeStatusProposalRequest();
    message.denom = object.denom ?? "";
    message.newStatus = object.newStatus ?? 0;
    message.authority = object.authority ?? "";
    return message;
  },
};

function createBaseMsgChangeStatusProposalResponse(): MsgChangeStatusProposalResponse {
  return {};
}

export const MsgChangeStatusProposalResponse: MessageFns<MsgChangeStatusProposalResponse> = {
  encode(_: MsgChangeStatusProposalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgChangeStatusProposalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgChangeStatusProposalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgChangeStatusProposalResponse {
    return {};
  },

  toJSON(_: MsgChangeStatusProposalResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgChangeStatusProposalResponse>, I>>(base?: I): MsgChangeStatusProposalResponse {
    return MsgChangeStatusProposalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgChangeStatusProposalResponse>, I>>(_: I): MsgChangeStatusProposalResponse {
    const message = createBaseMsgChangeStatusProposalResponse();
    return message;
  },
};

function createBaseMsgWithdrawEscrowProposalRequest(): MsgWithdrawEscrowProposalRequest {
  return { denom: "", amount: [], targetAddress: "", authority: "" };
}

export const MsgWithdrawEscrowProposalRequest: MessageFns<MsgWithdrawEscrowProposalRequest> = {
  encode(message: MsgWithdrawEscrowProposalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    for (const v of message.amount) {
      Coin.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.targetAddress !== "") {
      writer.uint32(26).string(message.targetAddress);
    }
    if (message.authority !== "") {
      writer.uint32(34).string(message.authority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgWithdrawEscrowProposalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawEscrowProposalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgWithdrawEscrowProposalRequest {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      amount: globalThis.Array.isArray(object?.amount) ? object.amount.map((e: any) => Coin.fromJSON(e)) : [],
      targetAddress: isSet(object.targetAddress) ? globalThis.String(object.targetAddress) : "",
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
    };
  },

  toJSON(message: MsgWithdrawEscrowProposalRequest): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.amount?.length) {
      obj.amount = message.amount.map((e) => Coin.toJSON(e));
    }
    if (message.targetAddress !== "") {
      obj.targetAddress = message.targetAddress;
    }
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgWithdrawEscrowProposalRequest>, I>>(
    base?: I,
  ): MsgWithdrawEscrowProposalRequest {
    return MsgWithdrawEscrowProposalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgWithdrawEscrowProposalRequest>, I>>(
    object: I,
  ): MsgWithdrawEscrowProposalRequest {
    const message = createBaseMsgWithdrawEscrowProposalRequest();
    message.denom = object.denom ?? "";
    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];
    message.targetAddress = object.targetAddress ?? "";
    message.authority = object.authority ?? "";
    return message;
  },
};

function createBaseMsgWithdrawEscrowProposalResponse(): MsgWithdrawEscrowProposalResponse {
  return {};
}

export const MsgWithdrawEscrowProposalResponse: MessageFns<MsgWithdrawEscrowProposalResponse> = {
  encode(_: MsgWithdrawEscrowProposalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgWithdrawEscrowProposalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawEscrowProposalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgWithdrawEscrowProposalResponse {
    return {};
  },

  toJSON(_: MsgWithdrawEscrowProposalResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgWithdrawEscrowProposalResponse>, I>>(
    base?: I,
  ): MsgWithdrawEscrowProposalResponse {
    return MsgWithdrawEscrowProposalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgWithdrawEscrowProposalResponse>, I>>(
    _: I,
  ): MsgWithdrawEscrowProposalResponse {
    const message = createBaseMsgWithdrawEscrowProposalResponse();
    return message;
  },
};

function createBaseMsgSetDenomMetadataProposalRequest(): MsgSetDenomMetadataProposalRequest {
  return { metadata: undefined, authority: "" };
}

export const MsgSetDenomMetadataProposalRequest: MessageFns<MsgSetDenomMetadataProposalRequest> = {
  encode(message: MsgSetDenomMetadataProposalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    if (message.authority !== "") {
      writer.uint32(18).string(message.authority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetDenomMetadataProposalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetDenomMetadataProposalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSetDenomMetadataProposalRequest {
    return {
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
    };
  },

  toJSON(message: MsgSetDenomMetadataProposalRequest): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetDenomMetadataProposalRequest>, I>>(
    base?: I,
  ): MsgSetDenomMetadataProposalRequest {
    return MsgSetDenomMetadataProposalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetDenomMetadataProposalRequest>, I>>(
    object: I,
  ): MsgSetDenomMetadataProposalRequest {
    const message = createBaseMsgSetDenomMetadataProposalRequest();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.authority = object.authority ?? "";
    return message;
  },
};

function createBaseMsgSetDenomMetadataProposalResponse(): MsgSetDenomMetadataProposalResponse {
  return {};
}

export const MsgSetDenomMetadataProposalResponse: MessageFns<MsgSetDenomMetadataProposalResponse> = {
  encode(_: MsgSetDenomMetadataProposalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSetDenomMetadataProposalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSetDenomMetadataProposalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSetDenomMetadataProposalResponse {
    return {};
  },

  toJSON(_: MsgSetDenomMetadataProposalResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSetDenomMetadataProposalResponse>, I>>(
    base?: I,
  ): MsgSetDenomMetadataProposalResponse {
    return MsgSetDenomMetadataProposalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSetDenomMetadataProposalResponse>, I>>(
    _: I,
  ): MsgSetDenomMetadataProposalResponse {
    const message = createBaseMsgSetDenomMetadataProposalResponse();
    return message;
  },
};

function createBaseMsgUpdateParamsRequest(): MsgUpdateParamsRequest {
  return { authority: "", params: undefined };
}

export const MsgUpdateParamsRequest: MessageFns<MsgUpdateParamsRequest> = {
  encode(message: MsgUpdateParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParamsRequest {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParamsRequest): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsRequest>, I>>(base?: I): MsgUpdateParamsRequest {
    return MsgUpdateParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsRequest>, I>>(object: I): MsgUpdateParamsRequest {
    const message = createBaseMsgUpdateParamsRequest();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(base?: I): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(_: I): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

/** Msg defines the Marker Msg service. */
export interface Msg {
  /** Finalize */
  Finalize(request: MsgFinalizeRequest): Promise<MsgFinalizeResponse>;
  /** Activate */
  Activate(request: MsgActivateRequest): Promise<MsgActivateResponse>;
  /** Cancel */
  Cancel(request: MsgCancelRequest): Promise<MsgCancelResponse>;
  /** Delete */
  Delete(request: MsgDeleteRequest): Promise<MsgDeleteResponse>;
  /** Mint */
  Mint(request: MsgMintRequest): Promise<MsgMintResponse>;
  /** Burn */
  Burn(request: MsgBurnRequest): Promise<MsgBurnResponse>;
  /** AddAccess */
  AddAccess(request: MsgAddAccessRequest): Promise<MsgAddAccessResponse>;
  /** DeleteAccess */
  DeleteAccess(request: MsgDeleteAccessRequest): Promise<MsgDeleteAccessResponse>;
  /** Withdraw */
  Withdraw(request: MsgWithdrawRequest): Promise<MsgWithdrawResponse>;
  /** AddMarker */
  AddMarker(request: MsgAddMarkerRequest): Promise<MsgAddMarkerResponse>;
  /** Transfer marker denominated coin between accounts */
  Transfer(request: MsgTransferRequest): Promise<MsgTransferResponse>;
  /**
   * Transfer over ibc any marker(including restricted markers) between ibc accounts.
   * The relayer is still needed to accomplish ibc middleware relays.
   */
  IbcTransfer(request: MsgIbcTransferRequest): Promise<MsgIbcTransferResponse>;
  /** Allows Denom Metadata (see bank module) to be set for the Marker's Denom */
  SetDenomMetadata(request: MsgSetDenomMetadataRequest): Promise<MsgSetDenomMetadataResponse>;
  /**
   * GrantAllowance grants fee allowance to the grantee on the granter's
   * account with the provided expiration time.
   */
  GrantAllowance(request: MsgGrantAllowanceRequest): Promise<MsgGrantAllowanceResponse>;
  /** AddFinalizeActivateMarker */
  AddFinalizeActivateMarker(
    request: MsgAddFinalizeActivateMarkerRequest,
  ): Promise<MsgAddFinalizeActivateMarkerResponse>;
  /** SupplyIncreaseProposal can only be called via gov proposal */
  SupplyIncreaseProposal(request: MsgSupplyIncreaseProposalRequest): Promise<MsgSupplyIncreaseProposalResponse>;
  /** SupplyDecreaseProposal can only be called via gov proposal */
  SupplyDecreaseProposal(request: MsgSupplyDecreaseProposalRequest): Promise<MsgSupplyDecreaseProposalResponse>;
  /** UpdateRequiredAttributes will only succeed if signer has transfer authority */
  UpdateRequiredAttributes(request: MsgUpdateRequiredAttributesRequest): Promise<MsgUpdateRequiredAttributesResponse>;
  /** UpdateForcedTransfer updates the allow_forced_transfer field of a marker via governance proposal. */
  UpdateForcedTransfer(request: MsgUpdateForcedTransferRequest): Promise<MsgUpdateForcedTransferResponse>;
  /** SetAccountData sets the accountdata for a denom. Signer must have deposit authority. */
  SetAccountData(request: MsgSetAccountDataRequest): Promise<MsgSetAccountDataResponse>;
  /** UpdateSendDenyList will only succeed if signer has admin authority */
  UpdateSendDenyList(request: MsgUpdateSendDenyListRequest): Promise<MsgUpdateSendDenyListResponse>;
  /** AddNetAssetValues set the net asset value for a marker */
  AddNetAssetValues(request: MsgAddNetAssetValuesRequest): Promise<MsgAddNetAssetValuesResponse>;
  /** SetAdministratorProposal sets administrators with specific access on the marker */
  SetAdministratorProposal(request: MsgSetAdministratorProposalRequest): Promise<MsgSetAdministratorProposalResponse>;
  /** RemoveAdministratorProposal removes administrators with specific access on the marker */
  RemoveAdministratorProposal(
    request: MsgRemoveAdministratorProposalRequest,
  ): Promise<MsgRemoveAdministratorProposalResponse>;
  /** ChangeStatusProposal is a governance proposal change marker status */
  ChangeStatusProposal(request: MsgChangeStatusProposalRequest): Promise<MsgChangeStatusProposalResponse>;
  /** WithdrawEscrowProposal is a governance proposal to withdraw escrow coins from a marker */
  WithdrawEscrowProposal(request: MsgWithdrawEscrowProposalRequest): Promise<MsgWithdrawEscrowProposalResponse>;
  /** SetDenomMetadataProposal is a governance proposal to set marker metadata */
  SetDenomMetadataProposal(request: MsgSetDenomMetadataProposalRequest): Promise<MsgSetDenomMetadataProposalResponse>;
  /** UpdateParams is a governance proposal endpoint for updating the marker module's params. */
  UpdateParams(request: MsgUpdateParamsRequest): Promise<MsgUpdateParamsResponse>;
}

export const MsgServiceName = "provenance.marker.v1.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.Finalize = this.Finalize.bind(this);
    this.Activate = this.Activate.bind(this);
    this.Cancel = this.Cancel.bind(this);
    this.Delete = this.Delete.bind(this);
    this.Mint = this.Mint.bind(this);
    this.Burn = this.Burn.bind(this);
    this.AddAccess = this.AddAccess.bind(this);
    this.DeleteAccess = this.DeleteAccess.bind(this);
    this.Withdraw = this.Withdraw.bind(this);
    this.AddMarker = this.AddMarker.bind(this);
    this.Transfer = this.Transfer.bind(this);
    this.IbcTransfer = this.IbcTransfer.bind(this);
    this.SetDenomMetadata = this.SetDenomMetadata.bind(this);
    this.GrantAllowance = this.GrantAllowance.bind(this);
    this.AddFinalizeActivateMarker = this.AddFinalizeActivateMarker.bind(this);
    this.SupplyIncreaseProposal = this.SupplyIncreaseProposal.bind(this);
    this.SupplyDecreaseProposal = this.SupplyDecreaseProposal.bind(this);
    this.UpdateRequiredAttributes = this.UpdateRequiredAttributes.bind(this);
    this.UpdateForcedTransfer = this.UpdateForcedTransfer.bind(this);
    this.SetAccountData = this.SetAccountData.bind(this);
    this.UpdateSendDenyList = this.UpdateSendDenyList.bind(this);
    this.AddNetAssetValues = this.AddNetAssetValues.bind(this);
    this.SetAdministratorProposal = this.SetAdministratorProposal.bind(this);
    this.RemoveAdministratorProposal = this.RemoveAdministratorProposal.bind(this);
    this.ChangeStatusProposal = this.ChangeStatusProposal.bind(this);
    this.WithdrawEscrowProposal = this.WithdrawEscrowProposal.bind(this);
    this.SetDenomMetadataProposal = this.SetDenomMetadataProposal.bind(this);
    this.UpdateParams = this.UpdateParams.bind(this);
  }
  Finalize(request: MsgFinalizeRequest): Promise<MsgFinalizeResponse> {
    const data = MsgFinalizeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Finalize", data);
    return promise.then((data) => MsgFinalizeResponse.decode(new BinaryReader(data)));
  }

  Activate(request: MsgActivateRequest): Promise<MsgActivateResponse> {
    const data = MsgActivateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Activate", data);
    return promise.then((data) => MsgActivateResponse.decode(new BinaryReader(data)));
  }

  Cancel(request: MsgCancelRequest): Promise<MsgCancelResponse> {
    const data = MsgCancelRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Cancel", data);
    return promise.then((data) => MsgCancelResponse.decode(new BinaryReader(data)));
  }

  Delete(request: MsgDeleteRequest): Promise<MsgDeleteResponse> {
    const data = MsgDeleteRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Delete", data);
    return promise.then((data) => MsgDeleteResponse.decode(new BinaryReader(data)));
  }

  Mint(request: MsgMintRequest): Promise<MsgMintResponse> {
    const data = MsgMintRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Mint", data);
    return promise.then((data) => MsgMintResponse.decode(new BinaryReader(data)));
  }

  Burn(request: MsgBurnRequest): Promise<MsgBurnResponse> {
    const data = MsgBurnRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Burn", data);
    return promise.then((data) => MsgBurnResponse.decode(new BinaryReader(data)));
  }

  AddAccess(request: MsgAddAccessRequest): Promise<MsgAddAccessResponse> {
    const data = MsgAddAccessRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddAccess", data);
    return promise.then((data) => MsgAddAccessResponse.decode(new BinaryReader(data)));
  }

  DeleteAccess(request: MsgDeleteAccessRequest): Promise<MsgDeleteAccessResponse> {
    const data = MsgDeleteAccessRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteAccess", data);
    return promise.then((data) => MsgDeleteAccessResponse.decode(new BinaryReader(data)));
  }

  Withdraw(request: MsgWithdrawRequest): Promise<MsgWithdrawResponse> {
    const data = MsgWithdrawRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Withdraw", data);
    return promise.then((data) => MsgWithdrawResponse.decode(new BinaryReader(data)));
  }

  AddMarker(request: MsgAddMarkerRequest): Promise<MsgAddMarkerResponse> {
    const data = MsgAddMarkerRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddMarker", data);
    return promise.then((data) => MsgAddMarkerResponse.decode(new BinaryReader(data)));
  }

  Transfer(request: MsgTransferRequest): Promise<MsgTransferResponse> {
    const data = MsgTransferRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Transfer", data);
    return promise.then((data) => MsgTransferResponse.decode(new BinaryReader(data)));
  }

  IbcTransfer(request: MsgIbcTransferRequest): Promise<MsgIbcTransferResponse> {
    const data = MsgIbcTransferRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "IbcTransfer", data);
    return promise.then((data) => MsgIbcTransferResponse.decode(new BinaryReader(data)));
  }

  SetDenomMetadata(request: MsgSetDenomMetadataRequest): Promise<MsgSetDenomMetadataResponse> {
    const data = MsgSetDenomMetadataRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetDenomMetadata", data);
    return promise.then((data) => MsgSetDenomMetadataResponse.decode(new BinaryReader(data)));
  }

  GrantAllowance(request: MsgGrantAllowanceRequest): Promise<MsgGrantAllowanceResponse> {
    const data = MsgGrantAllowanceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GrantAllowance", data);
    return promise.then((data) => MsgGrantAllowanceResponse.decode(new BinaryReader(data)));
  }

  AddFinalizeActivateMarker(
    request: MsgAddFinalizeActivateMarkerRequest,
  ): Promise<MsgAddFinalizeActivateMarkerResponse> {
    const data = MsgAddFinalizeActivateMarkerRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddFinalizeActivateMarker", data);
    return promise.then((data) => MsgAddFinalizeActivateMarkerResponse.decode(new BinaryReader(data)));
  }

  SupplyIncreaseProposal(request: MsgSupplyIncreaseProposalRequest): Promise<MsgSupplyIncreaseProposalResponse> {
    const data = MsgSupplyIncreaseProposalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SupplyIncreaseProposal", data);
    return promise.then((data) => MsgSupplyIncreaseProposalResponse.decode(new BinaryReader(data)));
  }

  SupplyDecreaseProposal(request: MsgSupplyDecreaseProposalRequest): Promise<MsgSupplyDecreaseProposalResponse> {
    const data = MsgSupplyDecreaseProposalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SupplyDecreaseProposal", data);
    return promise.then((data) => MsgSupplyDecreaseProposalResponse.decode(new BinaryReader(data)));
  }

  UpdateRequiredAttributes(request: MsgUpdateRequiredAttributesRequest): Promise<MsgUpdateRequiredAttributesResponse> {
    const data = MsgUpdateRequiredAttributesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateRequiredAttributes", data);
    return promise.then((data) => MsgUpdateRequiredAttributesResponse.decode(new BinaryReader(data)));
  }

  UpdateForcedTransfer(request: MsgUpdateForcedTransferRequest): Promise<MsgUpdateForcedTransferResponse> {
    const data = MsgUpdateForcedTransferRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateForcedTransfer", data);
    return promise.then((data) => MsgUpdateForcedTransferResponse.decode(new BinaryReader(data)));
  }

  SetAccountData(request: MsgSetAccountDataRequest): Promise<MsgSetAccountDataResponse> {
    const data = MsgSetAccountDataRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetAccountData", data);
    return promise.then((data) => MsgSetAccountDataResponse.decode(new BinaryReader(data)));
  }

  UpdateSendDenyList(request: MsgUpdateSendDenyListRequest): Promise<MsgUpdateSendDenyListResponse> {
    const data = MsgUpdateSendDenyListRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateSendDenyList", data);
    return promise.then((data) => MsgUpdateSendDenyListResponse.decode(new BinaryReader(data)));
  }

  AddNetAssetValues(request: MsgAddNetAssetValuesRequest): Promise<MsgAddNetAssetValuesResponse> {
    const data = MsgAddNetAssetValuesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddNetAssetValues", data);
    return promise.then((data) => MsgAddNetAssetValuesResponse.decode(new BinaryReader(data)));
  }

  SetAdministratorProposal(request: MsgSetAdministratorProposalRequest): Promise<MsgSetAdministratorProposalResponse> {
    const data = MsgSetAdministratorProposalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetAdministratorProposal", data);
    return promise.then((data) => MsgSetAdministratorProposalResponse.decode(new BinaryReader(data)));
  }

  RemoveAdministratorProposal(
    request: MsgRemoveAdministratorProposalRequest,
  ): Promise<MsgRemoveAdministratorProposalResponse> {
    const data = MsgRemoveAdministratorProposalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveAdministratorProposal", data);
    return promise.then((data) => MsgRemoveAdministratorProposalResponse.decode(new BinaryReader(data)));
  }

  ChangeStatusProposal(request: MsgChangeStatusProposalRequest): Promise<MsgChangeStatusProposalResponse> {
    const data = MsgChangeStatusProposalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ChangeStatusProposal", data);
    return promise.then((data) => MsgChangeStatusProposalResponse.decode(new BinaryReader(data)));
  }

  WithdrawEscrowProposal(request: MsgWithdrawEscrowProposalRequest): Promise<MsgWithdrawEscrowProposalResponse> {
    const data = MsgWithdrawEscrowProposalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "WithdrawEscrowProposal", data);
    return promise.then((data) => MsgWithdrawEscrowProposalResponse.decode(new BinaryReader(data)));
  }

  SetDenomMetadataProposal(request: MsgSetDenomMetadataProposalRequest): Promise<MsgSetDenomMetadataProposalResponse> {
    const data = MsgSetDenomMetadataProposalRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetDenomMetadataProposal", data);
    return promise.then((data) => MsgSetDenomMetadataProposalResponse.decode(new BinaryReader(data)));
  }

  UpdateParams(request: MsgUpdateParamsRequest): Promise<MsgUpdateParamsResponse> {
    const data = MsgUpdateParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateParams", data);
    return promise.then((data) => MsgUpdateParamsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
