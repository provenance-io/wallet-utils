// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: provenance/exchange/v1/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { PageRequest, PageResponse } from "../../../cosmos/base/query/v1beta1/pagination";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { AccountAmount, Commitment, MarketAmount, NetAssetPrice } from "./commitments";
import { Market, MarketBrief } from "./market";
import { AskOrder, BidOrder, Order } from "./orders";
import { Params } from "./params";
import { Payment } from "./payments";
import { MsgGovCreateMarketRequest, MsgGovManageFeesRequest, MsgMarketCommitmentSettleRequest } from "./tx";

export const protobufPackage = "provenance.exchange.v1";

/**
 * QueryOrderFeeCalcRequest is a request message for the OrderFeeCalc query.
 * Exactly one of ask_order or bid_order must be provided.
 */
export interface QueryOrderFeeCalcRequest {
  /** ask_order is the ask order to calculate the fees for. */
  askOrder?:
    | AskOrder
    | undefined;
  /** bid_order is the bid order to calculate the fees for. */
  bidOrder?: BidOrder | undefined;
}

/** QueryOrderFeeCalcResponse is a response message for the OrderFeeCalc query. */
export interface QueryOrderFeeCalcResponse {
  /**
   * creation_fee_options are the order creation flat fee options available for creating the provided order.
   * If it's empty, no order creation fee is required.
   * When creating the order, you should include exactly one of these.
   */
  creationFeeOptions: Coin[];
  /**
   * settlement_flat_fee_options are the settlement flat fee options available for the provided order.
   * If it's empty, no settlement flat fee is required.
   * When creating an order, you should include exactly one of these in the settlement fees field.
   */
  settlementFlatFeeOptions: Coin[];
  /**
   * settlement_ratio_fee_options are the settlement ratio fee options available for the provided order.
   * If it's empty, no settlement ratio fee is required.
   *
   * If the provided order was a bid order, you should include exactly one of these in the settlement fees field.
   * If the flat and ratio options you've chose have the same denom, a single entry should be included with their sum.
   *
   * If the provided order was an ask order, these are purely informational and represent how much will be removed
   * from your price if it settles at that price. If it settles for more, the actual amount will probably be larger.
   */
  settlementRatioFeeOptions: Coin[];
}

/** QueryGetOrderRequest is a request message for the GetOrder query. */
export interface QueryGetOrderRequest {
  /** order_id is the id of the order to look up. */
  orderId: Long;
}

/** QueryGetOrderResponse is a response message for the GetOrder query. */
export interface QueryGetOrderResponse {
  /** order is the requested order. */
  order?: Order | undefined;
}

/** QueryGetOrderByExternalIDRequest is a request message for the GetOrderByExternalID query. */
export interface QueryGetOrderByExternalIDRequest {
  /** market_id is the id of the market that's expected to have the order. */
  marketId: number;
  /** external_id the external id to look up. */
  externalId: string;
}

/** QueryGetOrderByExternalIDResponse is a response message for the GetOrderByExternalID query. */
export interface QueryGetOrderByExternalIDResponse {
  /** order is the requested order. */
  order?: Order | undefined;
}

/** QueryGetMarketOrdersRequest is a request message for the GetMarketOrders query. */
export interface QueryGetMarketOrdersRequest {
  /** market_id is the id of the market to get all the orders for. */
  marketId: number;
  /** order_type is optional and can limit orders to only "ask" or "bid" orders. */
  orderType: string;
  /** after_order_id is a minimum (exclusive) order id. All results will be strictly greater than this. */
  afterOrderId: Long;
  /** pagination defines an optional pagination for the request. */
  pagination?: PageRequest | undefined;
}

/** QueryGetMarketOrdersResponse is a response message for the GetMarketOrders query. */
export interface QueryGetMarketOrdersResponse {
  /** orders are a page of the orders in the provided market. */
  orders: Order[];
  /** pagination is the resulting pagination parameters. */
  pagination?: PageResponse | undefined;
}

/** QueryGetOwnerOrdersRequest is a request message for the GetOwnerOrders query. */
export interface QueryGetOwnerOrdersRequest {
  /** owner is the bech32 address string of the owner to get the orders for. */
  owner: string;
  /** order_type is optional and can limit orders to only "ask" or "bid" orders. */
  orderType: string;
  /** after_order_id is a minimum (exclusive) order id. All results will be strictly greater than this. */
  afterOrderId: Long;
  /** pagination defines an optional pagination for the request. */
  pagination?: PageRequest | undefined;
}

/** QueryGetOwnerOrdersResponse is a response message for the GetOwnerOrders query. */
export interface QueryGetOwnerOrdersResponse {
  /** orders are a page of the orders for the provided address. */
  orders: Order[];
  /** pagination is the resulting pagination parameters. */
  pagination?: PageResponse | undefined;
}

/** QueryGetAssetOrdersRequest is a request message for the GetAssetOrders query. */
export interface QueryGetAssetOrdersRequest {
  /** asset is the denom of assets to get orders for. */
  asset: string;
  /** order_type is optional and can limit orders to only "ask" or "bid" orders. */
  orderType: string;
  /** after_order_id is a minimum (exclusive) order id. All results will be strictly greater than this. */
  afterOrderId: Long;
  /** pagination defines an optional pagination for the request. */
  pagination?: PageRequest | undefined;
}

/** QueryGetAssetOrdersResponse is a response message for the GetAssetOrders query. */
export interface QueryGetAssetOrdersResponse {
  /** orders are a page of the orders for the provided asset. */
  orders: Order[];
  /** pagination is the resulting pagination parameters. */
  pagination?: PageResponse | undefined;
}

/** QueryGetAllOrdersRequest is a request message for the GetAllOrders query. */
export interface QueryGetAllOrdersRequest {
  /** pagination defines an optional pagination for the request. */
  pagination?: PageRequest | undefined;
}

/** QueryGetAllOrdersResponse is a response message for the GetAllOrders query. */
export interface QueryGetAllOrdersResponse {
  /** orders are a page of the all orders. */
  orders: Order[];
  /** pagination is the resulting pagination parameters. */
  pagination?: PageResponse | undefined;
}

/** QueryGetCommitmentRequest is a request message for the GetCommitment query. */
export interface QueryGetCommitmentRequest {
  /** account is the bech32 address string of the account in the commitment. */
  account: string;
  /** market_id is the numeric identifier of the market in the commitment. */
  marketId: number;
}

/** QueryGetCommitmentResponse is a response message for the GetCommitment query. */
export interface QueryGetCommitmentResponse {
  /** amount is the total funds committed to the market by the account. */
  amount: Coin[];
}

/** QueryGetAccountCommitmentsRequest is a request message for the GetAccountCommitments query. */
export interface QueryGetAccountCommitmentsRequest {
  /** account is the bech32 address string of the account with the commitments. */
  account: string;
}

/** QueryGetAccountCommitmentsResponse is a response message for the GetAccountCommitments query. */
export interface QueryGetAccountCommitmentsResponse {
  /** commitments is the amounts committed from the account to the any market. */
  commitments: MarketAmount[];
}

/** QueryGetMarketCommitmentsRequest is a request message for the GetMarketCommitments query. */
export interface QueryGetMarketCommitmentsRequest {
  /** market_id is the numeric identifier of the market with the commitment. */
  marketId: number;
  /** pagination defines an optional pagination for the request. */
  pagination?: PageRequest | undefined;
}

/** QueryGetMarketCommitmentsResponse is a response message for the GetMarketCommitments query. */
export interface QueryGetMarketCommitmentsResponse {
  /** commitments is the amounts committed to the market from any account. */
  commitments: AccountAmount[];
  /** pagination is the resulting pagination parameters. */
  pagination?: PageResponse | undefined;
}

/** QueryGetAllCommitmentsRequest is a request message for the GetAllCommitments query. */
export interface QueryGetAllCommitmentsRequest {
  /** pagination defines an optional pagination for the request. */
  pagination?: PageRequest | undefined;
}

/** QueryGetAllCommitmentsResponse is a response message for the GetAllCommitments query. */
export interface QueryGetAllCommitmentsResponse {
  /** commitments is the requested commitment information. */
  commitments: Commitment[];
  /** pagination is the resulting pagination parameters. */
  pagination?: PageResponse | undefined;
}

/** QueryGetMarketRequest is a request message for the GetMarket query. */
export interface QueryGetMarketRequest {
  /** market_id is the id of the market to look up. */
  marketId: number;
}

/** QueryGetMarketResponse is a response message for the GetMarket query. */
export interface QueryGetMarketResponse {
  /** address is the bech32 address string of this market's account. */
  address: string;
  /** market is all information and details of the market. */
  market?: Market | undefined;
}

/** QueryGetAllMarketsRequest is a request message for the GetAllMarkets query. */
export interface QueryGetAllMarketsRequest {
  /** pagination defines an optional pagination for the request. */
  pagination?: PageRequest | undefined;
}

/** QueryGetAllMarketsResponse is a response message for the GetAllMarkets query. */
export interface QueryGetAllMarketsResponse {
  /** markets are a page of the briefs for all markets. */
  markets: MarketBrief[];
  /** pagination is the resulting pagination parameters. */
  pagination?: PageResponse | undefined;
}

/** QueryParamsRequest is a request message for the Params query. */
export interface QueryParamsRequest {
}

/** QueryParamsResponse is a response message for the Params query. */
export interface QueryParamsResponse {
  /** params are the exchange module parameter values. */
  params?: Params | undefined;
}

/** QueryCommitmentSettlementFeeCalcRequest is a request message for the CommitmentSettlementFeeCalc query. */
export interface QueryCommitmentSettlementFeeCalcRequest {
  /**
   * settlement is a market's commitment settlement request message.
   * If no inputs are provided, only the to_fee_nav field will be populated in the response.
   */
  settlement?:
    | MsgMarketCommitmentSettleRequest
    | undefined;
  /**
   * include_breakdown_fields controls the fields that are populated in the response.
   * If false, only the exchange_fees field is populated.
   * If true, all of the fields are populated as possible.
   * If the settlement does not have any inputs, this field defaults to true.
   */
  includeBreakdownFields: boolean;
}

/** QueryCommitmentSettlementFeeCalcResponse is a response message for the CommitmentSettlementFeeCalc query. */
export interface QueryCommitmentSettlementFeeCalcResponse {
  /** exchange_fees is the total that the exchange would currently pay for the provided settlement. */
  exchangeFees: Coin[];
  /** input_total is the sum of all the inputs in the provided settlement. */
  inputTotal: Coin[];
  /** converted_total is the input_total converted to a single intermediary denom or left as the fee denom. */
  convertedTotal: Coin[];
  /** conversion_navs are the NAVs used to convert the input_total to the converted_total. */
  conversionNavs: NetAssetPrice[];
  /** to_fee_nav is the NAV used to convert the converted_total into the fee denom. */
  toFeeNav?: NetAssetPrice | undefined;
}

/** QueryValidateCreateMarketRequest is a request message for the ValidateCreateMarket query. */
export interface QueryValidateCreateMarketRequest {
  /** create_market_request is the request to run validation on. */
  createMarketRequest?: MsgGovCreateMarketRequest | undefined;
}

/** QueryValidateCreateMarketResponse is a response message for the ValidateCreateMarket query. */
export interface QueryValidateCreateMarketResponse {
  /**
   * error is any problems or inconsistencies in the provided gov prop msg.
   * This goes above and beyond the validation done when actually processing the governance proposal.
   * If an error is returned, and gov_prop_will_pass is true, it means the error is more of an
   * inconsistency that might cause certain aspects of the market to behave unexpectedly.
   */
  error: string;
  /**
   * gov_prop_will_pass will be true if the the provided msg will be successfully processed at the end of it's voting
   * period (assuming it passes).
   */
  govPropWillPass: boolean;
}

/** QueryValidateMarketRequest is a request message for the ValidateMarket query. */
export interface QueryValidateMarketRequest {
  /** market_id is the id of the market to check. */
  marketId: number;
}

/** QueryValidateMarketResponse is a response message for the ValidateMarket query. */
export interface QueryValidateMarketResponse {
  /** error is any problems or inconsistencies in the provided market. */
  error: string;
}

/** QueryValidateManageFeesRequest is a request message for the ValidateManageFees query. */
export interface QueryValidateManageFeesRequest {
  /** manage_fees_request is the request to run validation on. */
  manageFeesRequest?: MsgGovManageFeesRequest | undefined;
}

/** QueryValidateManageFeesResponse is a response message for the ValidateManageFees query. */
export interface QueryValidateManageFeesResponse {
  /**
   * error is any problems or inconsistencies in the provided gov prop msg.
   * This goes above and beyond the validation done when actually processing the governance proposal.
   * If an error is returned, and gov_prop_will_pass is true, it means the error is more of an
   * inconsistency that might cause certain aspects of the market to behave unexpectedly.
   */
  error: string;
  /**
   * gov_prop_will_pass will be true if the the provided msg will be successfully processed at the end of it's voting
   * period (assuming it passes).
   */
  govPropWillPass: boolean;
}

/** QueryGetPaymentRequest is a request message for the GetPayment query. */
export interface QueryGetPaymentRequest {
  /** source is the source account of the payment to get. */
  source: string;
  /** external_id is the external id of the payment to get. */
  externalId: string;
}

/** QueryGetPaymentResponse is a response message for the GetPayment query. */
export interface QueryGetPaymentResponse {
  /** payment is the info on the requested payment. */
  payment?: Payment | undefined;
}

/** QueryGetPaymentsWithSourceRequest is a request message for the GetPaymentsWithSource query. */
export interface QueryGetPaymentsWithSourceRequest {
  /** source is the source account of the payments to get. */
  source: string;
  /** pagination defines an optional pagination for the request. */
  pagination?: PageRequest | undefined;
}

/** QueryGetPaymentsWithSourceResponse is a response message for the GetPaymentsWithSource query. */
export interface QueryGetPaymentsWithSourceResponse {
  /** payments is all the payments with the requested source. */
  payments: Payment[];
  /** pagination is the resulting pagination parameters. */
  pagination?: PageResponse | undefined;
}

/** QueryGetPaymentsWithTargetRequest is a request message for the GetPaymentsWithTarget query. */
export interface QueryGetPaymentsWithTargetRequest {
  /** target is the target account of the payments to get. */
  target: string;
  /** pagination defines an optional pagination for the request. */
  pagination?: PageRequest | undefined;
}

/** QueryGetPaymentsWithTargetResponse is a response message for the GetPaymentsWithTarget query. */
export interface QueryGetPaymentsWithTargetResponse {
  /** payments is all the payments with the requested target. */
  payments: Payment[];
  /** pagination is the resulting pagination parameters. */
  pagination?: PageResponse | undefined;
}

/** QueryGetAllPaymentsRequest is a request message for the GetAllPayments query. */
export interface QueryGetAllPaymentsRequest {
  /** pagination defines an optional pagination for the request. */
  pagination?: PageRequest | undefined;
}

/** QueryGetAllPaymentsResponse is a response message for the GetAllPayments query. */
export interface QueryGetAllPaymentsResponse {
  /** payments is all the payments on this page of results. */
  payments: Payment[];
  /** pagination is the resulting pagination parameters. */
  pagination?: PageResponse | undefined;
}

/** QueryPaymentFeeCalcRequest is a request message for the PaymentFeeCalc query. */
export interface QueryPaymentFeeCalcRequest {
  /** payment is the details of the payment to create or accept. */
  payment?: Payment | undefined;
}

/** QueryPaymentFeeCalcResponse is a response message for the PaymentFeeCalc query. */
export interface QueryPaymentFeeCalcResponse {
  /** fee_create is the fee required to create the provided payment. */
  feeCreate: Coin[];
  /** fee_accept is the fee required to accept the provided payment. */
  feeAccept: Coin[];
}

function createBaseQueryOrderFeeCalcRequest(): QueryOrderFeeCalcRequest {
  return { askOrder: undefined, bidOrder: undefined };
}

export const QueryOrderFeeCalcRequest: MessageFns<QueryOrderFeeCalcRequest> = {
  encode(message: QueryOrderFeeCalcRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.askOrder !== undefined) {
      AskOrder.encode(message.askOrder, writer.uint32(18).fork()).join();
    }
    if (message.bidOrder !== undefined) {
      BidOrder.encode(message.bidOrder, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOrderFeeCalcRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOrderFeeCalcRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.askOrder = AskOrder.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bidOrder = BidOrder.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOrderFeeCalcRequest {
    return {
      askOrder: isSet(object.askOrder) ? AskOrder.fromJSON(object.askOrder) : undefined,
      bidOrder: isSet(object.bidOrder) ? BidOrder.fromJSON(object.bidOrder) : undefined,
    };
  },

  toJSON(message: QueryOrderFeeCalcRequest): unknown {
    const obj: any = {};
    if (message.askOrder !== undefined) {
      obj.askOrder = AskOrder.toJSON(message.askOrder);
    }
    if (message.bidOrder !== undefined) {
      obj.bidOrder = BidOrder.toJSON(message.bidOrder);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOrderFeeCalcRequest>, I>>(base?: I): QueryOrderFeeCalcRequest {
    return QueryOrderFeeCalcRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOrderFeeCalcRequest>, I>>(object: I): QueryOrderFeeCalcRequest {
    const message = createBaseQueryOrderFeeCalcRequest();
    message.askOrder = (object.askOrder !== undefined && object.askOrder !== null)
      ? AskOrder.fromPartial(object.askOrder)
      : undefined;
    message.bidOrder = (object.bidOrder !== undefined && object.bidOrder !== null)
      ? BidOrder.fromPartial(object.bidOrder)
      : undefined;
    return message;
  },
};

function createBaseQueryOrderFeeCalcResponse(): QueryOrderFeeCalcResponse {
  return { creationFeeOptions: [], settlementFlatFeeOptions: [], settlementRatioFeeOptions: [] };
}

export const QueryOrderFeeCalcResponse: MessageFns<QueryOrderFeeCalcResponse> = {
  encode(message: QueryOrderFeeCalcResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.creationFeeOptions) {
      Coin.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.settlementFlatFeeOptions) {
      Coin.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.settlementRatioFeeOptions) {
      Coin.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOrderFeeCalcResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOrderFeeCalcResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creationFeeOptions.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.settlementFlatFeeOptions.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.settlementRatioFeeOptions.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryOrderFeeCalcResponse {
    return {
      creationFeeOptions: globalThis.Array.isArray(object?.creationFeeOptions)
        ? object.creationFeeOptions.map((e: any) => Coin.fromJSON(e))
        : [],
      settlementFlatFeeOptions: globalThis.Array.isArray(object?.settlementFlatFeeOptions)
        ? object.settlementFlatFeeOptions.map((e: any) => Coin.fromJSON(e))
        : [],
      settlementRatioFeeOptions: globalThis.Array.isArray(object?.settlementRatioFeeOptions)
        ? object.settlementRatioFeeOptions.map((e: any) => Coin.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryOrderFeeCalcResponse): unknown {
    const obj: any = {};
    if (message.creationFeeOptions?.length) {
      obj.creationFeeOptions = message.creationFeeOptions.map((e) => Coin.toJSON(e));
    }
    if (message.settlementFlatFeeOptions?.length) {
      obj.settlementFlatFeeOptions = message.settlementFlatFeeOptions.map((e) => Coin.toJSON(e));
    }
    if (message.settlementRatioFeeOptions?.length) {
      obj.settlementRatioFeeOptions = message.settlementRatioFeeOptions.map((e) => Coin.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryOrderFeeCalcResponse>, I>>(base?: I): QueryOrderFeeCalcResponse {
    return QueryOrderFeeCalcResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryOrderFeeCalcResponse>, I>>(object: I): QueryOrderFeeCalcResponse {
    const message = createBaseQueryOrderFeeCalcResponse();
    message.creationFeeOptions = object.creationFeeOptions?.map((e) => Coin.fromPartial(e)) || [];
    message.settlementFlatFeeOptions = object.settlementFlatFeeOptions?.map((e) => Coin.fromPartial(e)) || [];
    message.settlementRatioFeeOptions = object.settlementRatioFeeOptions?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryGetOrderRequest(): QueryGetOrderRequest {
  return { orderId: Long.UZERO };
}

export const QueryGetOrderRequest: MessageFns<QueryGetOrderRequest> = {
  encode(message: QueryGetOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.orderId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.orderId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.orderId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetOrderRequest {
    return { orderId: isSet(object.orderId) ? Long.fromValue(object.orderId) : Long.UZERO };
  },

  toJSON(message: QueryGetOrderRequest): unknown {
    const obj: any = {};
    if (!message.orderId.equals(Long.UZERO)) {
      obj.orderId = (message.orderId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetOrderRequest>, I>>(base?: I): QueryGetOrderRequest {
    return QueryGetOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetOrderRequest>, I>>(object: I): QueryGetOrderRequest {
    const message = createBaseQueryGetOrderRequest();
    message.orderId = (object.orderId !== undefined && object.orderId !== null)
      ? Long.fromValue(object.orderId)
      : Long.UZERO;
    return message;
  },
};

function createBaseQueryGetOrderResponse(): QueryGetOrderResponse {
  return { order: undefined };
}

export const QueryGetOrderResponse: MessageFns<QueryGetOrderResponse> = {
  encode(message: QueryGetOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== undefined) {
      Order.encode(message.order, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.order = Order.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetOrderResponse {
    return { order: isSet(object.order) ? Order.fromJSON(object.order) : undefined };
  },

  toJSON(message: QueryGetOrderResponse): unknown {
    const obj: any = {};
    if (message.order !== undefined) {
      obj.order = Order.toJSON(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetOrderResponse>, I>>(base?: I): QueryGetOrderResponse {
    return QueryGetOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetOrderResponse>, I>>(object: I): QueryGetOrderResponse {
    const message = createBaseQueryGetOrderResponse();
    message.order = (object.order !== undefined && object.order !== null) ? Order.fromPartial(object.order) : undefined;
    return message;
  },
};

function createBaseQueryGetOrderByExternalIDRequest(): QueryGetOrderByExternalIDRequest {
  return { marketId: 0, externalId: "" };
}

export const QueryGetOrderByExternalIDRequest: MessageFns<QueryGetOrderByExternalIDRequest> = {
  encode(message: QueryGetOrderByExternalIDRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.externalId !== "") {
      writer.uint32(18).string(message.externalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetOrderByExternalIDRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetOrderByExternalIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetOrderByExternalIDRequest {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
    };
  },

  toJSON(message: QueryGetOrderByExternalIDRequest): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetOrderByExternalIDRequest>, I>>(
    base?: I,
  ): QueryGetOrderByExternalIDRequest {
    return QueryGetOrderByExternalIDRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetOrderByExternalIDRequest>, I>>(
    object: I,
  ): QueryGetOrderByExternalIDRequest {
    const message = createBaseQueryGetOrderByExternalIDRequest();
    message.marketId = object.marketId ?? 0;
    message.externalId = object.externalId ?? "";
    return message;
  },
};

function createBaseQueryGetOrderByExternalIDResponse(): QueryGetOrderByExternalIDResponse {
  return { order: undefined };
}

export const QueryGetOrderByExternalIDResponse: MessageFns<QueryGetOrderByExternalIDResponse> = {
  encode(message: QueryGetOrderByExternalIDResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.order !== undefined) {
      Order.encode(message.order, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetOrderByExternalIDResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetOrderByExternalIDResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.order = Order.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetOrderByExternalIDResponse {
    return { order: isSet(object.order) ? Order.fromJSON(object.order) : undefined };
  },

  toJSON(message: QueryGetOrderByExternalIDResponse): unknown {
    const obj: any = {};
    if (message.order !== undefined) {
      obj.order = Order.toJSON(message.order);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetOrderByExternalIDResponse>, I>>(
    base?: I,
  ): QueryGetOrderByExternalIDResponse {
    return QueryGetOrderByExternalIDResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetOrderByExternalIDResponse>, I>>(
    object: I,
  ): QueryGetOrderByExternalIDResponse {
    const message = createBaseQueryGetOrderByExternalIDResponse();
    message.order = (object.order !== undefined && object.order !== null) ? Order.fromPartial(object.order) : undefined;
    return message;
  },
};

function createBaseQueryGetMarketOrdersRequest(): QueryGetMarketOrdersRequest {
  return { marketId: 0, orderType: "", afterOrderId: Long.UZERO, pagination: undefined };
}

export const QueryGetMarketOrdersRequest: MessageFns<QueryGetMarketOrdersRequest> = {
  encode(message: QueryGetMarketOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.orderType !== "") {
      writer.uint32(18).string(message.orderType);
    }
    if (!message.afterOrderId.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.afterOrderId.toString());
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetMarketOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetMarketOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.afterOrderId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetMarketOrdersRequest {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      orderType: isSet(object.orderType) ? globalThis.String(object.orderType) : "",
      afterOrderId: isSet(object.afterOrderId) ? Long.fromValue(object.afterOrderId) : Long.UZERO,
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryGetMarketOrdersRequest): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.orderType !== "") {
      obj.orderType = message.orderType;
    }
    if (!message.afterOrderId.equals(Long.UZERO)) {
      obj.afterOrderId = (message.afterOrderId || Long.UZERO).toString();
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetMarketOrdersRequest>, I>>(base?: I): QueryGetMarketOrdersRequest {
    return QueryGetMarketOrdersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetMarketOrdersRequest>, I>>(object: I): QueryGetMarketOrdersRequest {
    const message = createBaseQueryGetMarketOrdersRequest();
    message.marketId = object.marketId ?? 0;
    message.orderType = object.orderType ?? "";
    message.afterOrderId = (object.afterOrderId !== undefined && object.afterOrderId !== null)
      ? Long.fromValue(object.afterOrderId)
      : Long.UZERO;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetMarketOrdersResponse(): QueryGetMarketOrdersResponse {
  return { orders: [], pagination: undefined };
}

export const QueryGetMarketOrdersResponse: MessageFns<QueryGetMarketOrdersResponse> = {
  encode(message: QueryGetMarketOrdersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.orders) {
      Order.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetMarketOrdersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetMarketOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orders.push(Order.decode(reader, reader.uint32()));
          continue;
        }
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetMarketOrdersResponse {
    return {
      orders: globalThis.Array.isArray(object?.orders) ? object.orders.map((e: any) => Order.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryGetMarketOrdersResponse): unknown {
    const obj: any = {};
    if (message.orders?.length) {
      obj.orders = message.orders.map((e) => Order.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetMarketOrdersResponse>, I>>(base?: I): QueryGetMarketOrdersResponse {
    return QueryGetMarketOrdersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetMarketOrdersResponse>, I>>(object: I): QueryGetMarketOrdersResponse {
    const message = createBaseQueryGetMarketOrdersResponse();
    message.orders = object.orders?.map((e) => Order.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetOwnerOrdersRequest(): QueryGetOwnerOrdersRequest {
  return { owner: "", orderType: "", afterOrderId: Long.UZERO, pagination: undefined };
}

export const QueryGetOwnerOrdersRequest: MessageFns<QueryGetOwnerOrdersRequest> = {
  encode(message: QueryGetOwnerOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (message.orderType !== "") {
      writer.uint32(18).string(message.orderType);
    }
    if (!message.afterOrderId.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.afterOrderId.toString());
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetOwnerOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetOwnerOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.afterOrderId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetOwnerOrdersRequest {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      orderType: isSet(object.orderType) ? globalThis.String(object.orderType) : "",
      afterOrderId: isSet(object.afterOrderId) ? Long.fromValue(object.afterOrderId) : Long.UZERO,
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryGetOwnerOrdersRequest): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.orderType !== "") {
      obj.orderType = message.orderType;
    }
    if (!message.afterOrderId.equals(Long.UZERO)) {
      obj.afterOrderId = (message.afterOrderId || Long.UZERO).toString();
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetOwnerOrdersRequest>, I>>(base?: I): QueryGetOwnerOrdersRequest {
    return QueryGetOwnerOrdersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetOwnerOrdersRequest>, I>>(object: I): QueryGetOwnerOrdersRequest {
    const message = createBaseQueryGetOwnerOrdersRequest();
    message.owner = object.owner ?? "";
    message.orderType = object.orderType ?? "";
    message.afterOrderId = (object.afterOrderId !== undefined && object.afterOrderId !== null)
      ? Long.fromValue(object.afterOrderId)
      : Long.UZERO;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetOwnerOrdersResponse(): QueryGetOwnerOrdersResponse {
  return { orders: [], pagination: undefined };
}

export const QueryGetOwnerOrdersResponse: MessageFns<QueryGetOwnerOrdersResponse> = {
  encode(message: QueryGetOwnerOrdersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.orders) {
      Order.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetOwnerOrdersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetOwnerOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orders.push(Order.decode(reader, reader.uint32()));
          continue;
        }
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetOwnerOrdersResponse {
    return {
      orders: globalThis.Array.isArray(object?.orders) ? object.orders.map((e: any) => Order.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryGetOwnerOrdersResponse): unknown {
    const obj: any = {};
    if (message.orders?.length) {
      obj.orders = message.orders.map((e) => Order.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetOwnerOrdersResponse>, I>>(base?: I): QueryGetOwnerOrdersResponse {
    return QueryGetOwnerOrdersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetOwnerOrdersResponse>, I>>(object: I): QueryGetOwnerOrdersResponse {
    const message = createBaseQueryGetOwnerOrdersResponse();
    message.orders = object.orders?.map((e) => Order.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetAssetOrdersRequest(): QueryGetAssetOrdersRequest {
  return { asset: "", orderType: "", afterOrderId: Long.UZERO, pagination: undefined };
}

export const QueryGetAssetOrdersRequest: MessageFns<QueryGetAssetOrdersRequest> = {
  encode(message: QueryGetAssetOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.asset !== "") {
      writer.uint32(10).string(message.asset);
    }
    if (message.orderType !== "") {
      writer.uint32(18).string(message.orderType);
    }
    if (!message.afterOrderId.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.afterOrderId.toString());
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetAssetOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetAssetOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.asset = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.afterOrderId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetAssetOrdersRequest {
    return {
      asset: isSet(object.asset) ? globalThis.String(object.asset) : "",
      orderType: isSet(object.orderType) ? globalThis.String(object.orderType) : "",
      afterOrderId: isSet(object.afterOrderId) ? Long.fromValue(object.afterOrderId) : Long.UZERO,
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryGetAssetOrdersRequest): unknown {
    const obj: any = {};
    if (message.asset !== "") {
      obj.asset = message.asset;
    }
    if (message.orderType !== "") {
      obj.orderType = message.orderType;
    }
    if (!message.afterOrderId.equals(Long.UZERO)) {
      obj.afterOrderId = (message.afterOrderId || Long.UZERO).toString();
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetAssetOrdersRequest>, I>>(base?: I): QueryGetAssetOrdersRequest {
    return QueryGetAssetOrdersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetAssetOrdersRequest>, I>>(object: I): QueryGetAssetOrdersRequest {
    const message = createBaseQueryGetAssetOrdersRequest();
    message.asset = object.asset ?? "";
    message.orderType = object.orderType ?? "";
    message.afterOrderId = (object.afterOrderId !== undefined && object.afterOrderId !== null)
      ? Long.fromValue(object.afterOrderId)
      : Long.UZERO;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetAssetOrdersResponse(): QueryGetAssetOrdersResponse {
  return { orders: [], pagination: undefined };
}

export const QueryGetAssetOrdersResponse: MessageFns<QueryGetAssetOrdersResponse> = {
  encode(message: QueryGetAssetOrdersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.orders) {
      Order.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetAssetOrdersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetAssetOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orders.push(Order.decode(reader, reader.uint32()));
          continue;
        }
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetAssetOrdersResponse {
    return {
      orders: globalThis.Array.isArray(object?.orders) ? object.orders.map((e: any) => Order.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryGetAssetOrdersResponse): unknown {
    const obj: any = {};
    if (message.orders?.length) {
      obj.orders = message.orders.map((e) => Order.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetAssetOrdersResponse>, I>>(base?: I): QueryGetAssetOrdersResponse {
    return QueryGetAssetOrdersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetAssetOrdersResponse>, I>>(object: I): QueryGetAssetOrdersResponse {
    const message = createBaseQueryGetAssetOrdersResponse();
    message.orders = object.orders?.map((e) => Order.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetAllOrdersRequest(): QueryGetAllOrdersRequest {
  return { pagination: undefined };
}

export const QueryGetAllOrdersRequest: MessageFns<QueryGetAllOrdersRequest> = {
  encode(message: QueryGetAllOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetAllOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetAllOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetAllOrdersRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryGetAllOrdersRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetAllOrdersRequest>, I>>(base?: I): QueryGetAllOrdersRequest {
    return QueryGetAllOrdersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetAllOrdersRequest>, I>>(object: I): QueryGetAllOrdersRequest {
    const message = createBaseQueryGetAllOrdersRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetAllOrdersResponse(): QueryGetAllOrdersResponse {
  return { orders: [], pagination: undefined };
}

export const QueryGetAllOrdersResponse: MessageFns<QueryGetAllOrdersResponse> = {
  encode(message: QueryGetAllOrdersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.orders) {
      Order.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetAllOrdersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetAllOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orders.push(Order.decode(reader, reader.uint32()));
          continue;
        }
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetAllOrdersResponse {
    return {
      orders: globalThis.Array.isArray(object?.orders) ? object.orders.map((e: any) => Order.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryGetAllOrdersResponse): unknown {
    const obj: any = {};
    if (message.orders?.length) {
      obj.orders = message.orders.map((e) => Order.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetAllOrdersResponse>, I>>(base?: I): QueryGetAllOrdersResponse {
    return QueryGetAllOrdersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetAllOrdersResponse>, I>>(object: I): QueryGetAllOrdersResponse {
    const message = createBaseQueryGetAllOrdersResponse();
    message.orders = object.orders?.map((e) => Order.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetCommitmentRequest(): QueryGetCommitmentRequest {
  return { account: "", marketId: 0 };
}

export const QueryGetCommitmentRequest: MessageFns<QueryGetCommitmentRequest> = {
  encode(message: QueryGetCommitmentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetCommitmentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetCommitmentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetCommitmentRequest {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
    };
  },

  toJSON(message: QueryGetCommitmentRequest): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetCommitmentRequest>, I>>(base?: I): QueryGetCommitmentRequest {
    return QueryGetCommitmentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetCommitmentRequest>, I>>(object: I): QueryGetCommitmentRequest {
    const message = createBaseQueryGetCommitmentRequest();
    message.account = object.account ?? "";
    message.marketId = object.marketId ?? 0;
    return message;
  },
};

function createBaseQueryGetCommitmentResponse(): QueryGetCommitmentResponse {
  return { amount: [] };
}

export const QueryGetCommitmentResponse: MessageFns<QueryGetCommitmentResponse> = {
  encode(message: QueryGetCommitmentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.amount) {
      Coin.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetCommitmentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetCommitmentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetCommitmentResponse {
    return { amount: globalThis.Array.isArray(object?.amount) ? object.amount.map((e: any) => Coin.fromJSON(e)) : [] };
  },

  toJSON(message: QueryGetCommitmentResponse): unknown {
    const obj: any = {};
    if (message.amount?.length) {
      obj.amount = message.amount.map((e) => Coin.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetCommitmentResponse>, I>>(base?: I): QueryGetCommitmentResponse {
    return QueryGetCommitmentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetCommitmentResponse>, I>>(object: I): QueryGetCommitmentResponse {
    const message = createBaseQueryGetCommitmentResponse();
    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryGetAccountCommitmentsRequest(): QueryGetAccountCommitmentsRequest {
  return { account: "" };
}

export const QueryGetAccountCommitmentsRequest: MessageFns<QueryGetAccountCommitmentsRequest> = {
  encode(message: QueryGetAccountCommitmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetAccountCommitmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetAccountCommitmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetAccountCommitmentsRequest {
    return { account: isSet(object.account) ? globalThis.String(object.account) : "" };
  },

  toJSON(message: QueryGetAccountCommitmentsRequest): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetAccountCommitmentsRequest>, I>>(
    base?: I,
  ): QueryGetAccountCommitmentsRequest {
    return QueryGetAccountCommitmentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetAccountCommitmentsRequest>, I>>(
    object: I,
  ): QueryGetAccountCommitmentsRequest {
    const message = createBaseQueryGetAccountCommitmentsRequest();
    message.account = object.account ?? "";
    return message;
  },
};

function createBaseQueryGetAccountCommitmentsResponse(): QueryGetAccountCommitmentsResponse {
  return { commitments: [] };
}

export const QueryGetAccountCommitmentsResponse: MessageFns<QueryGetAccountCommitmentsResponse> = {
  encode(message: QueryGetAccountCommitmentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.commitments) {
      MarketAmount.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetAccountCommitmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetAccountCommitmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commitments.push(MarketAmount.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetAccountCommitmentsResponse {
    return {
      commitments: globalThis.Array.isArray(object?.commitments)
        ? object.commitments.map((e: any) => MarketAmount.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryGetAccountCommitmentsResponse): unknown {
    const obj: any = {};
    if (message.commitments?.length) {
      obj.commitments = message.commitments.map((e) => MarketAmount.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetAccountCommitmentsResponse>, I>>(
    base?: I,
  ): QueryGetAccountCommitmentsResponse {
    return QueryGetAccountCommitmentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetAccountCommitmentsResponse>, I>>(
    object: I,
  ): QueryGetAccountCommitmentsResponse {
    const message = createBaseQueryGetAccountCommitmentsResponse();
    message.commitments = object.commitments?.map((e) => MarketAmount.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryGetMarketCommitmentsRequest(): QueryGetMarketCommitmentsRequest {
  return { marketId: 0, pagination: undefined };
}

export const QueryGetMarketCommitmentsRequest: MessageFns<QueryGetMarketCommitmentsRequest> = {
  encode(message: QueryGetMarketCommitmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetMarketCommitmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetMarketCommitmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetMarketCommitmentsRequest {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryGetMarketCommitmentsRequest): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetMarketCommitmentsRequest>, I>>(
    base?: I,
  ): QueryGetMarketCommitmentsRequest {
    return QueryGetMarketCommitmentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetMarketCommitmentsRequest>, I>>(
    object: I,
  ): QueryGetMarketCommitmentsRequest {
    const message = createBaseQueryGetMarketCommitmentsRequest();
    message.marketId = object.marketId ?? 0;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetMarketCommitmentsResponse(): QueryGetMarketCommitmentsResponse {
  return { commitments: [], pagination: undefined };
}

export const QueryGetMarketCommitmentsResponse: MessageFns<QueryGetMarketCommitmentsResponse> = {
  encode(message: QueryGetMarketCommitmentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.commitments) {
      AccountAmount.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetMarketCommitmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetMarketCommitmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commitments.push(AccountAmount.decode(reader, reader.uint32()));
          continue;
        }
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetMarketCommitmentsResponse {
    return {
      commitments: globalThis.Array.isArray(object?.commitments)
        ? object.commitments.map((e: any) => AccountAmount.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryGetMarketCommitmentsResponse): unknown {
    const obj: any = {};
    if (message.commitments?.length) {
      obj.commitments = message.commitments.map((e) => AccountAmount.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetMarketCommitmentsResponse>, I>>(
    base?: I,
  ): QueryGetMarketCommitmentsResponse {
    return QueryGetMarketCommitmentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetMarketCommitmentsResponse>, I>>(
    object: I,
  ): QueryGetMarketCommitmentsResponse {
    const message = createBaseQueryGetMarketCommitmentsResponse();
    message.commitments = object.commitments?.map((e) => AccountAmount.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetAllCommitmentsRequest(): QueryGetAllCommitmentsRequest {
  return { pagination: undefined };
}

export const QueryGetAllCommitmentsRequest: MessageFns<QueryGetAllCommitmentsRequest> = {
  encode(message: QueryGetAllCommitmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetAllCommitmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetAllCommitmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetAllCommitmentsRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryGetAllCommitmentsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetAllCommitmentsRequest>, I>>(base?: I): QueryGetAllCommitmentsRequest {
    return QueryGetAllCommitmentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetAllCommitmentsRequest>, I>>(
    object: I,
  ): QueryGetAllCommitmentsRequest {
    const message = createBaseQueryGetAllCommitmentsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetAllCommitmentsResponse(): QueryGetAllCommitmentsResponse {
  return { commitments: [], pagination: undefined };
}

export const QueryGetAllCommitmentsResponse: MessageFns<QueryGetAllCommitmentsResponse> = {
  encode(message: QueryGetAllCommitmentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.commitments) {
      Commitment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetAllCommitmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetAllCommitmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commitments.push(Commitment.decode(reader, reader.uint32()));
          continue;
        }
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetAllCommitmentsResponse {
    return {
      commitments: globalThis.Array.isArray(object?.commitments)
        ? object.commitments.map((e: any) => Commitment.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryGetAllCommitmentsResponse): unknown {
    const obj: any = {};
    if (message.commitments?.length) {
      obj.commitments = message.commitments.map((e) => Commitment.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetAllCommitmentsResponse>, I>>(base?: I): QueryGetAllCommitmentsResponse {
    return QueryGetAllCommitmentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetAllCommitmentsResponse>, I>>(
    object: I,
  ): QueryGetAllCommitmentsResponse {
    const message = createBaseQueryGetAllCommitmentsResponse();
    message.commitments = object.commitments?.map((e) => Commitment.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetMarketRequest(): QueryGetMarketRequest {
  return { marketId: 0 };
}

export const QueryGetMarketRequest: MessageFns<QueryGetMarketRequest> = {
  encode(message: QueryGetMarketRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetMarketRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetMarketRequest {
    return { marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0 };
  },

  toJSON(message: QueryGetMarketRequest): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetMarketRequest>, I>>(base?: I): QueryGetMarketRequest {
    return QueryGetMarketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetMarketRequest>, I>>(object: I): QueryGetMarketRequest {
    const message = createBaseQueryGetMarketRequest();
    message.marketId = object.marketId ?? 0;
    return message;
  },
};

function createBaseQueryGetMarketResponse(): QueryGetMarketResponse {
  return { address: "", market: undefined };
}

export const QueryGetMarketResponse: MessageFns<QueryGetMarketResponse> = {
  encode(message: QueryGetMarketResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.market !== undefined) {
      Market.encode(message.market, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetMarketResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetMarketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.market = Market.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetMarketResponse {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      market: isSet(object.market) ? Market.fromJSON(object.market) : undefined,
    };
  },

  toJSON(message: QueryGetMarketResponse): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.market !== undefined) {
      obj.market = Market.toJSON(message.market);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetMarketResponse>, I>>(base?: I): QueryGetMarketResponse {
    return QueryGetMarketResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetMarketResponse>, I>>(object: I): QueryGetMarketResponse {
    const message = createBaseQueryGetMarketResponse();
    message.address = object.address ?? "";
    message.market = (object.market !== undefined && object.market !== null)
      ? Market.fromPartial(object.market)
      : undefined;
    return message;
  },
};

function createBaseQueryGetAllMarketsRequest(): QueryGetAllMarketsRequest {
  return { pagination: undefined };
}

export const QueryGetAllMarketsRequest: MessageFns<QueryGetAllMarketsRequest> = {
  encode(message: QueryGetAllMarketsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetAllMarketsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetAllMarketsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetAllMarketsRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryGetAllMarketsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetAllMarketsRequest>, I>>(base?: I): QueryGetAllMarketsRequest {
    return QueryGetAllMarketsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetAllMarketsRequest>, I>>(object: I): QueryGetAllMarketsRequest {
    const message = createBaseQueryGetAllMarketsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetAllMarketsResponse(): QueryGetAllMarketsResponse {
  return { markets: [], pagination: undefined };
}

export const QueryGetAllMarketsResponse: MessageFns<QueryGetAllMarketsResponse> = {
  encode(message: QueryGetAllMarketsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.markets) {
      MarketBrief.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetAllMarketsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetAllMarketsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.markets.push(MarketBrief.decode(reader, reader.uint32()));
          continue;
        }
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetAllMarketsResponse {
    return {
      markets: globalThis.Array.isArray(object?.markets) ? object.markets.map((e: any) => MarketBrief.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryGetAllMarketsResponse): unknown {
    const obj: any = {};
    if (message.markets?.length) {
      obj.markets = message.markets.map((e) => MarketBrief.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetAllMarketsResponse>, I>>(base?: I): QueryGetAllMarketsResponse {
    return QueryGetAllMarketsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetAllMarketsResponse>, I>>(object: I): QueryGetAllMarketsResponse {
    const message = createBaseQueryGetAllMarketsResponse();
    message.markets = object.markets?.map((e) => MarketBrief.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(_: QueryParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(base?: I): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(_: I): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(message: QueryParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(base?: I): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(object: I): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryCommitmentSettlementFeeCalcRequest(): QueryCommitmentSettlementFeeCalcRequest {
  return { settlement: undefined, includeBreakdownFields: false };
}

export const QueryCommitmentSettlementFeeCalcRequest: MessageFns<QueryCommitmentSettlementFeeCalcRequest> = {
  encode(message: QueryCommitmentSettlementFeeCalcRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.settlement !== undefined) {
      MsgMarketCommitmentSettleRequest.encode(message.settlement, writer.uint32(10).fork()).join();
    }
    if (message.includeBreakdownFields !== false) {
      writer.uint32(16).bool(message.includeBreakdownFields);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCommitmentSettlementFeeCalcRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCommitmentSettlementFeeCalcRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.settlement = MsgMarketCommitmentSettleRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.includeBreakdownFields = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCommitmentSettlementFeeCalcRequest {
    return {
      settlement: isSet(object.settlement) ? MsgMarketCommitmentSettleRequest.fromJSON(object.settlement) : undefined,
      includeBreakdownFields: isSet(object.includeBreakdownFields)
        ? globalThis.Boolean(object.includeBreakdownFields)
        : false,
    };
  },

  toJSON(message: QueryCommitmentSettlementFeeCalcRequest): unknown {
    const obj: any = {};
    if (message.settlement !== undefined) {
      obj.settlement = MsgMarketCommitmentSettleRequest.toJSON(message.settlement);
    }
    if (message.includeBreakdownFields !== false) {
      obj.includeBreakdownFields = message.includeBreakdownFields;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCommitmentSettlementFeeCalcRequest>, I>>(
    base?: I,
  ): QueryCommitmentSettlementFeeCalcRequest {
    return QueryCommitmentSettlementFeeCalcRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCommitmentSettlementFeeCalcRequest>, I>>(
    object: I,
  ): QueryCommitmentSettlementFeeCalcRequest {
    const message = createBaseQueryCommitmentSettlementFeeCalcRequest();
    message.settlement = (object.settlement !== undefined && object.settlement !== null)
      ? MsgMarketCommitmentSettleRequest.fromPartial(object.settlement)
      : undefined;
    message.includeBreakdownFields = object.includeBreakdownFields ?? false;
    return message;
  },
};

function createBaseQueryCommitmentSettlementFeeCalcResponse(): QueryCommitmentSettlementFeeCalcResponse {
  return { exchangeFees: [], inputTotal: [], convertedTotal: [], conversionNavs: [], toFeeNav: undefined };
}

export const QueryCommitmentSettlementFeeCalcResponse: MessageFns<QueryCommitmentSettlementFeeCalcResponse> = {
  encode(message: QueryCommitmentSettlementFeeCalcResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.exchangeFees) {
      Coin.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.inputTotal) {
      Coin.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.convertedTotal) {
      Coin.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.conversionNavs) {
      NetAssetPrice.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.toFeeNav !== undefined) {
      NetAssetPrice.encode(message.toFeeNav, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCommitmentSettlementFeeCalcResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCommitmentSettlementFeeCalcResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.exchangeFees.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inputTotal.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.convertedTotal.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.conversionNavs.push(NetAssetPrice.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.toFeeNav = NetAssetPrice.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCommitmentSettlementFeeCalcResponse {
    return {
      exchangeFees: globalThis.Array.isArray(object?.exchangeFees)
        ? object.exchangeFees.map((e: any) => Coin.fromJSON(e))
        : [],
      inputTotal: globalThis.Array.isArray(object?.inputTotal)
        ? object.inputTotal.map((e: any) => Coin.fromJSON(e))
        : [],
      convertedTotal: globalThis.Array.isArray(object?.convertedTotal)
        ? object.convertedTotal.map((e: any) => Coin.fromJSON(e))
        : [],
      conversionNavs: globalThis.Array.isArray(object?.conversionNavs)
        ? object.conversionNavs.map((e: any) => NetAssetPrice.fromJSON(e))
        : [],
      toFeeNav: isSet(object.toFeeNav) ? NetAssetPrice.fromJSON(object.toFeeNav) : undefined,
    };
  },

  toJSON(message: QueryCommitmentSettlementFeeCalcResponse): unknown {
    const obj: any = {};
    if (message.exchangeFees?.length) {
      obj.exchangeFees = message.exchangeFees.map((e) => Coin.toJSON(e));
    }
    if (message.inputTotal?.length) {
      obj.inputTotal = message.inputTotal.map((e) => Coin.toJSON(e));
    }
    if (message.convertedTotal?.length) {
      obj.convertedTotal = message.convertedTotal.map((e) => Coin.toJSON(e));
    }
    if (message.conversionNavs?.length) {
      obj.conversionNavs = message.conversionNavs.map((e) => NetAssetPrice.toJSON(e));
    }
    if (message.toFeeNav !== undefined) {
      obj.toFeeNav = NetAssetPrice.toJSON(message.toFeeNav);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCommitmentSettlementFeeCalcResponse>, I>>(
    base?: I,
  ): QueryCommitmentSettlementFeeCalcResponse {
    return QueryCommitmentSettlementFeeCalcResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCommitmentSettlementFeeCalcResponse>, I>>(
    object: I,
  ): QueryCommitmentSettlementFeeCalcResponse {
    const message = createBaseQueryCommitmentSettlementFeeCalcResponse();
    message.exchangeFees = object.exchangeFees?.map((e) => Coin.fromPartial(e)) || [];
    message.inputTotal = object.inputTotal?.map((e) => Coin.fromPartial(e)) || [];
    message.convertedTotal = object.convertedTotal?.map((e) => Coin.fromPartial(e)) || [];
    message.conversionNavs = object.conversionNavs?.map((e) => NetAssetPrice.fromPartial(e)) || [];
    message.toFeeNav = (object.toFeeNav !== undefined && object.toFeeNav !== null)
      ? NetAssetPrice.fromPartial(object.toFeeNav)
      : undefined;
    return message;
  },
};

function createBaseQueryValidateCreateMarketRequest(): QueryValidateCreateMarketRequest {
  return { createMarketRequest: undefined };
}

export const QueryValidateCreateMarketRequest: MessageFns<QueryValidateCreateMarketRequest> = {
  encode(message: QueryValidateCreateMarketRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createMarketRequest !== undefined) {
      MsgGovCreateMarketRequest.encode(message.createMarketRequest, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryValidateCreateMarketRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryValidateCreateMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.createMarketRequest = MsgGovCreateMarketRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryValidateCreateMarketRequest {
    return {
      createMarketRequest: isSet(object.createMarketRequest)
        ? MsgGovCreateMarketRequest.fromJSON(object.createMarketRequest)
        : undefined,
    };
  },

  toJSON(message: QueryValidateCreateMarketRequest): unknown {
    const obj: any = {};
    if (message.createMarketRequest !== undefined) {
      obj.createMarketRequest = MsgGovCreateMarketRequest.toJSON(message.createMarketRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryValidateCreateMarketRequest>, I>>(
    base?: I,
  ): QueryValidateCreateMarketRequest {
    return QueryValidateCreateMarketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryValidateCreateMarketRequest>, I>>(
    object: I,
  ): QueryValidateCreateMarketRequest {
    const message = createBaseQueryValidateCreateMarketRequest();
    message.createMarketRequest = (object.createMarketRequest !== undefined && object.createMarketRequest !== null)
      ? MsgGovCreateMarketRequest.fromPartial(object.createMarketRequest)
      : undefined;
    return message;
  },
};

function createBaseQueryValidateCreateMarketResponse(): QueryValidateCreateMarketResponse {
  return { error: "", govPropWillPass: false };
}

export const QueryValidateCreateMarketResponse: MessageFns<QueryValidateCreateMarketResponse> = {
  encode(message: QueryValidateCreateMarketResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== "") {
      writer.uint32(10).string(message.error);
    }
    if (message.govPropWillPass !== false) {
      writer.uint32(16).bool(message.govPropWillPass);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryValidateCreateMarketResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryValidateCreateMarketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.govPropWillPass = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryValidateCreateMarketResponse {
    return {
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      govPropWillPass: isSet(object.govPropWillPass) ? globalThis.Boolean(object.govPropWillPass) : false,
    };
  },

  toJSON(message: QueryValidateCreateMarketResponse): unknown {
    const obj: any = {};
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.govPropWillPass !== false) {
      obj.govPropWillPass = message.govPropWillPass;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryValidateCreateMarketResponse>, I>>(
    base?: I,
  ): QueryValidateCreateMarketResponse {
    return QueryValidateCreateMarketResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryValidateCreateMarketResponse>, I>>(
    object: I,
  ): QueryValidateCreateMarketResponse {
    const message = createBaseQueryValidateCreateMarketResponse();
    message.error = object.error ?? "";
    message.govPropWillPass = object.govPropWillPass ?? false;
    return message;
  },
};

function createBaseQueryValidateMarketRequest(): QueryValidateMarketRequest {
  return { marketId: 0 };
}

export const QueryValidateMarketRequest: MessageFns<QueryValidateMarketRequest> = {
  encode(message: QueryValidateMarketRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryValidateMarketRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryValidateMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryValidateMarketRequest {
    return { marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0 };
  },

  toJSON(message: QueryValidateMarketRequest): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryValidateMarketRequest>, I>>(base?: I): QueryValidateMarketRequest {
    return QueryValidateMarketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryValidateMarketRequest>, I>>(object: I): QueryValidateMarketRequest {
    const message = createBaseQueryValidateMarketRequest();
    message.marketId = object.marketId ?? 0;
    return message;
  },
};

function createBaseQueryValidateMarketResponse(): QueryValidateMarketResponse {
  return { error: "" };
}

export const QueryValidateMarketResponse: MessageFns<QueryValidateMarketResponse> = {
  encode(message: QueryValidateMarketResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== "") {
      writer.uint32(10).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryValidateMarketResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryValidateMarketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryValidateMarketResponse {
    return { error: isSet(object.error) ? globalThis.String(object.error) : "" };
  },

  toJSON(message: QueryValidateMarketResponse): unknown {
    const obj: any = {};
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryValidateMarketResponse>, I>>(base?: I): QueryValidateMarketResponse {
    return QueryValidateMarketResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryValidateMarketResponse>, I>>(object: I): QueryValidateMarketResponse {
    const message = createBaseQueryValidateMarketResponse();
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseQueryValidateManageFeesRequest(): QueryValidateManageFeesRequest {
  return { manageFeesRequest: undefined };
}

export const QueryValidateManageFeesRequest: MessageFns<QueryValidateManageFeesRequest> = {
  encode(message: QueryValidateManageFeesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.manageFeesRequest !== undefined) {
      MsgGovManageFeesRequest.encode(message.manageFeesRequest, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryValidateManageFeesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryValidateManageFeesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.manageFeesRequest = MsgGovManageFeesRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryValidateManageFeesRequest {
    return {
      manageFeesRequest: isSet(object.manageFeesRequest)
        ? MsgGovManageFeesRequest.fromJSON(object.manageFeesRequest)
        : undefined,
    };
  },

  toJSON(message: QueryValidateManageFeesRequest): unknown {
    const obj: any = {};
    if (message.manageFeesRequest !== undefined) {
      obj.manageFeesRequest = MsgGovManageFeesRequest.toJSON(message.manageFeesRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryValidateManageFeesRequest>, I>>(base?: I): QueryValidateManageFeesRequest {
    return QueryValidateManageFeesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryValidateManageFeesRequest>, I>>(
    object: I,
  ): QueryValidateManageFeesRequest {
    const message = createBaseQueryValidateManageFeesRequest();
    message.manageFeesRequest = (object.manageFeesRequest !== undefined && object.manageFeesRequest !== null)
      ? MsgGovManageFeesRequest.fromPartial(object.manageFeesRequest)
      : undefined;
    return message;
  },
};

function createBaseQueryValidateManageFeesResponse(): QueryValidateManageFeesResponse {
  return { error: "", govPropWillPass: false };
}

export const QueryValidateManageFeesResponse: MessageFns<QueryValidateManageFeesResponse> = {
  encode(message: QueryValidateManageFeesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== "") {
      writer.uint32(10).string(message.error);
    }
    if (message.govPropWillPass !== false) {
      writer.uint32(16).bool(message.govPropWillPass);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryValidateManageFeesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryValidateManageFeesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.govPropWillPass = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryValidateManageFeesResponse {
    return {
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      govPropWillPass: isSet(object.govPropWillPass) ? globalThis.Boolean(object.govPropWillPass) : false,
    };
  },

  toJSON(message: QueryValidateManageFeesResponse): unknown {
    const obj: any = {};
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.govPropWillPass !== false) {
      obj.govPropWillPass = message.govPropWillPass;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryValidateManageFeesResponse>, I>>(base?: I): QueryValidateManageFeesResponse {
    return QueryValidateManageFeesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryValidateManageFeesResponse>, I>>(
    object: I,
  ): QueryValidateManageFeesResponse {
    const message = createBaseQueryValidateManageFeesResponse();
    message.error = object.error ?? "";
    message.govPropWillPass = object.govPropWillPass ?? false;
    return message;
  },
};

function createBaseQueryGetPaymentRequest(): QueryGetPaymentRequest {
  return { source: "", externalId: "" };
}

export const QueryGetPaymentRequest: MessageFns<QueryGetPaymentRequest> = {
  encode(message: QueryGetPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.externalId !== "") {
      writer.uint32(18).string(message.externalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetPaymentRequest {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
    };
  },

  toJSON(message: QueryGetPaymentRequest): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetPaymentRequest>, I>>(base?: I): QueryGetPaymentRequest {
    return QueryGetPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetPaymentRequest>, I>>(object: I): QueryGetPaymentRequest {
    const message = createBaseQueryGetPaymentRequest();
    message.source = object.source ?? "";
    message.externalId = object.externalId ?? "";
    return message;
  },
};

function createBaseQueryGetPaymentResponse(): QueryGetPaymentResponse {
  return { payment: undefined };
}

export const QueryGetPaymentResponse: MessageFns<QueryGetPaymentResponse> = {
  encode(message: QueryGetPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payment !== undefined) {
      Payment.encode(message.payment, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payment = Payment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetPaymentResponse {
    return { payment: isSet(object.payment) ? Payment.fromJSON(object.payment) : undefined };
  },

  toJSON(message: QueryGetPaymentResponse): unknown {
    const obj: any = {};
    if (message.payment !== undefined) {
      obj.payment = Payment.toJSON(message.payment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetPaymentResponse>, I>>(base?: I): QueryGetPaymentResponse {
    return QueryGetPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetPaymentResponse>, I>>(object: I): QueryGetPaymentResponse {
    const message = createBaseQueryGetPaymentResponse();
    message.payment = (object.payment !== undefined && object.payment !== null)
      ? Payment.fromPartial(object.payment)
      : undefined;
    return message;
  },
};

function createBaseQueryGetPaymentsWithSourceRequest(): QueryGetPaymentsWithSourceRequest {
  return { source: "", pagination: undefined };
}

export const QueryGetPaymentsWithSourceRequest: MessageFns<QueryGetPaymentsWithSourceRequest> = {
  encode(message: QueryGetPaymentsWithSourceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetPaymentsWithSourceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetPaymentsWithSourceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetPaymentsWithSourceRequest {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryGetPaymentsWithSourceRequest): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetPaymentsWithSourceRequest>, I>>(
    base?: I,
  ): QueryGetPaymentsWithSourceRequest {
    return QueryGetPaymentsWithSourceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetPaymentsWithSourceRequest>, I>>(
    object: I,
  ): QueryGetPaymentsWithSourceRequest {
    const message = createBaseQueryGetPaymentsWithSourceRequest();
    message.source = object.source ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetPaymentsWithSourceResponse(): QueryGetPaymentsWithSourceResponse {
  return { payments: [], pagination: undefined };
}

export const QueryGetPaymentsWithSourceResponse: MessageFns<QueryGetPaymentsWithSourceResponse> = {
  encode(message: QueryGetPaymentsWithSourceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.payments) {
      Payment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetPaymentsWithSourceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetPaymentsWithSourceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payments.push(Payment.decode(reader, reader.uint32()));
          continue;
        }
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetPaymentsWithSourceResponse {
    return {
      payments: globalThis.Array.isArray(object?.payments) ? object.payments.map((e: any) => Payment.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryGetPaymentsWithSourceResponse): unknown {
    const obj: any = {};
    if (message.payments?.length) {
      obj.payments = message.payments.map((e) => Payment.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetPaymentsWithSourceResponse>, I>>(
    base?: I,
  ): QueryGetPaymentsWithSourceResponse {
    return QueryGetPaymentsWithSourceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetPaymentsWithSourceResponse>, I>>(
    object: I,
  ): QueryGetPaymentsWithSourceResponse {
    const message = createBaseQueryGetPaymentsWithSourceResponse();
    message.payments = object.payments?.map((e) => Payment.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetPaymentsWithTargetRequest(): QueryGetPaymentsWithTargetRequest {
  return { target: "", pagination: undefined };
}

export const QueryGetPaymentsWithTargetRequest: MessageFns<QueryGetPaymentsWithTargetRequest> = {
  encode(message: QueryGetPaymentsWithTargetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== "") {
      writer.uint32(10).string(message.target);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetPaymentsWithTargetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetPaymentsWithTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.target = reader.string();
          continue;
        }
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetPaymentsWithTargetRequest {
    return {
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryGetPaymentsWithTargetRequest): unknown {
    const obj: any = {};
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetPaymentsWithTargetRequest>, I>>(
    base?: I,
  ): QueryGetPaymentsWithTargetRequest {
    return QueryGetPaymentsWithTargetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetPaymentsWithTargetRequest>, I>>(
    object: I,
  ): QueryGetPaymentsWithTargetRequest {
    const message = createBaseQueryGetPaymentsWithTargetRequest();
    message.target = object.target ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetPaymentsWithTargetResponse(): QueryGetPaymentsWithTargetResponse {
  return { payments: [], pagination: undefined };
}

export const QueryGetPaymentsWithTargetResponse: MessageFns<QueryGetPaymentsWithTargetResponse> = {
  encode(message: QueryGetPaymentsWithTargetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.payments) {
      Payment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetPaymentsWithTargetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetPaymentsWithTargetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payments.push(Payment.decode(reader, reader.uint32()));
          continue;
        }
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetPaymentsWithTargetResponse {
    return {
      payments: globalThis.Array.isArray(object?.payments) ? object.payments.map((e: any) => Payment.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryGetPaymentsWithTargetResponse): unknown {
    const obj: any = {};
    if (message.payments?.length) {
      obj.payments = message.payments.map((e) => Payment.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetPaymentsWithTargetResponse>, I>>(
    base?: I,
  ): QueryGetPaymentsWithTargetResponse {
    return QueryGetPaymentsWithTargetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetPaymentsWithTargetResponse>, I>>(
    object: I,
  ): QueryGetPaymentsWithTargetResponse {
    const message = createBaseQueryGetPaymentsWithTargetResponse();
    message.payments = object.payments?.map((e) => Payment.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetAllPaymentsRequest(): QueryGetAllPaymentsRequest {
  return { pagination: undefined };
}

export const QueryGetAllPaymentsRequest: MessageFns<QueryGetAllPaymentsRequest> = {
  encode(message: QueryGetAllPaymentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetAllPaymentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetAllPaymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetAllPaymentsRequest {
    return { pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
  },

  toJSON(message: QueryGetAllPaymentsRequest): unknown {
    const obj: any = {};
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetAllPaymentsRequest>, I>>(base?: I): QueryGetAllPaymentsRequest {
    return QueryGetAllPaymentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetAllPaymentsRequest>, I>>(object: I): QueryGetAllPaymentsRequest {
    const message = createBaseQueryGetAllPaymentsRequest();
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryGetAllPaymentsResponse(): QueryGetAllPaymentsResponse {
  return { payments: [], pagination: undefined };
}

export const QueryGetAllPaymentsResponse: MessageFns<QueryGetAllPaymentsResponse> = {
  encode(message: QueryGetAllPaymentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.payments) {
      Payment.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(794).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryGetAllPaymentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryGetAllPaymentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payments.push(Payment.decode(reader, reader.uint32()));
          continue;
        }
        case 99: {
          if (tag !== 794) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryGetAllPaymentsResponse {
    return {
      payments: globalThis.Array.isArray(object?.payments) ? object.payments.map((e: any) => Payment.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryGetAllPaymentsResponse): unknown {
    const obj: any = {};
    if (message.payments?.length) {
      obj.payments = message.payments.map((e) => Payment.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryGetAllPaymentsResponse>, I>>(base?: I): QueryGetAllPaymentsResponse {
    return QueryGetAllPaymentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryGetAllPaymentsResponse>, I>>(object: I): QueryGetAllPaymentsResponse {
    const message = createBaseQueryGetAllPaymentsResponse();
    message.payments = object.payments?.map((e) => Payment.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryPaymentFeeCalcRequest(): QueryPaymentFeeCalcRequest {
  return { payment: undefined };
}

export const QueryPaymentFeeCalcRequest: MessageFns<QueryPaymentFeeCalcRequest> = {
  encode(message: QueryPaymentFeeCalcRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payment !== undefined) {
      Payment.encode(message.payment, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPaymentFeeCalcRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPaymentFeeCalcRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payment = Payment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPaymentFeeCalcRequest {
    return { payment: isSet(object.payment) ? Payment.fromJSON(object.payment) : undefined };
  },

  toJSON(message: QueryPaymentFeeCalcRequest): unknown {
    const obj: any = {};
    if (message.payment !== undefined) {
      obj.payment = Payment.toJSON(message.payment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPaymentFeeCalcRequest>, I>>(base?: I): QueryPaymentFeeCalcRequest {
    return QueryPaymentFeeCalcRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPaymentFeeCalcRequest>, I>>(object: I): QueryPaymentFeeCalcRequest {
    const message = createBaseQueryPaymentFeeCalcRequest();
    message.payment = (object.payment !== undefined && object.payment !== null)
      ? Payment.fromPartial(object.payment)
      : undefined;
    return message;
  },
};

function createBaseQueryPaymentFeeCalcResponse(): QueryPaymentFeeCalcResponse {
  return { feeCreate: [], feeAccept: [] };
}

export const QueryPaymentFeeCalcResponse: MessageFns<QueryPaymentFeeCalcResponse> = {
  encode(message: QueryPaymentFeeCalcResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.feeCreate) {
      Coin.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.feeAccept) {
      Coin.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPaymentFeeCalcResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPaymentFeeCalcResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.feeCreate.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.feeAccept.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPaymentFeeCalcResponse {
    return {
      feeCreate: globalThis.Array.isArray(object?.feeCreate) ? object.feeCreate.map((e: any) => Coin.fromJSON(e)) : [],
      feeAccept: globalThis.Array.isArray(object?.feeAccept) ? object.feeAccept.map((e: any) => Coin.fromJSON(e)) : [],
    };
  },

  toJSON(message: QueryPaymentFeeCalcResponse): unknown {
    const obj: any = {};
    if (message.feeCreate?.length) {
      obj.feeCreate = message.feeCreate.map((e) => Coin.toJSON(e));
    }
    if (message.feeAccept?.length) {
      obj.feeAccept = message.feeAccept.map((e) => Coin.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPaymentFeeCalcResponse>, I>>(base?: I): QueryPaymentFeeCalcResponse {
    return QueryPaymentFeeCalcResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPaymentFeeCalcResponse>, I>>(object: I): QueryPaymentFeeCalcResponse {
    const message = createBaseQueryPaymentFeeCalcResponse();
    message.feeCreate = object.feeCreate?.map((e) => Coin.fromPartial(e)) || [];
    message.feeAccept = object.feeAccept?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

/** Query is the service for exchange module's query endpoints. */
export interface Query {
  /** OrderFeeCalc calculates the fees that will be associated with the provided order. */
  OrderFeeCalc(request: QueryOrderFeeCalcRequest): Promise<QueryOrderFeeCalcResponse>;
  /** GetOrder looks up an order by id. */
  GetOrder(request: QueryGetOrderRequest): Promise<QueryGetOrderResponse>;
  /** GetOrderByExternalID looks up an order by market id and external id. */
  GetOrderByExternalID(request: QueryGetOrderByExternalIDRequest): Promise<QueryGetOrderByExternalIDResponse>;
  /** GetMarketOrders looks up the orders in a market. */
  GetMarketOrders(request: QueryGetMarketOrdersRequest): Promise<QueryGetMarketOrdersResponse>;
  /** GetOwnerOrders looks up the orders from the provided owner address. */
  GetOwnerOrders(request: QueryGetOwnerOrdersRequest): Promise<QueryGetOwnerOrdersResponse>;
  /** GetAssetOrders looks up the orders for a specific asset denom. */
  GetAssetOrders(request: QueryGetAssetOrdersRequest): Promise<QueryGetAssetOrdersResponse>;
  /** GetAllOrders gets all orders in the exchange module. */
  GetAllOrders(request: QueryGetAllOrdersRequest): Promise<QueryGetAllOrdersResponse>;
  /** GetCommitment gets the funds in an account that are committed to the market. */
  GetCommitment(request: QueryGetCommitmentRequest): Promise<QueryGetCommitmentResponse>;
  /** GetAccountCommitments gets all the funds in an account that are committed to any market. */
  GetAccountCommitments(request: QueryGetAccountCommitmentsRequest): Promise<QueryGetAccountCommitmentsResponse>;
  /** GetMarketCommitments gets all the funds committed to a market from any account. */
  GetMarketCommitments(request: QueryGetMarketCommitmentsRequest): Promise<QueryGetMarketCommitmentsResponse>;
  /** GetAllCommitments gets all fund committed to any market from any account. */
  GetAllCommitments(request: QueryGetAllCommitmentsRequest): Promise<QueryGetAllCommitmentsResponse>;
  /** GetMarket returns all the information and details about a market. */
  GetMarket(request: QueryGetMarketRequest): Promise<QueryGetMarketResponse>;
  /** GetAllMarkets returns brief information about each market. */
  GetAllMarkets(request: QueryGetAllMarketsRequest): Promise<QueryGetAllMarketsResponse>;
  /** Params returns the exchange module parameters. */
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
  /** CommitmentSettlementFeeCalc calculates the fees a market will pay for a commitment settlement using current NAVs. */
  CommitmentSettlementFeeCalc(
    request: QueryCommitmentSettlementFeeCalcRequest,
  ): Promise<QueryCommitmentSettlementFeeCalcResponse>;
  /** ValidateCreateMarket checks the provided MsgGovCreateMarketResponse and returns any errors it might have. */
  ValidateCreateMarket(request: QueryValidateCreateMarketRequest): Promise<QueryValidateCreateMarketResponse>;
  /** ValidateMarket checks for any problems with a market's setup. */
  ValidateMarket(request: QueryValidateMarketRequest): Promise<QueryValidateMarketResponse>;
  /** ValidateManageFees checks the provided MsgGovManageFeesRequest and returns any errors that it might have. */
  ValidateManageFees(request: QueryValidateManageFeesRequest): Promise<QueryValidateManageFeesResponse>;
  /** GetPayment gets a single specific payment. */
  GetPayment(request: QueryGetPaymentRequest): Promise<QueryGetPaymentResponse>;
  /** GetPaymentsWithSource gets all payments with a specific source account. */
  GetPaymentsWithSource(request: QueryGetPaymentsWithSourceRequest): Promise<QueryGetPaymentsWithSourceResponse>;
  /** GetPaymentsWithTarget gets all payments with a specific target account. */
  GetPaymentsWithTarget(request: QueryGetPaymentsWithTargetRequest): Promise<QueryGetPaymentsWithTargetResponse>;
  /** GetAllPayments gets all payments. */
  GetAllPayments(request: QueryGetAllPaymentsRequest): Promise<QueryGetAllPaymentsResponse>;
  /** PaymentFeeCalc calculates the fees that must be paid for creating or accepting a specific payment. */
  PaymentFeeCalc(request: QueryPaymentFeeCalcRequest): Promise<QueryPaymentFeeCalcResponse>;
}

export const QueryServiceName = "provenance.exchange.v1.Query";
export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceName;
    this.rpc = rpc;
    this.OrderFeeCalc = this.OrderFeeCalc.bind(this);
    this.GetOrder = this.GetOrder.bind(this);
    this.GetOrderByExternalID = this.GetOrderByExternalID.bind(this);
    this.GetMarketOrders = this.GetMarketOrders.bind(this);
    this.GetOwnerOrders = this.GetOwnerOrders.bind(this);
    this.GetAssetOrders = this.GetAssetOrders.bind(this);
    this.GetAllOrders = this.GetAllOrders.bind(this);
    this.GetCommitment = this.GetCommitment.bind(this);
    this.GetAccountCommitments = this.GetAccountCommitments.bind(this);
    this.GetMarketCommitments = this.GetMarketCommitments.bind(this);
    this.GetAllCommitments = this.GetAllCommitments.bind(this);
    this.GetMarket = this.GetMarket.bind(this);
    this.GetAllMarkets = this.GetAllMarkets.bind(this);
    this.Params = this.Params.bind(this);
    this.CommitmentSettlementFeeCalc = this.CommitmentSettlementFeeCalc.bind(this);
    this.ValidateCreateMarket = this.ValidateCreateMarket.bind(this);
    this.ValidateMarket = this.ValidateMarket.bind(this);
    this.ValidateManageFees = this.ValidateManageFees.bind(this);
    this.GetPayment = this.GetPayment.bind(this);
    this.GetPaymentsWithSource = this.GetPaymentsWithSource.bind(this);
    this.GetPaymentsWithTarget = this.GetPaymentsWithTarget.bind(this);
    this.GetAllPayments = this.GetAllPayments.bind(this);
    this.PaymentFeeCalc = this.PaymentFeeCalc.bind(this);
  }
  OrderFeeCalc(request: QueryOrderFeeCalcRequest): Promise<QueryOrderFeeCalcResponse> {
    const data = QueryOrderFeeCalcRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "OrderFeeCalc", data);
    return promise.then((data) => QueryOrderFeeCalcResponse.decode(new BinaryReader(data)));
  }

  GetOrder(request: QueryGetOrderRequest): Promise<QueryGetOrderResponse> {
    const data = QueryGetOrderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetOrder", data);
    return promise.then((data) => QueryGetOrderResponse.decode(new BinaryReader(data)));
  }

  GetOrderByExternalID(request: QueryGetOrderByExternalIDRequest): Promise<QueryGetOrderByExternalIDResponse> {
    const data = QueryGetOrderByExternalIDRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetOrderByExternalID", data);
    return promise.then((data) => QueryGetOrderByExternalIDResponse.decode(new BinaryReader(data)));
  }

  GetMarketOrders(request: QueryGetMarketOrdersRequest): Promise<QueryGetMarketOrdersResponse> {
    const data = QueryGetMarketOrdersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetMarketOrders", data);
    return promise.then((data) => QueryGetMarketOrdersResponse.decode(new BinaryReader(data)));
  }

  GetOwnerOrders(request: QueryGetOwnerOrdersRequest): Promise<QueryGetOwnerOrdersResponse> {
    const data = QueryGetOwnerOrdersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetOwnerOrders", data);
    return promise.then((data) => QueryGetOwnerOrdersResponse.decode(new BinaryReader(data)));
  }

  GetAssetOrders(request: QueryGetAssetOrdersRequest): Promise<QueryGetAssetOrdersResponse> {
    const data = QueryGetAssetOrdersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAssetOrders", data);
    return promise.then((data) => QueryGetAssetOrdersResponse.decode(new BinaryReader(data)));
  }

  GetAllOrders(request: QueryGetAllOrdersRequest): Promise<QueryGetAllOrdersResponse> {
    const data = QueryGetAllOrdersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAllOrders", data);
    return promise.then((data) => QueryGetAllOrdersResponse.decode(new BinaryReader(data)));
  }

  GetCommitment(request: QueryGetCommitmentRequest): Promise<QueryGetCommitmentResponse> {
    const data = QueryGetCommitmentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetCommitment", data);
    return promise.then((data) => QueryGetCommitmentResponse.decode(new BinaryReader(data)));
  }

  GetAccountCommitments(request: QueryGetAccountCommitmentsRequest): Promise<QueryGetAccountCommitmentsResponse> {
    const data = QueryGetAccountCommitmentsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAccountCommitments", data);
    return promise.then((data) => QueryGetAccountCommitmentsResponse.decode(new BinaryReader(data)));
  }

  GetMarketCommitments(request: QueryGetMarketCommitmentsRequest): Promise<QueryGetMarketCommitmentsResponse> {
    const data = QueryGetMarketCommitmentsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetMarketCommitments", data);
    return promise.then((data) => QueryGetMarketCommitmentsResponse.decode(new BinaryReader(data)));
  }

  GetAllCommitments(request: QueryGetAllCommitmentsRequest): Promise<QueryGetAllCommitmentsResponse> {
    const data = QueryGetAllCommitmentsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAllCommitments", data);
    return promise.then((data) => QueryGetAllCommitmentsResponse.decode(new BinaryReader(data)));
  }

  GetMarket(request: QueryGetMarketRequest): Promise<QueryGetMarketResponse> {
    const data = QueryGetMarketRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetMarket", data);
    return promise.then((data) => QueryGetMarketResponse.decode(new BinaryReader(data)));
  }

  GetAllMarkets(request: QueryGetAllMarketsRequest): Promise<QueryGetAllMarketsResponse> {
    const data = QueryGetAllMarketsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAllMarkets", data);
    return promise.then((data) => QueryGetAllMarketsResponse.decode(new BinaryReader(data)));
  }

  Params(request: QueryParamsRequest): Promise<QueryParamsResponse> {
    const data = QueryParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Params", data);
    return promise.then((data) => QueryParamsResponse.decode(new BinaryReader(data)));
  }

  CommitmentSettlementFeeCalc(
    request: QueryCommitmentSettlementFeeCalcRequest,
  ): Promise<QueryCommitmentSettlementFeeCalcResponse> {
    const data = QueryCommitmentSettlementFeeCalcRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CommitmentSettlementFeeCalc", data);
    return promise.then((data) => QueryCommitmentSettlementFeeCalcResponse.decode(new BinaryReader(data)));
  }

  ValidateCreateMarket(request: QueryValidateCreateMarketRequest): Promise<QueryValidateCreateMarketResponse> {
    const data = QueryValidateCreateMarketRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ValidateCreateMarket", data);
    return promise.then((data) => QueryValidateCreateMarketResponse.decode(new BinaryReader(data)));
  }

  ValidateMarket(request: QueryValidateMarketRequest): Promise<QueryValidateMarketResponse> {
    const data = QueryValidateMarketRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ValidateMarket", data);
    return promise.then((data) => QueryValidateMarketResponse.decode(new BinaryReader(data)));
  }

  ValidateManageFees(request: QueryValidateManageFeesRequest): Promise<QueryValidateManageFeesResponse> {
    const data = QueryValidateManageFeesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ValidateManageFees", data);
    return promise.then((data) => QueryValidateManageFeesResponse.decode(new BinaryReader(data)));
  }

  GetPayment(request: QueryGetPaymentRequest): Promise<QueryGetPaymentResponse> {
    const data = QueryGetPaymentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPayment", data);
    return promise.then((data) => QueryGetPaymentResponse.decode(new BinaryReader(data)));
  }

  GetPaymentsWithSource(request: QueryGetPaymentsWithSourceRequest): Promise<QueryGetPaymentsWithSourceResponse> {
    const data = QueryGetPaymentsWithSourceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPaymentsWithSource", data);
    return promise.then((data) => QueryGetPaymentsWithSourceResponse.decode(new BinaryReader(data)));
  }

  GetPaymentsWithTarget(request: QueryGetPaymentsWithTargetRequest): Promise<QueryGetPaymentsWithTargetResponse> {
    const data = QueryGetPaymentsWithTargetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetPaymentsWithTarget", data);
    return promise.then((data) => QueryGetPaymentsWithTargetResponse.decode(new BinaryReader(data)));
  }

  GetAllPayments(request: QueryGetAllPaymentsRequest): Promise<QueryGetAllPaymentsResponse> {
    const data = QueryGetAllPaymentsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetAllPayments", data);
    return promise.then((data) => QueryGetAllPaymentsResponse.decode(new BinaryReader(data)));
  }

  PaymentFeeCalc(request: QueryPaymentFeeCalcRequest): Promise<QueryPaymentFeeCalcResponse> {
    const data = QueryPaymentFeeCalcRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PaymentFeeCalc", data);
    return promise.then((data) => QueryPaymentFeeCalcResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
