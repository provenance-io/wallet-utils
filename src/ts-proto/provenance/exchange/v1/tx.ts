// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: provenance/exchange/v1/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { AccountAmount, NetAssetPrice } from "./commitments";
import { AccessGrant, FeeRatio, Market, MarketDetails } from "./market";
import { AskOrder, BidOrder } from "./orders";
import { Params } from "./params";
import { Payment } from "./payments";

export const protobufPackage = "provenance.exchange.v1";

/** MsgCreateAskRequest is a request message for the CreateAsk endpoint. */
export interface MsgCreateAskRequest {
  /** ask_order is the details of the order being created. */
  askOrder?:
    | AskOrder
    | undefined;
  /** order_creation_fee is the fee that is being paid to create this order. */
  orderCreationFee?: Coin | undefined;
}

/** MsgCreateAskResponse is a response message for the CreateAsk endpoint. */
export interface MsgCreateAskResponse {
  /** order_id is the id of the order created. */
  orderId: Long;
}

/** MsgCreateBidRequest is a request message for the CreateBid endpoint. */
export interface MsgCreateBidRequest {
  /** bid_order is the details of the order being created. */
  bidOrder?:
    | BidOrder
    | undefined;
  /** order_creation_fee is the fee that is being paid to create this order. */
  orderCreationFee?: Coin | undefined;
}

/** MsgCreateBidResponse is a response message for the CreateBid endpoint. */
export interface MsgCreateBidResponse {
  /** order_id is the id of the order created. */
  orderId: Long;
}

/** MsgCommitFundsRequest is a request message for the CommitFunds endpoint. */
export interface MsgCommitFundsRequest {
  /** account is the address of the account with the funds being committed. */
  account: string;
  /** market_id is the numerical identifier of the market the funds will be committed to. */
  marketId: number;
  /** amount is the funds being committed to the market. */
  amount: Coin[];
  /** creation_fee is the fee that is being paid to create this commitment. */
  creationFee?:
    | Coin
    | undefined;
  /** event_tag is a string that is included in the funds-committed event. Max length is 100 characters. */
  eventTag: string;
}

/** MsgCommitFundsResponse is a response message for the CommitFunds endpoint. */
export interface MsgCommitFundsResponse {
}

/** MsgCancelOrderRequest is a request message for the CancelOrder endpoint. */
export interface MsgCancelOrderRequest {
  /**
   * signer is the account requesting the order cancellation.
   * It must be either the order owner (e.g. the buyer or seller), the governance module account address, or an account
   * with cancel permission with the market that the order is in.
   */
  signer: string;
  /** order_id is the id of the order to cancel. */
  orderId: Long;
}

/** MsgCancelOrderResponse is a response message for the CancelOrder endpoint. */
export interface MsgCancelOrderResponse {
}

/** MsgFillBidsRequest is a request message for the FillBids endpoint. */
export interface MsgFillBidsRequest {
  /** seller is the address of the account with the assets to sell. */
  seller: string;
  /**
   * market_id is the numerical identifier of the market with the bids to fill.
   * All bid orders being filled must be in this market.
   */
  marketId: number;
  /**
   * total_assets are the things that the seller wishes to sell.
   * It must be the sum of all bid order assets.
   */
  totalAssets: Coin[];
  /**
   * bid_order_ids are the ids of the bid orders that you are trying to fill.
   * All ids must be for bid orders, and must be in the same market as the market_id.
   */
  bidOrderIds: Long[];
  /** seller_settlement_flat_fee is the flat fee for sellers that will be charged for this settlement. */
  sellerSettlementFlatFee?:
    | Coin
    | undefined;
  /** ask_order_creation_fee is the fee that is being paid to create this order (which is immediately then settled). */
  askOrderCreationFee?: Coin | undefined;
}

/** MsgFillBidsResponse is a response message for the FillBids endpoint. */
export interface MsgFillBidsResponse {
}

/** MsgFillAsksRequest is a request message for the FillAsks endpoint. */
export interface MsgFillAsksRequest {
  /** buyer is the address of the account attempting to buy some assets. */
  buyer: string;
  /**
   * market_id is the numerical identifier of the market with the asks to fill.
   * All ask orders being filled must be in this market.
   */
  marketId: number;
  /**
   * total_price is the total amount being spent on some assets.
   * It must be the sum of all ask order prices.
   */
  totalPrice?:
    | Coin
    | undefined;
  /**
   * ask_order_ids are the ids of the ask orders that you are trying to fill.
   * All ids must be for ask orders, and must be in the same market as the market_id.
   */
  askOrderIds: Long[];
  /**
   * buyer_settlement_fees are the fees (both flat and proportional) that the buyer will pay (in addition to the price)
   * for this settlement.
   */
  buyerSettlementFees: Coin[];
  /** bid_order_creation_fee is the fee that is being paid to create this order (which is immediately then settled). */
  bidOrderCreationFee?: Coin | undefined;
}

/** MsgFillAsksResponse is a response message for the FillAsks endpoint. */
export interface MsgFillAsksResponse {
}

/** MsgMarketSettleRequest is a request message for the MarketSettle endpoint. */
export interface MsgMarketSettleRequest {
  /** admin is the account with "settle" permission requesting this settlement. */
  admin: string;
  /** market_id is the numerical identifier of the market requesting this settlement. */
  marketId: number;
  /** ask_order_ids are the ask orders being filled. */
  askOrderIds: Long[];
  /** bid_order_ids are the bid orders being filled. */
  bidOrderIds: Long[];
  /**
   * expect_partial is whether to expect an order to only be partially filled. Set to true to indicate that either
   * the last ask order, or last bid order will be partially filled by this settlement. Set to false to indicate
   * that all provided orders will be filled in full during this settlement.
   */
  expectPartial: boolean;
}

/** MsgMarketSettleResponse is a response message for the MarketSettle endpoint. */
export interface MsgMarketSettleResponse {
}

/** MsgMarketCommitmentSettleRequest is a request message for the MarketCommitmentSettle endpoint. */
export interface MsgMarketCommitmentSettleRequest {
  /** admin is the account with "settle" permission requesting this settlement. */
  admin: string;
  /** market_id is the numerical identifier of the market requesting this settlement. */
  marketId: number;
  /** inputs defines where the funds are coming from. All of these funds must be already committed to the market. */
  inputs: AccountAmount[];
  /** outputs defines how the funds are to be distributed. These funds will be re-committed in the destination accounts. */
  outputs: AccountAmount[];
  /**
   * fees is the funds that the market is collecting as part of this settlement.
   * All of these funds must be already committed to the market.
   */
  fees: AccountAmount[];
  /** navs are any NAV info that should be updated at the beginning of this settlement. */
  navs: NetAssetPrice[];
  /** event_tag is a string that is included in the funds-committed/released events. Max length is 100 characters. */
  eventTag: string;
}

/** MsgMarketCommitmentSettleResponse is a response message for the MarketCommitmentSettle endpoint. */
export interface MsgMarketCommitmentSettleResponse {
}

/** MsgMarketReleaseCommitmentsRequest is a request message for the MarketReleaseCommitments endpoint. */
export interface MsgMarketReleaseCommitmentsRequest {
  /** admin is the account with "cancel" permission requesting this release. */
  admin: string;
  /** market_id is the numerical identifier of the market releasing these funds. */
  marketId: number;
  /**
   * to_release is the funds that are to be released.
   * An entry with a zero amount indicates that all committed funds for that account should be released.
   */
  toRelease: AccountAmount[];
  /** event_tag is a string that is included in the funds-released events. Max length is 100 characters. */
  eventTag: string;
}

/** MsgMarketReleaseCommitmentsResponse is a response message for the MarketReleaseCommitments endpoint. */
export interface MsgMarketReleaseCommitmentsResponse {
}

/** MsgMarketSetOrderExternalIDRequest is a request message for the MarketSetOrderExternalID endpoint. */
export interface MsgMarketSetOrderExternalIDRequest {
  /** admin is the account with "set_ids" permission requesting this settlement. */
  admin: string;
  /** market_id is the numerical identifier of the market with the orders to update. */
  marketId: number;
  /** order_id is the numerical identifier of the order to update. */
  orderId: Long;
  /**
   * external_id is the new external id to associate with the order. Max length is 100 characters.
   * If the external id is already associated with another order in this market, this update will fail.
   */
  externalId: string;
}

/** MsgMarketSetOrderExternalIDResponse is a response message for the MarketSetOrderExternalID endpoint. */
export interface MsgMarketSetOrderExternalIDResponse {
}

/** MsgMarketWithdrawRequest is a request message for the MarketWithdraw endpoint. */
export interface MsgMarketWithdrawRequest {
  /** admin is the account with withdraw permission requesting the withdrawal. */
  admin: string;
  /** market_id is the numerical identifier of the market to withdraw from. */
  marketId: number;
  /** to_address is the address that will receive the funds. */
  toAddress: string;
  /** amount is the funds to withdraw. */
  amount: Coin[];
}

/** MsgMarketWithdrawResponse is a response message for the MarketWithdraw endpoint. */
export interface MsgMarketWithdrawResponse {
}

/** MsgMarketUpdateDetailsRequest is a request message for the MarketUpdateDetails endpoint. */
export interface MsgMarketUpdateDetailsRequest {
  /** admin is the account with "update" permission requesting this change. */
  admin: string;
  /** market_id is the numerical identifier of the market to update details for. */
  marketId: number;
  /** market_details is some information about this market. */
  marketDetails?: MarketDetails | undefined;
}

/** MsgMarketUpdateDetailsResponse is a response message for the MarketUpdateDetails endpoint. */
export interface MsgMarketUpdateDetailsResponse {
}

/**
 * MsgMarketUpdateEnabledRequest is a request message for the MarketUpdateEnabled endpoint.
 * Deprecated: This endpoint is no longer usable. It is replaced by MarketUpdateAcceptingOrders.
 *
 * @deprecated
 */
export interface MsgMarketUpdateEnabledRequest {
  /**
   * admin is the account with "update" permission requesting this change.
   * Deprecated: This endpoint is no longer usable. It is replaced by MarketUpdateAcceptingOrders.
   *
   * @deprecated
   */
  admin: string;
  /**
   * market_id is the numerical identifier of the market to enable or disable.
   * Deprecated: This endpoint is no longer usable. It is replaced by MarketUpdateAcceptingOrders.
   *
   * @deprecated
   */
  marketId: number;
  /**
   * accepting_orders is whether this market is allowing orders to be created for it.
   * Deprecated: This endpoint is no longer usable. It is replaced by MarketUpdateAcceptingOrders.
   *
   * @deprecated
   */
  acceptingOrders: boolean;
}

/**
 * MsgMarketUpdateEnabledResponse is a response message for the MarketUpdateEnabled endpoint.
 * Deprecated: This endpoint is no longer usable. It is replaced by MarketUpdateAcceptingOrders.
 *
 * @deprecated
 */
export interface MsgMarketUpdateEnabledResponse {
}

/** MsgMarketUpdateAcceptingOrdersRequest is a request message for the MarketUpdateAcceptingOrders endpoint. */
export interface MsgMarketUpdateAcceptingOrdersRequest {
  /** admin is the account with "update" permission requesting this change. */
  admin: string;
  /** market_id is the numerical identifier of the market to enable or disable. */
  marketId: number;
  /** accepting_orders is whether this market is allowing orders to be created for it. */
  acceptingOrders: boolean;
}

/** MsgMarketUpdateAcceptingOrdersResponse is a response message for the MarketUpdateAcceptingOrders endpoint. */
export interface MsgMarketUpdateAcceptingOrdersResponse {
}

/** MsgMarketUpdateUserSettleRequest is a request message for the MarketUpdateUserSettle endpoint. */
export interface MsgMarketUpdateUserSettleRequest {
  /** admin is the account with "update" permission requesting this change. */
  admin: string;
  /** market_id is the numerical identifier of the market to enable or disable user-settlement for. */
  marketId: number;
  /**
   * allow_user_settlement is whether this market allows users to initiate their own settlements.
   * For example, the FillBids and FillAsks endpoints are available if and only if this is true.
   * The MarketSettle endpoint is available (only to market actors) regardless of the value of this field.
   */
  allowUserSettlement: boolean;
}

/** MsgMarketUpdateUserSettleResponse is a response message for the MarketUpdateUserSettle endpoint. */
export interface MsgMarketUpdateUserSettleResponse {
}

/** MsgMarketUpdateAcceptingCommitmentsRequest is a request message for the MarketUpdateAcceptingCommitments endpoint. */
export interface MsgMarketUpdateAcceptingCommitmentsRequest {
  /** admin is the account with "update" permission requesting this change. */
  admin: string;
  /** market_id is the numerical identifier of the market to enable or disable commitments for. */
  marketId: number;
  /**
   * accepting_commitments is whether this market allows users to commit funds to it.
   * For example, the CommitFunds endpoint is available if and only if this is true.
   * The MarketCommitmentSettle endpoint is available (only to market actors) regardless of the value of this field.
   */
  acceptingCommitments: boolean;
}

/** MsgMarketUpdateAcceptingCommitmentsResponse is a response message for the MarketUpdateAcceptingCommitments endpoint. */
export interface MsgMarketUpdateAcceptingCommitmentsResponse {
}

/** MsgMarketUpdateIntermediaryDenomRequest is a request message for the MarketUpdateIntermediaryDenom endpoint. */
export interface MsgMarketUpdateIntermediaryDenomRequest {
  /** admin is the account with "update" permission requesting this change. */
  admin: string;
  /** market_id is the numerical identifier of the market changing the intermediary denom. */
  marketId: number;
  /** intermediary_denom is the new intermediary denom for this market to use. */
  intermediaryDenom: string;
}

/** MsgMarketUpdateIntermediaryDenomResponse is a response message for the MarketUpdateIntermediaryDenom endpoint. */
export interface MsgMarketUpdateIntermediaryDenomResponse {
}

/** MsgMarketManagePermissionsRequest is a request message for the MarketManagePermissions endpoint. */
export interface MsgMarketManagePermissionsRequest {
  /** admin is the account with "permissions" permission requesting this change. */
  admin: string;
  /** market_id is the numerical identifier of the market to manage permissions for. */
  marketId: number;
  /** revoke_all are addresses that should have all their permissions revoked. */
  revokeAll: string[];
  /** to_revoke are the specific permissions to remove for addresses. */
  toRevoke: AccessGrant[];
  /** to_grant are the permissions to grant to addresses. */
  toGrant: AccessGrant[];
}

/** MsgMarketManagePermissionsResponse is a response message for the MarketManagePermissions endpoint. */
export interface MsgMarketManagePermissionsResponse {
}

/** MsgMarketManageReqAttrsRequest is a request message for the MarketManageReqAttrs endpoint. */
export interface MsgMarketManageReqAttrsRequest {
  /** admin is the account with "attributes" permission requesting this change. */
  admin: string;
  /** market_id is the numerical identifier of the market to update required attributes for. */
  marketId: number;
  /** create_ask_to_add are the attributes that should now also be required to create an ask order. */
  createAskToAdd: string[];
  /** create_ask_to_remove are the attributes that should no longer be required to create an ask order. */
  createAskToRemove: string[];
  /** create_bid_to_add are the attributes that should now also be required to create a bid order. */
  createBidToAdd: string[];
  /** create_bid_to_remove are the attributes that should no longer be required to create a bid order. */
  createBidToRemove: string[];
  /** create_commitment_to_add are the attributes that should now also be required to create a commitment. */
  createCommitmentToAdd: string[];
  /** create_commitment_to_remove are the attributes that should no longer be required to create a commitment. */
  createCommitmentToRemove: string[];
}

/** MsgMarketManageReqAttrsResponse is a response message for the MarketManageReqAttrs endpoint. */
export interface MsgMarketManageReqAttrsResponse {
}

/** MsgCreatePaymentRequest is a request message for the CreatePayment endpoint. */
export interface MsgCreatePaymentRequest {
  /** payment is the details of the payment to create. */
  payment?: Payment | undefined;
}

/** MsgCreatePaymentResponse is a response message for the CreatePayment endpoint. */
export interface MsgCreatePaymentResponse {
}

/** MsgAcceptPaymentRequest is a request message for the AcceptPayment endpoint. */
export interface MsgAcceptPaymentRequest {
  /** payment is the details of the payment to accept. */
  payment?: Payment | undefined;
}

/** MsgAcceptPaymentResponse is a response message for the AcceptPayment endpoint. */
export interface MsgAcceptPaymentResponse {
}

/** MsgRejectPaymentRequest is a request message for the RejectPayment endpoint. */
export interface MsgRejectPaymentRequest {
  /** target is the target account of the payment to reject. */
  target: string;
  /** source is the source account of the payment to reject. */
  source: string;
  /** external_id is the external id of the payment to reject. */
  externalId: string;
}

/** MsgRejectPaymentResponse is a response message for the RejectPayment endpoint. */
export interface MsgRejectPaymentResponse {
}

/** MsgRejectPaymentsRequest is a request message for the RejectPayments endpoint. */
export interface MsgRejectPaymentsRequest {
  /** target is the account that wishes to reject some payments. */
  target: string;
  /** sources is the source accounts of the payments to reject. */
  sources: string[];
}

/** MsgRejectPaymentsResponse is a response message for the RejectPayments endpoint. */
export interface MsgRejectPaymentsResponse {
}

/** MsgCancelPaymentsRequest is a request message for the CancelPayments endpoint. */
export interface MsgCancelPaymentsRequest {
  /** source is the account that wishes to cancel some of their payments. */
  source: string;
  /** external_ids is all of the external ids of the payments to cancel. */
  externalIds: string[];
}

/** MsgCancelPaymentsResponse is a response message for the CancelPayments endpoint. */
export interface MsgCancelPaymentsResponse {
}

/** MsgChangePaymentTargetRequest is a request message for the ChangePaymentTarget endpoint. */
export interface MsgChangePaymentTargetRequest {
  /** source is the account that wishes to update the target of one of their payments. */
  source: string;
  /** external_id is the external id of the payment to update. */
  externalId: string;
  /** new_target is the new target account of the payment. */
  newTarget: string;
}

/** MsgChangePaymentTargetResponse is a response message for the ChangePaymentTarget endpoint. */
export interface MsgChangePaymentTargetResponse {
}

/** MsgGovCreateMarketRequest is a request message for the GovCreateMarket endpoint. */
export interface MsgGovCreateMarketRequest {
  /** authority should be the governance module account address. */
  authority: string;
  /**
   * market is the initial market configuration.
   * If the market_id is 0, the next available market_id will be used (once voting ends).
   * If it is not zero, it must not yet be in use when the voting period ends.
   */
  market?: Market | undefined;
}

/** MsgGovCreateMarketResponse is a response message for the GovCreateMarket endpoint. */
export interface MsgGovCreateMarketResponse {
}

/** MsgGovManageFeesRequest is a request message for the GovManageFees endpoint. */
export interface MsgGovManageFeesRequest {
  /** authority should be the governance module account address. */
  authority: string;
  /** market_id is the market id that will get these fee updates. */
  marketId: number;
  /** add_fee_create_ask_flat are the create-ask flat fee options to add. */
  addFeeCreateAskFlat: Coin[];
  /** remove_fee_create_ask_flat are the create-ask flat fee options to remove. */
  removeFeeCreateAskFlat: Coin[];
  /** add_fee_create_bid_flat are the create-bid flat fee options to add. */
  addFeeCreateBidFlat: Coin[];
  /** remove_fee_create_bid_flat are the create-bid flat fee options to remove. */
  removeFeeCreateBidFlat: Coin[];
  /** add_fee_seller_settlement_flat are the seller settlement flat fee options to add. */
  addFeeSellerSettlementFlat: Coin[];
  /** remove_fee_seller_settlement_flat are the seller settlement flat fee options to remove. */
  removeFeeSellerSettlementFlat: Coin[];
  /** add_fee_seller_settlement_ratios are the seller settlement fee ratios to add. */
  addFeeSellerSettlementRatios: FeeRatio[];
  /** remove_fee_seller_settlement_ratios are the seller settlement fee ratios to remove. */
  removeFeeSellerSettlementRatios: FeeRatio[];
  /** add_fee_buyer_settlement_flat are the buyer settlement flat fee options to add. */
  addFeeBuyerSettlementFlat: Coin[];
  /** remove_fee_buyer_settlement_flat are the buyer settlement flat fee options to remove. */
  removeFeeBuyerSettlementFlat: Coin[];
  /** add_fee_buyer_settlement_ratios are the buyer settlement fee ratios to add. */
  addFeeBuyerSettlementRatios: FeeRatio[];
  /** remove_fee_buyer_settlement_ratios are the buyer settlement fee ratios to remove. */
  removeFeeBuyerSettlementRatios: FeeRatio[];
  /** add_fee_create_commitment_flat are the create-commitment flat fee options to add. */
  addFeeCreateCommitmentFlat: Coin[];
  /** remove_fee_create_commitment_flat are the create-commitment flat fee options to remove. */
  removeFeeCreateCommitmentFlat: Coin[];
  /**
   * set_fee_commitment_settlement_bips is the new fee_commitment_settlement_bips for the market.
   * It is ignored if it is zero. To set it to zero set unset_fee_commitment_settlement_bips to true.
   */
  setFeeCommitmentSettlementBips: number;
  /**
   * unset_fee_commitment_settlement_bips, if true, sets the fee_commitment_settlement_bips to zero.
   * If false, it is ignored.
   */
  unsetFeeCommitmentSettlementBips: boolean;
}

/** MsgGovManageFeesResponse is a response message for the GovManageFees endpoint. */
export interface MsgGovManageFeesResponse {
}

/** MsgGovCloseMarketRequest is a request message for the GovCloseMarket endpoint. */
export interface MsgGovCloseMarketRequest {
  /** authority must be the governance module account. */
  authority: string;
  /** market_id is the numerical identifier of the market to close. */
  marketId: number;
}

/** MsgGovCloseMarketResponse is a response message for the GovCloseMarket endpoint. */
export interface MsgGovCloseMarketResponse {
}

/**
 * MsgGovUpdateParamsRequest is a request message for the GovUpdateParams endpoint.
 * Deprecated: Use MsgUpdateParamsRequest instead.
 *
 * @deprecated
 */
export interface MsgGovUpdateParamsRequest {
  /** authority should be the governance module account address. */
  authority: string;
  /** params are the new param values to set */
  params?: Params | undefined;
}

/**
 * MsgGovUpdateParamsResponse is a response message for the GovUpdateParams endpoint.
 * Deprecated: Use MsgUpdateParamsResponse instead.
 *
 * @deprecated
 */
export interface MsgGovUpdateParamsResponse {
}

/** MsgGovUpdateParamsRequest is a request message for the GovUpdateParams endpoint. */
export interface MsgUpdateParamsRequest {
  /** authority should be the governance module account address. */
  authority: string;
  /** params are the new param values to set */
  params?: Params | undefined;
}

/** MsgUpdateParamsResponse is a response message for the GovUpdateParams endpoint. */
export interface MsgUpdateParamsResponse {
}

function createBaseMsgCreateAskRequest(): MsgCreateAskRequest {
  return { askOrder: undefined, orderCreationFee: undefined };
}

export const MsgCreateAskRequest: MessageFns<MsgCreateAskRequest> = {
  encode(message: MsgCreateAskRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.askOrder !== undefined) {
      AskOrder.encode(message.askOrder, writer.uint32(10).fork()).join();
    }
    if (message.orderCreationFee !== undefined) {
      Coin.encode(message.orderCreationFee, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateAskRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateAskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.askOrder = AskOrder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderCreationFee = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateAskRequest {
    return {
      askOrder: isSet(object.askOrder) ? AskOrder.fromJSON(object.askOrder) : undefined,
      orderCreationFee: isSet(object.orderCreationFee) ? Coin.fromJSON(object.orderCreationFee) : undefined,
    };
  },

  toJSON(message: MsgCreateAskRequest): unknown {
    const obj: any = {};
    if (message.askOrder !== undefined) {
      obj.askOrder = AskOrder.toJSON(message.askOrder);
    }
    if (message.orderCreationFee !== undefined) {
      obj.orderCreationFee = Coin.toJSON(message.orderCreationFee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateAskRequest>, I>>(base?: I): MsgCreateAskRequest {
    return MsgCreateAskRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateAskRequest>, I>>(object: I): MsgCreateAskRequest {
    const message = createBaseMsgCreateAskRequest();
    message.askOrder = (object.askOrder !== undefined && object.askOrder !== null)
      ? AskOrder.fromPartial(object.askOrder)
      : undefined;
    message.orderCreationFee = (object.orderCreationFee !== undefined && object.orderCreationFee !== null)
      ? Coin.fromPartial(object.orderCreationFee)
      : undefined;
    return message;
  },
};

function createBaseMsgCreateAskResponse(): MsgCreateAskResponse {
  return { orderId: Long.UZERO };
}

export const MsgCreateAskResponse: MessageFns<MsgCreateAskResponse> = {
  encode(message: MsgCreateAskResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.orderId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.orderId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateAskResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateAskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.orderId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateAskResponse {
    return { orderId: isSet(object.orderId) ? Long.fromValue(object.orderId) : Long.UZERO };
  },

  toJSON(message: MsgCreateAskResponse): unknown {
    const obj: any = {};
    if (!message.orderId.equals(Long.UZERO)) {
      obj.orderId = (message.orderId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateAskResponse>, I>>(base?: I): MsgCreateAskResponse {
    return MsgCreateAskResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateAskResponse>, I>>(object: I): MsgCreateAskResponse {
    const message = createBaseMsgCreateAskResponse();
    message.orderId = (object.orderId !== undefined && object.orderId !== null)
      ? Long.fromValue(object.orderId)
      : Long.UZERO;
    return message;
  },
};

function createBaseMsgCreateBidRequest(): MsgCreateBidRequest {
  return { bidOrder: undefined, orderCreationFee: undefined };
}

export const MsgCreateBidRequest: MessageFns<MsgCreateBidRequest> = {
  encode(message: MsgCreateBidRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bidOrder !== undefined) {
      BidOrder.encode(message.bidOrder, writer.uint32(10).fork()).join();
    }
    if (message.orderCreationFee !== undefined) {
      Coin.encode(message.orderCreationFee, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateBidRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateBidRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bidOrder = BidOrder.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderCreationFee = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateBidRequest {
    return {
      bidOrder: isSet(object.bidOrder) ? BidOrder.fromJSON(object.bidOrder) : undefined,
      orderCreationFee: isSet(object.orderCreationFee) ? Coin.fromJSON(object.orderCreationFee) : undefined,
    };
  },

  toJSON(message: MsgCreateBidRequest): unknown {
    const obj: any = {};
    if (message.bidOrder !== undefined) {
      obj.bidOrder = BidOrder.toJSON(message.bidOrder);
    }
    if (message.orderCreationFee !== undefined) {
      obj.orderCreationFee = Coin.toJSON(message.orderCreationFee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateBidRequest>, I>>(base?: I): MsgCreateBidRequest {
    return MsgCreateBidRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateBidRequest>, I>>(object: I): MsgCreateBidRequest {
    const message = createBaseMsgCreateBidRequest();
    message.bidOrder = (object.bidOrder !== undefined && object.bidOrder !== null)
      ? BidOrder.fromPartial(object.bidOrder)
      : undefined;
    message.orderCreationFee = (object.orderCreationFee !== undefined && object.orderCreationFee !== null)
      ? Coin.fromPartial(object.orderCreationFee)
      : undefined;
    return message;
  },
};

function createBaseMsgCreateBidResponse(): MsgCreateBidResponse {
  return { orderId: Long.UZERO };
}

export const MsgCreateBidResponse: MessageFns<MsgCreateBidResponse> = {
  encode(message: MsgCreateBidResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.orderId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.orderId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateBidResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateBidResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.orderId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateBidResponse {
    return { orderId: isSet(object.orderId) ? Long.fromValue(object.orderId) : Long.UZERO };
  },

  toJSON(message: MsgCreateBidResponse): unknown {
    const obj: any = {};
    if (!message.orderId.equals(Long.UZERO)) {
      obj.orderId = (message.orderId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateBidResponse>, I>>(base?: I): MsgCreateBidResponse {
    return MsgCreateBidResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateBidResponse>, I>>(object: I): MsgCreateBidResponse {
    const message = createBaseMsgCreateBidResponse();
    message.orderId = (object.orderId !== undefined && object.orderId !== null)
      ? Long.fromValue(object.orderId)
      : Long.UZERO;
    return message;
  },
};

function createBaseMsgCommitFundsRequest(): MsgCommitFundsRequest {
  return { account: "", marketId: 0, amount: [], creationFee: undefined, eventTag: "" };
}

export const MsgCommitFundsRequest: MessageFns<MsgCommitFundsRequest> = {
  encode(message: MsgCommitFundsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    for (const v of message.amount) {
      Coin.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.creationFee !== undefined) {
      Coin.encode(message.creationFee, writer.uint32(34).fork()).join();
    }
    if (message.eventTag !== "") {
      writer.uint32(42).string(message.eventTag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCommitFundsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCommitFundsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.creationFee = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.eventTag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCommitFundsRequest {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      amount: globalThis.Array.isArray(object?.amount) ? object.amount.map((e: any) => Coin.fromJSON(e)) : [],
      creationFee: isSet(object.creationFee) ? Coin.fromJSON(object.creationFee) : undefined,
      eventTag: isSet(object.eventTag) ? globalThis.String(object.eventTag) : "",
    };
  },

  toJSON(message: MsgCommitFundsRequest): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.amount?.length) {
      obj.amount = message.amount.map((e) => Coin.toJSON(e));
    }
    if (message.creationFee !== undefined) {
      obj.creationFee = Coin.toJSON(message.creationFee);
    }
    if (message.eventTag !== "") {
      obj.eventTag = message.eventTag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCommitFundsRequest>, I>>(base?: I): MsgCommitFundsRequest {
    return MsgCommitFundsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCommitFundsRequest>, I>>(object: I): MsgCommitFundsRequest {
    const message = createBaseMsgCommitFundsRequest();
    message.account = object.account ?? "";
    message.marketId = object.marketId ?? 0;
    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];
    message.creationFee = (object.creationFee !== undefined && object.creationFee !== null)
      ? Coin.fromPartial(object.creationFee)
      : undefined;
    message.eventTag = object.eventTag ?? "";
    return message;
  },
};

function createBaseMsgCommitFundsResponse(): MsgCommitFundsResponse {
  return {};
}

export const MsgCommitFundsResponse: MessageFns<MsgCommitFundsResponse> = {
  encode(_: MsgCommitFundsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCommitFundsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCommitFundsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCommitFundsResponse {
    return {};
  },

  toJSON(_: MsgCommitFundsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCommitFundsResponse>, I>>(base?: I): MsgCommitFundsResponse {
    return MsgCommitFundsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCommitFundsResponse>, I>>(_: I): MsgCommitFundsResponse {
    const message = createBaseMsgCommitFundsResponse();
    return message;
  },
};

function createBaseMsgCancelOrderRequest(): MsgCancelOrderRequest {
  return { signer: "", orderId: Long.UZERO };
}

export const MsgCancelOrderRequest: MessageFns<MsgCancelOrderRequest> = {
  encode(message: MsgCancelOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signer !== "") {
      writer.uint32(10).string(message.signer);
    }
    if (!message.orderId.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.orderId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCancelOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.orderId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCancelOrderRequest {
    return {
      signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
      orderId: isSet(object.orderId) ? Long.fromValue(object.orderId) : Long.UZERO,
    };
  },

  toJSON(message: MsgCancelOrderRequest): unknown {
    const obj: any = {};
    if (message.signer !== "") {
      obj.signer = message.signer;
    }
    if (!message.orderId.equals(Long.UZERO)) {
      obj.orderId = (message.orderId || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCancelOrderRequest>, I>>(base?: I): MsgCancelOrderRequest {
    return MsgCancelOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCancelOrderRequest>, I>>(object: I): MsgCancelOrderRequest {
    const message = createBaseMsgCancelOrderRequest();
    message.signer = object.signer ?? "";
    message.orderId = (object.orderId !== undefined && object.orderId !== null)
      ? Long.fromValue(object.orderId)
      : Long.UZERO;
    return message;
  },
};

function createBaseMsgCancelOrderResponse(): MsgCancelOrderResponse {
  return {};
}

export const MsgCancelOrderResponse: MessageFns<MsgCancelOrderResponse> = {
  encode(_: MsgCancelOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCancelOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCancelOrderResponse {
    return {};
  },

  toJSON(_: MsgCancelOrderResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCancelOrderResponse>, I>>(base?: I): MsgCancelOrderResponse {
    return MsgCancelOrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCancelOrderResponse>, I>>(_: I): MsgCancelOrderResponse {
    const message = createBaseMsgCancelOrderResponse();
    return message;
  },
};

function createBaseMsgFillBidsRequest(): MsgFillBidsRequest {
  return {
    seller: "",
    marketId: 0,
    totalAssets: [],
    bidOrderIds: [],
    sellerSettlementFlatFee: undefined,
    askOrderCreationFee: undefined,
  };
}

export const MsgFillBidsRequest: MessageFns<MsgFillBidsRequest> = {
  encode(message: MsgFillBidsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.seller !== "") {
      writer.uint32(10).string(message.seller);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    for (const v of message.totalAssets) {
      Coin.encode(v!, writer.uint32(26).fork()).join();
    }
    writer.uint32(34).fork();
    for (const v of message.bidOrderIds) {
      writer.uint64(v.toString());
    }
    writer.join();
    if (message.sellerSettlementFlatFee !== undefined) {
      Coin.encode(message.sellerSettlementFlatFee, writer.uint32(42).fork()).join();
    }
    if (message.askOrderCreationFee !== undefined) {
      Coin.encode(message.askOrderCreationFee, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFillBidsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFillBidsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.seller = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.totalAssets.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.bidOrderIds.push(Long.fromString(reader.uint64().toString(), true));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.bidOrderIds.push(Long.fromString(reader.uint64().toString(), true));
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sellerSettlementFlatFee = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.askOrderCreationFee = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgFillBidsRequest {
    return {
      seller: isSet(object.seller) ? globalThis.String(object.seller) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      totalAssets: globalThis.Array.isArray(object?.totalAssets)
        ? object.totalAssets.map((e: any) => Coin.fromJSON(e))
        : [],
      bidOrderIds: globalThis.Array.isArray(object?.bidOrderIds)
        ? object.bidOrderIds.map((e: any) => Long.fromValue(e))
        : [],
      sellerSettlementFlatFee: isSet(object.sellerSettlementFlatFee)
        ? Coin.fromJSON(object.sellerSettlementFlatFee)
        : undefined,
      askOrderCreationFee: isSet(object.askOrderCreationFee) ? Coin.fromJSON(object.askOrderCreationFee) : undefined,
    };
  },

  toJSON(message: MsgFillBidsRequest): unknown {
    const obj: any = {};
    if (message.seller !== "") {
      obj.seller = message.seller;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.totalAssets?.length) {
      obj.totalAssets = message.totalAssets.map((e) => Coin.toJSON(e));
    }
    if (message.bidOrderIds?.length) {
      obj.bidOrderIds = message.bidOrderIds.map((e) => (e || Long.UZERO).toString());
    }
    if (message.sellerSettlementFlatFee !== undefined) {
      obj.sellerSettlementFlatFee = Coin.toJSON(message.sellerSettlementFlatFee);
    }
    if (message.askOrderCreationFee !== undefined) {
      obj.askOrderCreationFee = Coin.toJSON(message.askOrderCreationFee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFillBidsRequest>, I>>(base?: I): MsgFillBidsRequest {
    return MsgFillBidsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFillBidsRequest>, I>>(object: I): MsgFillBidsRequest {
    const message = createBaseMsgFillBidsRequest();
    message.seller = object.seller ?? "";
    message.marketId = object.marketId ?? 0;
    message.totalAssets = object.totalAssets?.map((e) => Coin.fromPartial(e)) || [];
    message.bidOrderIds = object.bidOrderIds?.map((e) => Long.fromValue(e)) || [];
    message.sellerSettlementFlatFee =
      (object.sellerSettlementFlatFee !== undefined && object.sellerSettlementFlatFee !== null)
        ? Coin.fromPartial(object.sellerSettlementFlatFee)
        : undefined;
    message.askOrderCreationFee = (object.askOrderCreationFee !== undefined && object.askOrderCreationFee !== null)
      ? Coin.fromPartial(object.askOrderCreationFee)
      : undefined;
    return message;
  },
};

function createBaseMsgFillBidsResponse(): MsgFillBidsResponse {
  return {};
}

export const MsgFillBidsResponse: MessageFns<MsgFillBidsResponse> = {
  encode(_: MsgFillBidsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFillBidsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFillBidsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgFillBidsResponse {
    return {};
  },

  toJSON(_: MsgFillBidsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFillBidsResponse>, I>>(base?: I): MsgFillBidsResponse {
    return MsgFillBidsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFillBidsResponse>, I>>(_: I): MsgFillBidsResponse {
    const message = createBaseMsgFillBidsResponse();
    return message;
  },
};

function createBaseMsgFillAsksRequest(): MsgFillAsksRequest {
  return {
    buyer: "",
    marketId: 0,
    totalPrice: undefined,
    askOrderIds: [],
    buyerSettlementFees: [],
    bidOrderCreationFee: undefined,
  };
}

export const MsgFillAsksRequest: MessageFns<MsgFillAsksRequest> = {
  encode(message: MsgFillAsksRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.buyer !== "") {
      writer.uint32(10).string(message.buyer);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    if (message.totalPrice !== undefined) {
      Coin.encode(message.totalPrice, writer.uint32(26).fork()).join();
    }
    writer.uint32(34).fork();
    for (const v of message.askOrderIds) {
      writer.uint64(v.toString());
    }
    writer.join();
    for (const v of message.buyerSettlementFees) {
      Coin.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.bidOrderCreationFee !== undefined) {
      Coin.encode(message.bidOrderCreationFee, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFillAsksRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFillAsksRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.buyer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.totalPrice = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.askOrderIds.push(Long.fromString(reader.uint64().toString(), true));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.askOrderIds.push(Long.fromString(reader.uint64().toString(), true));
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.buyerSettlementFees.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.bidOrderCreationFee = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgFillAsksRequest {
    return {
      buyer: isSet(object.buyer) ? globalThis.String(object.buyer) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      totalPrice: isSet(object.totalPrice) ? Coin.fromJSON(object.totalPrice) : undefined,
      askOrderIds: globalThis.Array.isArray(object?.askOrderIds)
        ? object.askOrderIds.map((e: any) => Long.fromValue(e))
        : [],
      buyerSettlementFees: globalThis.Array.isArray(object?.buyerSettlementFees)
        ? object.buyerSettlementFees.map((e: any) => Coin.fromJSON(e))
        : [],
      bidOrderCreationFee: isSet(object.bidOrderCreationFee) ? Coin.fromJSON(object.bidOrderCreationFee) : undefined,
    };
  },

  toJSON(message: MsgFillAsksRequest): unknown {
    const obj: any = {};
    if (message.buyer !== "") {
      obj.buyer = message.buyer;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.totalPrice !== undefined) {
      obj.totalPrice = Coin.toJSON(message.totalPrice);
    }
    if (message.askOrderIds?.length) {
      obj.askOrderIds = message.askOrderIds.map((e) => (e || Long.UZERO).toString());
    }
    if (message.buyerSettlementFees?.length) {
      obj.buyerSettlementFees = message.buyerSettlementFees.map((e) => Coin.toJSON(e));
    }
    if (message.bidOrderCreationFee !== undefined) {
      obj.bidOrderCreationFee = Coin.toJSON(message.bidOrderCreationFee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFillAsksRequest>, I>>(base?: I): MsgFillAsksRequest {
    return MsgFillAsksRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFillAsksRequest>, I>>(object: I): MsgFillAsksRequest {
    const message = createBaseMsgFillAsksRequest();
    message.buyer = object.buyer ?? "";
    message.marketId = object.marketId ?? 0;
    message.totalPrice = (object.totalPrice !== undefined && object.totalPrice !== null)
      ? Coin.fromPartial(object.totalPrice)
      : undefined;
    message.askOrderIds = object.askOrderIds?.map((e) => Long.fromValue(e)) || [];
    message.buyerSettlementFees = object.buyerSettlementFees?.map((e) => Coin.fromPartial(e)) || [];
    message.bidOrderCreationFee = (object.bidOrderCreationFee !== undefined && object.bidOrderCreationFee !== null)
      ? Coin.fromPartial(object.bidOrderCreationFee)
      : undefined;
    return message;
  },
};

function createBaseMsgFillAsksResponse(): MsgFillAsksResponse {
  return {};
}

export const MsgFillAsksResponse: MessageFns<MsgFillAsksResponse> = {
  encode(_: MsgFillAsksResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFillAsksResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFillAsksResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgFillAsksResponse {
    return {};
  },

  toJSON(_: MsgFillAsksResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFillAsksResponse>, I>>(base?: I): MsgFillAsksResponse {
    return MsgFillAsksResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFillAsksResponse>, I>>(_: I): MsgFillAsksResponse {
    const message = createBaseMsgFillAsksResponse();
    return message;
  },
};

function createBaseMsgMarketSettleRequest(): MsgMarketSettleRequest {
  return { admin: "", marketId: 0, askOrderIds: [], bidOrderIds: [], expectPartial: false };
}

export const MsgMarketSettleRequest: MessageFns<MsgMarketSettleRequest> = {
  encode(message: MsgMarketSettleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.admin !== "") {
      writer.uint32(10).string(message.admin);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    writer.uint32(26).fork();
    for (const v of message.askOrderIds) {
      writer.uint64(v.toString());
    }
    writer.join();
    writer.uint32(34).fork();
    for (const v of message.bidOrderIds) {
      writer.uint64(v.toString());
    }
    writer.join();
    if (message.expectPartial !== false) {
      writer.uint32(40).bool(message.expectPartial);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketSettleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketSettleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.admin = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.askOrderIds.push(Long.fromString(reader.uint64().toString(), true));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.askOrderIds.push(Long.fromString(reader.uint64().toString(), true));
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag === 32) {
            message.bidOrderIds.push(Long.fromString(reader.uint64().toString(), true));

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.bidOrderIds.push(Long.fromString(reader.uint64().toString(), true));
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.expectPartial = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMarketSettleRequest {
    return {
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      askOrderIds: globalThis.Array.isArray(object?.askOrderIds)
        ? object.askOrderIds.map((e: any) => Long.fromValue(e))
        : [],
      bidOrderIds: globalThis.Array.isArray(object?.bidOrderIds)
        ? object.bidOrderIds.map((e: any) => Long.fromValue(e))
        : [],
      expectPartial: isSet(object.expectPartial) ? globalThis.Boolean(object.expectPartial) : false,
    };
  },

  toJSON(message: MsgMarketSettleRequest): unknown {
    const obj: any = {};
    if (message.admin !== "") {
      obj.admin = message.admin;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.askOrderIds?.length) {
      obj.askOrderIds = message.askOrderIds.map((e) => (e || Long.UZERO).toString());
    }
    if (message.bidOrderIds?.length) {
      obj.bidOrderIds = message.bidOrderIds.map((e) => (e || Long.UZERO).toString());
    }
    if (message.expectPartial !== false) {
      obj.expectPartial = message.expectPartial;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketSettleRequest>, I>>(base?: I): MsgMarketSettleRequest {
    return MsgMarketSettleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketSettleRequest>, I>>(object: I): MsgMarketSettleRequest {
    const message = createBaseMsgMarketSettleRequest();
    message.admin = object.admin ?? "";
    message.marketId = object.marketId ?? 0;
    message.askOrderIds = object.askOrderIds?.map((e) => Long.fromValue(e)) || [];
    message.bidOrderIds = object.bidOrderIds?.map((e) => Long.fromValue(e)) || [];
    message.expectPartial = object.expectPartial ?? false;
    return message;
  },
};

function createBaseMsgMarketSettleResponse(): MsgMarketSettleResponse {
  return {};
}

export const MsgMarketSettleResponse: MessageFns<MsgMarketSettleResponse> = {
  encode(_: MsgMarketSettleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketSettleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketSettleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgMarketSettleResponse {
    return {};
  },

  toJSON(_: MsgMarketSettleResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketSettleResponse>, I>>(base?: I): MsgMarketSettleResponse {
    return MsgMarketSettleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketSettleResponse>, I>>(_: I): MsgMarketSettleResponse {
    const message = createBaseMsgMarketSettleResponse();
    return message;
  },
};

function createBaseMsgMarketCommitmentSettleRequest(): MsgMarketCommitmentSettleRequest {
  return { admin: "", marketId: 0, inputs: [], outputs: [], fees: [], navs: [], eventTag: "" };
}

export const MsgMarketCommitmentSettleRequest: MessageFns<MsgMarketCommitmentSettleRequest> = {
  encode(message: MsgMarketCommitmentSettleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.admin !== "") {
      writer.uint32(10).string(message.admin);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    for (const v of message.inputs) {
      AccountAmount.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.outputs) {
      AccountAmount.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.fees) {
      AccountAmount.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.navs) {
      NetAssetPrice.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.eventTag !== "") {
      writer.uint32(58).string(message.eventTag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketCommitmentSettleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketCommitmentSettleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.admin = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputs.push(AccountAmount.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.outputs.push(AccountAmount.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fees.push(AccountAmount.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.navs.push(NetAssetPrice.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.eventTag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMarketCommitmentSettleRequest {
    return {
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => AccountAmount.fromJSON(e)) : [],
      outputs: globalThis.Array.isArray(object?.outputs)
        ? object.outputs.map((e: any) => AccountAmount.fromJSON(e))
        : [],
      fees: globalThis.Array.isArray(object?.fees) ? object.fees.map((e: any) => AccountAmount.fromJSON(e)) : [],
      navs: globalThis.Array.isArray(object?.navs) ? object.navs.map((e: any) => NetAssetPrice.fromJSON(e)) : [],
      eventTag: isSet(object.eventTag) ? globalThis.String(object.eventTag) : "",
    };
  },

  toJSON(message: MsgMarketCommitmentSettleRequest): unknown {
    const obj: any = {};
    if (message.admin !== "") {
      obj.admin = message.admin;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => AccountAmount.toJSON(e));
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => AccountAmount.toJSON(e));
    }
    if (message.fees?.length) {
      obj.fees = message.fees.map((e) => AccountAmount.toJSON(e));
    }
    if (message.navs?.length) {
      obj.navs = message.navs.map((e) => NetAssetPrice.toJSON(e));
    }
    if (message.eventTag !== "") {
      obj.eventTag = message.eventTag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketCommitmentSettleRequest>, I>>(
    base?: I,
  ): MsgMarketCommitmentSettleRequest {
    return MsgMarketCommitmentSettleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketCommitmentSettleRequest>, I>>(
    object: I,
  ): MsgMarketCommitmentSettleRequest {
    const message = createBaseMsgMarketCommitmentSettleRequest();
    message.admin = object.admin ?? "";
    message.marketId = object.marketId ?? 0;
    message.inputs = object.inputs?.map((e) => AccountAmount.fromPartial(e)) || [];
    message.outputs = object.outputs?.map((e) => AccountAmount.fromPartial(e)) || [];
    message.fees = object.fees?.map((e) => AccountAmount.fromPartial(e)) || [];
    message.navs = object.navs?.map((e) => NetAssetPrice.fromPartial(e)) || [];
    message.eventTag = object.eventTag ?? "";
    return message;
  },
};

function createBaseMsgMarketCommitmentSettleResponse(): MsgMarketCommitmentSettleResponse {
  return {};
}

export const MsgMarketCommitmentSettleResponse: MessageFns<MsgMarketCommitmentSettleResponse> = {
  encode(_: MsgMarketCommitmentSettleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketCommitmentSettleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketCommitmentSettleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgMarketCommitmentSettleResponse {
    return {};
  },

  toJSON(_: MsgMarketCommitmentSettleResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketCommitmentSettleResponse>, I>>(
    base?: I,
  ): MsgMarketCommitmentSettleResponse {
    return MsgMarketCommitmentSettleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketCommitmentSettleResponse>, I>>(
    _: I,
  ): MsgMarketCommitmentSettleResponse {
    const message = createBaseMsgMarketCommitmentSettleResponse();
    return message;
  },
};

function createBaseMsgMarketReleaseCommitmentsRequest(): MsgMarketReleaseCommitmentsRequest {
  return { admin: "", marketId: 0, toRelease: [], eventTag: "" };
}

export const MsgMarketReleaseCommitmentsRequest: MessageFns<MsgMarketReleaseCommitmentsRequest> = {
  encode(message: MsgMarketReleaseCommitmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.admin !== "") {
      writer.uint32(10).string(message.admin);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    for (const v of message.toRelease) {
      AccountAmount.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.eventTag !== "") {
      writer.uint32(34).string(message.eventTag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketReleaseCommitmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketReleaseCommitmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.admin = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toRelease.push(AccountAmount.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.eventTag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMarketReleaseCommitmentsRequest {
    return {
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      toRelease: globalThis.Array.isArray(object?.toRelease)
        ? object.toRelease.map((e: any) => AccountAmount.fromJSON(e))
        : [],
      eventTag: isSet(object.eventTag) ? globalThis.String(object.eventTag) : "",
    };
  },

  toJSON(message: MsgMarketReleaseCommitmentsRequest): unknown {
    const obj: any = {};
    if (message.admin !== "") {
      obj.admin = message.admin;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.toRelease?.length) {
      obj.toRelease = message.toRelease.map((e) => AccountAmount.toJSON(e));
    }
    if (message.eventTag !== "") {
      obj.eventTag = message.eventTag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketReleaseCommitmentsRequest>, I>>(
    base?: I,
  ): MsgMarketReleaseCommitmentsRequest {
    return MsgMarketReleaseCommitmentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketReleaseCommitmentsRequest>, I>>(
    object: I,
  ): MsgMarketReleaseCommitmentsRequest {
    const message = createBaseMsgMarketReleaseCommitmentsRequest();
    message.admin = object.admin ?? "";
    message.marketId = object.marketId ?? 0;
    message.toRelease = object.toRelease?.map((e) => AccountAmount.fromPartial(e)) || [];
    message.eventTag = object.eventTag ?? "";
    return message;
  },
};

function createBaseMsgMarketReleaseCommitmentsResponse(): MsgMarketReleaseCommitmentsResponse {
  return {};
}

export const MsgMarketReleaseCommitmentsResponse: MessageFns<MsgMarketReleaseCommitmentsResponse> = {
  encode(_: MsgMarketReleaseCommitmentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketReleaseCommitmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketReleaseCommitmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgMarketReleaseCommitmentsResponse {
    return {};
  },

  toJSON(_: MsgMarketReleaseCommitmentsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketReleaseCommitmentsResponse>, I>>(
    base?: I,
  ): MsgMarketReleaseCommitmentsResponse {
    return MsgMarketReleaseCommitmentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketReleaseCommitmentsResponse>, I>>(
    _: I,
  ): MsgMarketReleaseCommitmentsResponse {
    const message = createBaseMsgMarketReleaseCommitmentsResponse();
    return message;
  },
};

function createBaseMsgMarketSetOrderExternalIDRequest(): MsgMarketSetOrderExternalIDRequest {
  return { admin: "", marketId: 0, orderId: Long.UZERO, externalId: "" };
}

export const MsgMarketSetOrderExternalIDRequest: MessageFns<MsgMarketSetOrderExternalIDRequest> = {
  encode(message: MsgMarketSetOrderExternalIDRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.admin !== "") {
      writer.uint32(10).string(message.admin);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    if (!message.orderId.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.orderId.toString());
    }
    if (message.externalId !== "") {
      writer.uint32(34).string(message.externalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketSetOrderExternalIDRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketSetOrderExternalIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.admin = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.orderId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMarketSetOrderExternalIDRequest {
    return {
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      orderId: isSet(object.orderId) ? Long.fromValue(object.orderId) : Long.UZERO,
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
    };
  },

  toJSON(message: MsgMarketSetOrderExternalIDRequest): unknown {
    const obj: any = {};
    if (message.admin !== "") {
      obj.admin = message.admin;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (!message.orderId.equals(Long.UZERO)) {
      obj.orderId = (message.orderId || Long.UZERO).toString();
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketSetOrderExternalIDRequest>, I>>(
    base?: I,
  ): MsgMarketSetOrderExternalIDRequest {
    return MsgMarketSetOrderExternalIDRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketSetOrderExternalIDRequest>, I>>(
    object: I,
  ): MsgMarketSetOrderExternalIDRequest {
    const message = createBaseMsgMarketSetOrderExternalIDRequest();
    message.admin = object.admin ?? "";
    message.marketId = object.marketId ?? 0;
    message.orderId = (object.orderId !== undefined && object.orderId !== null)
      ? Long.fromValue(object.orderId)
      : Long.UZERO;
    message.externalId = object.externalId ?? "";
    return message;
  },
};

function createBaseMsgMarketSetOrderExternalIDResponse(): MsgMarketSetOrderExternalIDResponse {
  return {};
}

export const MsgMarketSetOrderExternalIDResponse: MessageFns<MsgMarketSetOrderExternalIDResponse> = {
  encode(_: MsgMarketSetOrderExternalIDResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketSetOrderExternalIDResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketSetOrderExternalIDResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgMarketSetOrderExternalIDResponse {
    return {};
  },

  toJSON(_: MsgMarketSetOrderExternalIDResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketSetOrderExternalIDResponse>, I>>(
    base?: I,
  ): MsgMarketSetOrderExternalIDResponse {
    return MsgMarketSetOrderExternalIDResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketSetOrderExternalIDResponse>, I>>(
    _: I,
  ): MsgMarketSetOrderExternalIDResponse {
    const message = createBaseMsgMarketSetOrderExternalIDResponse();
    return message;
  },
};

function createBaseMsgMarketWithdrawRequest(): MsgMarketWithdrawRequest {
  return { admin: "", marketId: 0, toAddress: "", amount: [] };
}

export const MsgMarketWithdrawRequest: MessageFns<MsgMarketWithdrawRequest> = {
  encode(message: MsgMarketWithdrawRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.admin !== "") {
      writer.uint32(10).string(message.admin);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    if (message.toAddress !== "") {
      writer.uint32(26).string(message.toAddress);
    }
    for (const v of message.amount) {
      Coin.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketWithdrawRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketWithdrawRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.admin = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.toAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMarketWithdrawRequest {
    return {
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      toAddress: isSet(object.toAddress) ? globalThis.String(object.toAddress) : "",
      amount: globalThis.Array.isArray(object?.amount) ? object.amount.map((e: any) => Coin.fromJSON(e)) : [],
    };
  },

  toJSON(message: MsgMarketWithdrawRequest): unknown {
    const obj: any = {};
    if (message.admin !== "") {
      obj.admin = message.admin;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.toAddress !== "") {
      obj.toAddress = message.toAddress;
    }
    if (message.amount?.length) {
      obj.amount = message.amount.map((e) => Coin.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketWithdrawRequest>, I>>(base?: I): MsgMarketWithdrawRequest {
    return MsgMarketWithdrawRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketWithdrawRequest>, I>>(object: I): MsgMarketWithdrawRequest {
    const message = createBaseMsgMarketWithdrawRequest();
    message.admin = object.admin ?? "";
    message.marketId = object.marketId ?? 0;
    message.toAddress = object.toAddress ?? "";
    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgMarketWithdrawResponse(): MsgMarketWithdrawResponse {
  return {};
}

export const MsgMarketWithdrawResponse: MessageFns<MsgMarketWithdrawResponse> = {
  encode(_: MsgMarketWithdrawResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketWithdrawResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketWithdrawResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgMarketWithdrawResponse {
    return {};
  },

  toJSON(_: MsgMarketWithdrawResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketWithdrawResponse>, I>>(base?: I): MsgMarketWithdrawResponse {
    return MsgMarketWithdrawResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketWithdrawResponse>, I>>(_: I): MsgMarketWithdrawResponse {
    const message = createBaseMsgMarketWithdrawResponse();
    return message;
  },
};

function createBaseMsgMarketUpdateDetailsRequest(): MsgMarketUpdateDetailsRequest {
  return { admin: "", marketId: 0, marketDetails: undefined };
}

export const MsgMarketUpdateDetailsRequest: MessageFns<MsgMarketUpdateDetailsRequest> = {
  encode(message: MsgMarketUpdateDetailsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.admin !== "") {
      writer.uint32(10).string(message.admin);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    if (message.marketDetails !== undefined) {
      MarketDetails.encode(message.marketDetails, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketUpdateDetailsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketUpdateDetailsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.admin = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.marketDetails = MarketDetails.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMarketUpdateDetailsRequest {
    return {
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      marketDetails: isSet(object.marketDetails) ? MarketDetails.fromJSON(object.marketDetails) : undefined,
    };
  },

  toJSON(message: MsgMarketUpdateDetailsRequest): unknown {
    const obj: any = {};
    if (message.admin !== "") {
      obj.admin = message.admin;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.marketDetails !== undefined) {
      obj.marketDetails = MarketDetails.toJSON(message.marketDetails);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketUpdateDetailsRequest>, I>>(base?: I): MsgMarketUpdateDetailsRequest {
    return MsgMarketUpdateDetailsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketUpdateDetailsRequest>, I>>(
    object: I,
  ): MsgMarketUpdateDetailsRequest {
    const message = createBaseMsgMarketUpdateDetailsRequest();
    message.admin = object.admin ?? "";
    message.marketId = object.marketId ?? 0;
    message.marketDetails = (object.marketDetails !== undefined && object.marketDetails !== null)
      ? MarketDetails.fromPartial(object.marketDetails)
      : undefined;
    return message;
  },
};

function createBaseMsgMarketUpdateDetailsResponse(): MsgMarketUpdateDetailsResponse {
  return {};
}

export const MsgMarketUpdateDetailsResponse: MessageFns<MsgMarketUpdateDetailsResponse> = {
  encode(_: MsgMarketUpdateDetailsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketUpdateDetailsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketUpdateDetailsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgMarketUpdateDetailsResponse {
    return {};
  },

  toJSON(_: MsgMarketUpdateDetailsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketUpdateDetailsResponse>, I>>(base?: I): MsgMarketUpdateDetailsResponse {
    return MsgMarketUpdateDetailsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketUpdateDetailsResponse>, I>>(_: I): MsgMarketUpdateDetailsResponse {
    const message = createBaseMsgMarketUpdateDetailsResponse();
    return message;
  },
};

function createBaseMsgMarketUpdateEnabledRequest(): MsgMarketUpdateEnabledRequest {
  return { admin: "", marketId: 0, acceptingOrders: false };
}

export const MsgMarketUpdateEnabledRequest: MessageFns<MsgMarketUpdateEnabledRequest> = {
  encode(message: MsgMarketUpdateEnabledRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.admin !== "") {
      writer.uint32(10).string(message.admin);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    if (message.acceptingOrders !== false) {
      writer.uint32(24).bool(message.acceptingOrders);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketUpdateEnabledRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketUpdateEnabledRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.admin = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.acceptingOrders = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMarketUpdateEnabledRequest {
    return {
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      acceptingOrders: isSet(object.acceptingOrders) ? globalThis.Boolean(object.acceptingOrders) : false,
    };
  },

  toJSON(message: MsgMarketUpdateEnabledRequest): unknown {
    const obj: any = {};
    if (message.admin !== "") {
      obj.admin = message.admin;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.acceptingOrders !== false) {
      obj.acceptingOrders = message.acceptingOrders;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketUpdateEnabledRequest>, I>>(base?: I): MsgMarketUpdateEnabledRequest {
    return MsgMarketUpdateEnabledRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketUpdateEnabledRequest>, I>>(
    object: I,
  ): MsgMarketUpdateEnabledRequest {
    const message = createBaseMsgMarketUpdateEnabledRequest();
    message.admin = object.admin ?? "";
    message.marketId = object.marketId ?? 0;
    message.acceptingOrders = object.acceptingOrders ?? false;
    return message;
  },
};

function createBaseMsgMarketUpdateEnabledResponse(): MsgMarketUpdateEnabledResponse {
  return {};
}

export const MsgMarketUpdateEnabledResponse: MessageFns<MsgMarketUpdateEnabledResponse> = {
  encode(_: MsgMarketUpdateEnabledResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketUpdateEnabledResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketUpdateEnabledResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgMarketUpdateEnabledResponse {
    return {};
  },

  toJSON(_: MsgMarketUpdateEnabledResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketUpdateEnabledResponse>, I>>(base?: I): MsgMarketUpdateEnabledResponse {
    return MsgMarketUpdateEnabledResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketUpdateEnabledResponse>, I>>(_: I): MsgMarketUpdateEnabledResponse {
    const message = createBaseMsgMarketUpdateEnabledResponse();
    return message;
  },
};

function createBaseMsgMarketUpdateAcceptingOrdersRequest(): MsgMarketUpdateAcceptingOrdersRequest {
  return { admin: "", marketId: 0, acceptingOrders: false };
}

export const MsgMarketUpdateAcceptingOrdersRequest: MessageFns<MsgMarketUpdateAcceptingOrdersRequest> = {
  encode(message: MsgMarketUpdateAcceptingOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.admin !== "") {
      writer.uint32(10).string(message.admin);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    if (message.acceptingOrders !== false) {
      writer.uint32(24).bool(message.acceptingOrders);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketUpdateAcceptingOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketUpdateAcceptingOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.admin = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.acceptingOrders = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMarketUpdateAcceptingOrdersRequest {
    return {
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      acceptingOrders: isSet(object.acceptingOrders) ? globalThis.Boolean(object.acceptingOrders) : false,
    };
  },

  toJSON(message: MsgMarketUpdateAcceptingOrdersRequest): unknown {
    const obj: any = {};
    if (message.admin !== "") {
      obj.admin = message.admin;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.acceptingOrders !== false) {
      obj.acceptingOrders = message.acceptingOrders;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketUpdateAcceptingOrdersRequest>, I>>(
    base?: I,
  ): MsgMarketUpdateAcceptingOrdersRequest {
    return MsgMarketUpdateAcceptingOrdersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketUpdateAcceptingOrdersRequest>, I>>(
    object: I,
  ): MsgMarketUpdateAcceptingOrdersRequest {
    const message = createBaseMsgMarketUpdateAcceptingOrdersRequest();
    message.admin = object.admin ?? "";
    message.marketId = object.marketId ?? 0;
    message.acceptingOrders = object.acceptingOrders ?? false;
    return message;
  },
};

function createBaseMsgMarketUpdateAcceptingOrdersResponse(): MsgMarketUpdateAcceptingOrdersResponse {
  return {};
}

export const MsgMarketUpdateAcceptingOrdersResponse: MessageFns<MsgMarketUpdateAcceptingOrdersResponse> = {
  encode(_: MsgMarketUpdateAcceptingOrdersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketUpdateAcceptingOrdersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketUpdateAcceptingOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgMarketUpdateAcceptingOrdersResponse {
    return {};
  },

  toJSON(_: MsgMarketUpdateAcceptingOrdersResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketUpdateAcceptingOrdersResponse>, I>>(
    base?: I,
  ): MsgMarketUpdateAcceptingOrdersResponse {
    return MsgMarketUpdateAcceptingOrdersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketUpdateAcceptingOrdersResponse>, I>>(
    _: I,
  ): MsgMarketUpdateAcceptingOrdersResponse {
    const message = createBaseMsgMarketUpdateAcceptingOrdersResponse();
    return message;
  },
};

function createBaseMsgMarketUpdateUserSettleRequest(): MsgMarketUpdateUserSettleRequest {
  return { admin: "", marketId: 0, allowUserSettlement: false };
}

export const MsgMarketUpdateUserSettleRequest: MessageFns<MsgMarketUpdateUserSettleRequest> = {
  encode(message: MsgMarketUpdateUserSettleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.admin !== "") {
      writer.uint32(10).string(message.admin);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    if (message.allowUserSettlement !== false) {
      writer.uint32(24).bool(message.allowUserSettlement);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketUpdateUserSettleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketUpdateUserSettleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.admin = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.allowUserSettlement = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMarketUpdateUserSettleRequest {
    return {
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      allowUserSettlement: isSet(object.allowUserSettlement) ? globalThis.Boolean(object.allowUserSettlement) : false,
    };
  },

  toJSON(message: MsgMarketUpdateUserSettleRequest): unknown {
    const obj: any = {};
    if (message.admin !== "") {
      obj.admin = message.admin;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.allowUserSettlement !== false) {
      obj.allowUserSettlement = message.allowUserSettlement;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketUpdateUserSettleRequest>, I>>(
    base?: I,
  ): MsgMarketUpdateUserSettleRequest {
    return MsgMarketUpdateUserSettleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketUpdateUserSettleRequest>, I>>(
    object: I,
  ): MsgMarketUpdateUserSettleRequest {
    const message = createBaseMsgMarketUpdateUserSettleRequest();
    message.admin = object.admin ?? "";
    message.marketId = object.marketId ?? 0;
    message.allowUserSettlement = object.allowUserSettlement ?? false;
    return message;
  },
};

function createBaseMsgMarketUpdateUserSettleResponse(): MsgMarketUpdateUserSettleResponse {
  return {};
}

export const MsgMarketUpdateUserSettleResponse: MessageFns<MsgMarketUpdateUserSettleResponse> = {
  encode(_: MsgMarketUpdateUserSettleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketUpdateUserSettleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketUpdateUserSettleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgMarketUpdateUserSettleResponse {
    return {};
  },

  toJSON(_: MsgMarketUpdateUserSettleResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketUpdateUserSettleResponse>, I>>(
    base?: I,
  ): MsgMarketUpdateUserSettleResponse {
    return MsgMarketUpdateUserSettleResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketUpdateUserSettleResponse>, I>>(
    _: I,
  ): MsgMarketUpdateUserSettleResponse {
    const message = createBaseMsgMarketUpdateUserSettleResponse();
    return message;
  },
};

function createBaseMsgMarketUpdateAcceptingCommitmentsRequest(): MsgMarketUpdateAcceptingCommitmentsRequest {
  return { admin: "", marketId: 0, acceptingCommitments: false };
}

export const MsgMarketUpdateAcceptingCommitmentsRequest: MessageFns<MsgMarketUpdateAcceptingCommitmentsRequest> = {
  encode(message: MsgMarketUpdateAcceptingCommitmentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.admin !== "") {
      writer.uint32(10).string(message.admin);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    if (message.acceptingCommitments !== false) {
      writer.uint32(24).bool(message.acceptingCommitments);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketUpdateAcceptingCommitmentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketUpdateAcceptingCommitmentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.admin = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.acceptingCommitments = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMarketUpdateAcceptingCommitmentsRequest {
    return {
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      acceptingCommitments: isSet(object.acceptingCommitments)
        ? globalThis.Boolean(object.acceptingCommitments)
        : false,
    };
  },

  toJSON(message: MsgMarketUpdateAcceptingCommitmentsRequest): unknown {
    const obj: any = {};
    if (message.admin !== "") {
      obj.admin = message.admin;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.acceptingCommitments !== false) {
      obj.acceptingCommitments = message.acceptingCommitments;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketUpdateAcceptingCommitmentsRequest>, I>>(
    base?: I,
  ): MsgMarketUpdateAcceptingCommitmentsRequest {
    return MsgMarketUpdateAcceptingCommitmentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketUpdateAcceptingCommitmentsRequest>, I>>(
    object: I,
  ): MsgMarketUpdateAcceptingCommitmentsRequest {
    const message = createBaseMsgMarketUpdateAcceptingCommitmentsRequest();
    message.admin = object.admin ?? "";
    message.marketId = object.marketId ?? 0;
    message.acceptingCommitments = object.acceptingCommitments ?? false;
    return message;
  },
};

function createBaseMsgMarketUpdateAcceptingCommitmentsResponse(): MsgMarketUpdateAcceptingCommitmentsResponse {
  return {};
}

export const MsgMarketUpdateAcceptingCommitmentsResponse: MessageFns<MsgMarketUpdateAcceptingCommitmentsResponse> = {
  encode(_: MsgMarketUpdateAcceptingCommitmentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketUpdateAcceptingCommitmentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketUpdateAcceptingCommitmentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgMarketUpdateAcceptingCommitmentsResponse {
    return {};
  },

  toJSON(_: MsgMarketUpdateAcceptingCommitmentsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketUpdateAcceptingCommitmentsResponse>, I>>(
    base?: I,
  ): MsgMarketUpdateAcceptingCommitmentsResponse {
    return MsgMarketUpdateAcceptingCommitmentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketUpdateAcceptingCommitmentsResponse>, I>>(
    _: I,
  ): MsgMarketUpdateAcceptingCommitmentsResponse {
    const message = createBaseMsgMarketUpdateAcceptingCommitmentsResponse();
    return message;
  },
};

function createBaseMsgMarketUpdateIntermediaryDenomRequest(): MsgMarketUpdateIntermediaryDenomRequest {
  return { admin: "", marketId: 0, intermediaryDenom: "" };
}

export const MsgMarketUpdateIntermediaryDenomRequest: MessageFns<MsgMarketUpdateIntermediaryDenomRequest> = {
  encode(message: MsgMarketUpdateIntermediaryDenomRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.admin !== "") {
      writer.uint32(10).string(message.admin);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    if (message.intermediaryDenom !== "") {
      writer.uint32(26).string(message.intermediaryDenom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketUpdateIntermediaryDenomRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketUpdateIntermediaryDenomRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.admin = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.intermediaryDenom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMarketUpdateIntermediaryDenomRequest {
    return {
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      intermediaryDenom: isSet(object.intermediaryDenom) ? globalThis.String(object.intermediaryDenom) : "",
    };
  },

  toJSON(message: MsgMarketUpdateIntermediaryDenomRequest): unknown {
    const obj: any = {};
    if (message.admin !== "") {
      obj.admin = message.admin;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.intermediaryDenom !== "") {
      obj.intermediaryDenom = message.intermediaryDenom;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketUpdateIntermediaryDenomRequest>, I>>(
    base?: I,
  ): MsgMarketUpdateIntermediaryDenomRequest {
    return MsgMarketUpdateIntermediaryDenomRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketUpdateIntermediaryDenomRequest>, I>>(
    object: I,
  ): MsgMarketUpdateIntermediaryDenomRequest {
    const message = createBaseMsgMarketUpdateIntermediaryDenomRequest();
    message.admin = object.admin ?? "";
    message.marketId = object.marketId ?? 0;
    message.intermediaryDenom = object.intermediaryDenom ?? "";
    return message;
  },
};

function createBaseMsgMarketUpdateIntermediaryDenomResponse(): MsgMarketUpdateIntermediaryDenomResponse {
  return {};
}

export const MsgMarketUpdateIntermediaryDenomResponse: MessageFns<MsgMarketUpdateIntermediaryDenomResponse> = {
  encode(_: MsgMarketUpdateIntermediaryDenomResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketUpdateIntermediaryDenomResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketUpdateIntermediaryDenomResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgMarketUpdateIntermediaryDenomResponse {
    return {};
  },

  toJSON(_: MsgMarketUpdateIntermediaryDenomResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketUpdateIntermediaryDenomResponse>, I>>(
    base?: I,
  ): MsgMarketUpdateIntermediaryDenomResponse {
    return MsgMarketUpdateIntermediaryDenomResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketUpdateIntermediaryDenomResponse>, I>>(
    _: I,
  ): MsgMarketUpdateIntermediaryDenomResponse {
    const message = createBaseMsgMarketUpdateIntermediaryDenomResponse();
    return message;
  },
};

function createBaseMsgMarketManagePermissionsRequest(): MsgMarketManagePermissionsRequest {
  return { admin: "", marketId: 0, revokeAll: [], toRevoke: [], toGrant: [] };
}

export const MsgMarketManagePermissionsRequest: MessageFns<MsgMarketManagePermissionsRequest> = {
  encode(message: MsgMarketManagePermissionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.admin !== "") {
      writer.uint32(10).string(message.admin);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    for (const v of message.revokeAll) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.toRevoke) {
      AccessGrant.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.toGrant) {
      AccessGrant.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketManagePermissionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketManagePermissionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.admin = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.revokeAll.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.toRevoke.push(AccessGrant.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.toGrant.push(AccessGrant.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMarketManagePermissionsRequest {
    return {
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      revokeAll: globalThis.Array.isArray(object?.revokeAll)
        ? object.revokeAll.map((e: any) => globalThis.String(e))
        : [],
      toRevoke: globalThis.Array.isArray(object?.toRevoke)
        ? object.toRevoke.map((e: any) => AccessGrant.fromJSON(e))
        : [],
      toGrant: globalThis.Array.isArray(object?.toGrant) ? object.toGrant.map((e: any) => AccessGrant.fromJSON(e)) : [],
    };
  },

  toJSON(message: MsgMarketManagePermissionsRequest): unknown {
    const obj: any = {};
    if (message.admin !== "") {
      obj.admin = message.admin;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.revokeAll?.length) {
      obj.revokeAll = message.revokeAll;
    }
    if (message.toRevoke?.length) {
      obj.toRevoke = message.toRevoke.map((e) => AccessGrant.toJSON(e));
    }
    if (message.toGrant?.length) {
      obj.toGrant = message.toGrant.map((e) => AccessGrant.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketManagePermissionsRequest>, I>>(
    base?: I,
  ): MsgMarketManagePermissionsRequest {
    return MsgMarketManagePermissionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketManagePermissionsRequest>, I>>(
    object: I,
  ): MsgMarketManagePermissionsRequest {
    const message = createBaseMsgMarketManagePermissionsRequest();
    message.admin = object.admin ?? "";
    message.marketId = object.marketId ?? 0;
    message.revokeAll = object.revokeAll?.map((e) => e) || [];
    message.toRevoke = object.toRevoke?.map((e) => AccessGrant.fromPartial(e)) || [];
    message.toGrant = object.toGrant?.map((e) => AccessGrant.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgMarketManagePermissionsResponse(): MsgMarketManagePermissionsResponse {
  return {};
}

export const MsgMarketManagePermissionsResponse: MessageFns<MsgMarketManagePermissionsResponse> = {
  encode(_: MsgMarketManagePermissionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketManagePermissionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketManagePermissionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgMarketManagePermissionsResponse {
    return {};
  },

  toJSON(_: MsgMarketManagePermissionsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketManagePermissionsResponse>, I>>(
    base?: I,
  ): MsgMarketManagePermissionsResponse {
    return MsgMarketManagePermissionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketManagePermissionsResponse>, I>>(
    _: I,
  ): MsgMarketManagePermissionsResponse {
    const message = createBaseMsgMarketManagePermissionsResponse();
    return message;
  },
};

function createBaseMsgMarketManageReqAttrsRequest(): MsgMarketManageReqAttrsRequest {
  return {
    admin: "",
    marketId: 0,
    createAskToAdd: [],
    createAskToRemove: [],
    createBidToAdd: [],
    createBidToRemove: [],
    createCommitmentToAdd: [],
    createCommitmentToRemove: [],
  };
}

export const MsgMarketManageReqAttrsRequest: MessageFns<MsgMarketManageReqAttrsRequest> = {
  encode(message: MsgMarketManageReqAttrsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.admin !== "") {
      writer.uint32(10).string(message.admin);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    for (const v of message.createAskToAdd) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.createAskToRemove) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.createBidToAdd) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.createBidToRemove) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.createCommitmentToAdd) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.createCommitmentToRemove) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketManageReqAttrsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketManageReqAttrsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.admin = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.createAskToAdd.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createAskToRemove.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createBidToAdd.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createBidToRemove.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createCommitmentToAdd.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.createCommitmentToRemove.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgMarketManageReqAttrsRequest {
    return {
      admin: isSet(object.admin) ? globalThis.String(object.admin) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      createAskToAdd: globalThis.Array.isArray(object?.createAskToAdd)
        ? object.createAskToAdd.map((e: any) => globalThis.String(e))
        : [],
      createAskToRemove: globalThis.Array.isArray(object?.createAskToRemove)
        ? object.createAskToRemove.map((e: any) => globalThis.String(e))
        : [],
      createBidToAdd: globalThis.Array.isArray(object?.createBidToAdd)
        ? object.createBidToAdd.map((e: any) => globalThis.String(e))
        : [],
      createBidToRemove: globalThis.Array.isArray(object?.createBidToRemove)
        ? object.createBidToRemove.map((e: any) => globalThis.String(e))
        : [],
      createCommitmentToAdd: globalThis.Array.isArray(object?.createCommitmentToAdd)
        ? object.createCommitmentToAdd.map((e: any) => globalThis.String(e))
        : [],
      createCommitmentToRemove: globalThis.Array.isArray(object?.createCommitmentToRemove)
        ? object.createCommitmentToRemove.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MsgMarketManageReqAttrsRequest): unknown {
    const obj: any = {};
    if (message.admin !== "") {
      obj.admin = message.admin;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.createAskToAdd?.length) {
      obj.createAskToAdd = message.createAskToAdd;
    }
    if (message.createAskToRemove?.length) {
      obj.createAskToRemove = message.createAskToRemove;
    }
    if (message.createBidToAdd?.length) {
      obj.createBidToAdd = message.createBidToAdd;
    }
    if (message.createBidToRemove?.length) {
      obj.createBidToRemove = message.createBidToRemove;
    }
    if (message.createCommitmentToAdd?.length) {
      obj.createCommitmentToAdd = message.createCommitmentToAdd;
    }
    if (message.createCommitmentToRemove?.length) {
      obj.createCommitmentToRemove = message.createCommitmentToRemove;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketManageReqAttrsRequest>, I>>(base?: I): MsgMarketManageReqAttrsRequest {
    return MsgMarketManageReqAttrsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketManageReqAttrsRequest>, I>>(
    object: I,
  ): MsgMarketManageReqAttrsRequest {
    const message = createBaseMsgMarketManageReqAttrsRequest();
    message.admin = object.admin ?? "";
    message.marketId = object.marketId ?? 0;
    message.createAskToAdd = object.createAskToAdd?.map((e) => e) || [];
    message.createAskToRemove = object.createAskToRemove?.map((e) => e) || [];
    message.createBidToAdd = object.createBidToAdd?.map((e) => e) || [];
    message.createBidToRemove = object.createBidToRemove?.map((e) => e) || [];
    message.createCommitmentToAdd = object.createCommitmentToAdd?.map((e) => e) || [];
    message.createCommitmentToRemove = object.createCommitmentToRemove?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgMarketManageReqAttrsResponse(): MsgMarketManageReqAttrsResponse {
  return {};
}

export const MsgMarketManageReqAttrsResponse: MessageFns<MsgMarketManageReqAttrsResponse> = {
  encode(_: MsgMarketManageReqAttrsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgMarketManageReqAttrsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgMarketManageReqAttrsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgMarketManageReqAttrsResponse {
    return {};
  },

  toJSON(_: MsgMarketManageReqAttrsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgMarketManageReqAttrsResponse>, I>>(base?: I): MsgMarketManageReqAttrsResponse {
    return MsgMarketManageReqAttrsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgMarketManageReqAttrsResponse>, I>>(_: I): MsgMarketManageReqAttrsResponse {
    const message = createBaseMsgMarketManageReqAttrsResponse();
    return message;
  },
};

function createBaseMsgCreatePaymentRequest(): MsgCreatePaymentRequest {
  return { payment: undefined };
}

export const MsgCreatePaymentRequest: MessageFns<MsgCreatePaymentRequest> = {
  encode(message: MsgCreatePaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payment !== undefined) {
      Payment.encode(message.payment, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreatePaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreatePaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payment = Payment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreatePaymentRequest {
    return { payment: isSet(object.payment) ? Payment.fromJSON(object.payment) : undefined };
  },

  toJSON(message: MsgCreatePaymentRequest): unknown {
    const obj: any = {};
    if (message.payment !== undefined) {
      obj.payment = Payment.toJSON(message.payment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreatePaymentRequest>, I>>(base?: I): MsgCreatePaymentRequest {
    return MsgCreatePaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreatePaymentRequest>, I>>(object: I): MsgCreatePaymentRequest {
    const message = createBaseMsgCreatePaymentRequest();
    message.payment = (object.payment !== undefined && object.payment !== null)
      ? Payment.fromPartial(object.payment)
      : undefined;
    return message;
  },
};

function createBaseMsgCreatePaymentResponse(): MsgCreatePaymentResponse {
  return {};
}

export const MsgCreatePaymentResponse: MessageFns<MsgCreatePaymentResponse> = {
  encode(_: MsgCreatePaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreatePaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreatePaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCreatePaymentResponse {
    return {};
  },

  toJSON(_: MsgCreatePaymentResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreatePaymentResponse>, I>>(base?: I): MsgCreatePaymentResponse {
    return MsgCreatePaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreatePaymentResponse>, I>>(_: I): MsgCreatePaymentResponse {
    const message = createBaseMsgCreatePaymentResponse();
    return message;
  },
};

function createBaseMsgAcceptPaymentRequest(): MsgAcceptPaymentRequest {
  return { payment: undefined };
}

export const MsgAcceptPaymentRequest: MessageFns<MsgAcceptPaymentRequest> = {
  encode(message: MsgAcceptPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.payment !== undefined) {
      Payment.encode(message.payment, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAcceptPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAcceptPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.payment = Payment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAcceptPaymentRequest {
    return { payment: isSet(object.payment) ? Payment.fromJSON(object.payment) : undefined };
  },

  toJSON(message: MsgAcceptPaymentRequest): unknown {
    const obj: any = {};
    if (message.payment !== undefined) {
      obj.payment = Payment.toJSON(message.payment);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAcceptPaymentRequest>, I>>(base?: I): MsgAcceptPaymentRequest {
    return MsgAcceptPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAcceptPaymentRequest>, I>>(object: I): MsgAcceptPaymentRequest {
    const message = createBaseMsgAcceptPaymentRequest();
    message.payment = (object.payment !== undefined && object.payment !== null)
      ? Payment.fromPartial(object.payment)
      : undefined;
    return message;
  },
};

function createBaseMsgAcceptPaymentResponse(): MsgAcceptPaymentResponse {
  return {};
}

export const MsgAcceptPaymentResponse: MessageFns<MsgAcceptPaymentResponse> = {
  encode(_: MsgAcceptPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAcceptPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAcceptPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAcceptPaymentResponse {
    return {};
  },

  toJSON(_: MsgAcceptPaymentResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAcceptPaymentResponse>, I>>(base?: I): MsgAcceptPaymentResponse {
    return MsgAcceptPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAcceptPaymentResponse>, I>>(_: I): MsgAcceptPaymentResponse {
    const message = createBaseMsgAcceptPaymentResponse();
    return message;
  },
};

function createBaseMsgRejectPaymentRequest(): MsgRejectPaymentRequest {
  return { target: "", source: "", externalId: "" };
}

export const MsgRejectPaymentRequest: MessageFns<MsgRejectPaymentRequest> = {
  encode(message: MsgRejectPaymentRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== "") {
      writer.uint32(10).string(message.target);
    }
    if (message.source !== "") {
      writer.uint32(18).string(message.source);
    }
    if (message.externalId !== "") {
      writer.uint32(26).string(message.externalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRejectPaymentRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRejectPaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.target = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRejectPaymentRequest {
    return {
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
    };
  },

  toJSON(message: MsgRejectPaymentRequest): unknown {
    const obj: any = {};
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRejectPaymentRequest>, I>>(base?: I): MsgRejectPaymentRequest {
    return MsgRejectPaymentRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRejectPaymentRequest>, I>>(object: I): MsgRejectPaymentRequest {
    const message = createBaseMsgRejectPaymentRequest();
    message.target = object.target ?? "";
    message.source = object.source ?? "";
    message.externalId = object.externalId ?? "";
    return message;
  },
};

function createBaseMsgRejectPaymentResponse(): MsgRejectPaymentResponse {
  return {};
}

export const MsgRejectPaymentResponse: MessageFns<MsgRejectPaymentResponse> = {
  encode(_: MsgRejectPaymentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRejectPaymentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRejectPaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRejectPaymentResponse {
    return {};
  },

  toJSON(_: MsgRejectPaymentResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRejectPaymentResponse>, I>>(base?: I): MsgRejectPaymentResponse {
    return MsgRejectPaymentResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRejectPaymentResponse>, I>>(_: I): MsgRejectPaymentResponse {
    const message = createBaseMsgRejectPaymentResponse();
    return message;
  },
};

function createBaseMsgRejectPaymentsRequest(): MsgRejectPaymentsRequest {
  return { target: "", sources: [] };
}

export const MsgRejectPaymentsRequest: MessageFns<MsgRejectPaymentsRequest> = {
  encode(message: MsgRejectPaymentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== "") {
      writer.uint32(10).string(message.target);
    }
    for (const v of message.sources) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRejectPaymentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRejectPaymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.target = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sources.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRejectPaymentsRequest {
    return {
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      sources: globalThis.Array.isArray(object?.sources) ? object.sources.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgRejectPaymentsRequest): unknown {
    const obj: any = {};
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.sources?.length) {
      obj.sources = message.sources;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRejectPaymentsRequest>, I>>(base?: I): MsgRejectPaymentsRequest {
    return MsgRejectPaymentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRejectPaymentsRequest>, I>>(object: I): MsgRejectPaymentsRequest {
    const message = createBaseMsgRejectPaymentsRequest();
    message.target = object.target ?? "";
    message.sources = object.sources?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgRejectPaymentsResponse(): MsgRejectPaymentsResponse {
  return {};
}

export const MsgRejectPaymentsResponse: MessageFns<MsgRejectPaymentsResponse> = {
  encode(_: MsgRejectPaymentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRejectPaymentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRejectPaymentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRejectPaymentsResponse {
    return {};
  },

  toJSON(_: MsgRejectPaymentsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgRejectPaymentsResponse>, I>>(base?: I): MsgRejectPaymentsResponse {
    return MsgRejectPaymentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgRejectPaymentsResponse>, I>>(_: I): MsgRejectPaymentsResponse {
    const message = createBaseMsgRejectPaymentsResponse();
    return message;
  },
};

function createBaseMsgCancelPaymentsRequest(): MsgCancelPaymentsRequest {
  return { source: "", externalIds: [] };
}

export const MsgCancelPaymentsRequest: MessageFns<MsgCancelPaymentsRequest> = {
  encode(message: MsgCancelPaymentsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    for (const v of message.externalIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCancelPaymentsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelPaymentsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.externalIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCancelPaymentsRequest {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      externalIds: globalThis.Array.isArray(object?.externalIds)
        ? object.externalIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MsgCancelPaymentsRequest): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.externalIds?.length) {
      obj.externalIds = message.externalIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCancelPaymentsRequest>, I>>(base?: I): MsgCancelPaymentsRequest {
    return MsgCancelPaymentsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCancelPaymentsRequest>, I>>(object: I): MsgCancelPaymentsRequest {
    const message = createBaseMsgCancelPaymentsRequest();
    message.source = object.source ?? "";
    message.externalIds = object.externalIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgCancelPaymentsResponse(): MsgCancelPaymentsResponse {
  return {};
}

export const MsgCancelPaymentsResponse: MessageFns<MsgCancelPaymentsResponse> = {
  encode(_: MsgCancelPaymentsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCancelPaymentsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelPaymentsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCancelPaymentsResponse {
    return {};
  },

  toJSON(_: MsgCancelPaymentsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCancelPaymentsResponse>, I>>(base?: I): MsgCancelPaymentsResponse {
    return MsgCancelPaymentsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCancelPaymentsResponse>, I>>(_: I): MsgCancelPaymentsResponse {
    const message = createBaseMsgCancelPaymentsResponse();
    return message;
  },
};

function createBaseMsgChangePaymentTargetRequest(): MsgChangePaymentTargetRequest {
  return { source: "", externalId: "", newTarget: "" };
}

export const MsgChangePaymentTargetRequest: MessageFns<MsgChangePaymentTargetRequest> = {
  encode(message: MsgChangePaymentTargetRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.externalId !== "") {
      writer.uint32(18).string(message.externalId);
    }
    if (message.newTarget !== "") {
      writer.uint32(26).string(message.newTarget);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgChangePaymentTargetRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgChangePaymentTargetRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newTarget = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgChangePaymentTargetRequest {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
      newTarget: isSet(object.newTarget) ? globalThis.String(object.newTarget) : "",
    };
  },

  toJSON(message: MsgChangePaymentTargetRequest): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    if (message.newTarget !== "") {
      obj.newTarget = message.newTarget;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgChangePaymentTargetRequest>, I>>(base?: I): MsgChangePaymentTargetRequest {
    return MsgChangePaymentTargetRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgChangePaymentTargetRequest>, I>>(
    object: I,
  ): MsgChangePaymentTargetRequest {
    const message = createBaseMsgChangePaymentTargetRequest();
    message.source = object.source ?? "";
    message.externalId = object.externalId ?? "";
    message.newTarget = object.newTarget ?? "";
    return message;
  },
};

function createBaseMsgChangePaymentTargetResponse(): MsgChangePaymentTargetResponse {
  return {};
}

export const MsgChangePaymentTargetResponse: MessageFns<MsgChangePaymentTargetResponse> = {
  encode(_: MsgChangePaymentTargetResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgChangePaymentTargetResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgChangePaymentTargetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgChangePaymentTargetResponse {
    return {};
  },

  toJSON(_: MsgChangePaymentTargetResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgChangePaymentTargetResponse>, I>>(base?: I): MsgChangePaymentTargetResponse {
    return MsgChangePaymentTargetResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgChangePaymentTargetResponse>, I>>(_: I): MsgChangePaymentTargetResponse {
    const message = createBaseMsgChangePaymentTargetResponse();
    return message;
  },
};

function createBaseMsgGovCreateMarketRequest(): MsgGovCreateMarketRequest {
  return { authority: "", market: undefined };
}

export const MsgGovCreateMarketRequest: MessageFns<MsgGovCreateMarketRequest> = {
  encode(message: MsgGovCreateMarketRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.market !== undefined) {
      Market.encode(message.market, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGovCreateMarketRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGovCreateMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.market = Market.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGovCreateMarketRequest {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      market: isSet(object.market) ? Market.fromJSON(object.market) : undefined,
    };
  },

  toJSON(message: MsgGovCreateMarketRequest): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.market !== undefined) {
      obj.market = Market.toJSON(message.market);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGovCreateMarketRequest>, I>>(base?: I): MsgGovCreateMarketRequest {
    return MsgGovCreateMarketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGovCreateMarketRequest>, I>>(object: I): MsgGovCreateMarketRequest {
    const message = createBaseMsgGovCreateMarketRequest();
    message.authority = object.authority ?? "";
    message.market = (object.market !== undefined && object.market !== null)
      ? Market.fromPartial(object.market)
      : undefined;
    return message;
  },
};

function createBaseMsgGovCreateMarketResponse(): MsgGovCreateMarketResponse {
  return {};
}

export const MsgGovCreateMarketResponse: MessageFns<MsgGovCreateMarketResponse> = {
  encode(_: MsgGovCreateMarketResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGovCreateMarketResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGovCreateMarketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgGovCreateMarketResponse {
    return {};
  },

  toJSON(_: MsgGovCreateMarketResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGovCreateMarketResponse>, I>>(base?: I): MsgGovCreateMarketResponse {
    return MsgGovCreateMarketResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGovCreateMarketResponse>, I>>(_: I): MsgGovCreateMarketResponse {
    const message = createBaseMsgGovCreateMarketResponse();
    return message;
  },
};

function createBaseMsgGovManageFeesRequest(): MsgGovManageFeesRequest {
  return {
    authority: "",
    marketId: 0,
    addFeeCreateAskFlat: [],
    removeFeeCreateAskFlat: [],
    addFeeCreateBidFlat: [],
    removeFeeCreateBidFlat: [],
    addFeeSellerSettlementFlat: [],
    removeFeeSellerSettlementFlat: [],
    addFeeSellerSettlementRatios: [],
    removeFeeSellerSettlementRatios: [],
    addFeeBuyerSettlementFlat: [],
    removeFeeBuyerSettlementFlat: [],
    addFeeBuyerSettlementRatios: [],
    removeFeeBuyerSettlementRatios: [],
    addFeeCreateCommitmentFlat: [],
    removeFeeCreateCommitmentFlat: [],
    setFeeCommitmentSettlementBips: 0,
    unsetFeeCommitmentSettlementBips: false,
  };
}

export const MsgGovManageFeesRequest: MessageFns<MsgGovManageFeesRequest> = {
  encode(message: MsgGovManageFeesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    for (const v of message.addFeeCreateAskFlat) {
      Coin.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.removeFeeCreateAskFlat) {
      Coin.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.addFeeCreateBidFlat) {
      Coin.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.removeFeeCreateBidFlat) {
      Coin.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.addFeeSellerSettlementFlat) {
      Coin.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.removeFeeSellerSettlementFlat) {
      Coin.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.addFeeSellerSettlementRatios) {
      FeeRatio.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.removeFeeSellerSettlementRatios) {
      FeeRatio.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.addFeeBuyerSettlementFlat) {
      Coin.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.removeFeeBuyerSettlementFlat) {
      Coin.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.addFeeBuyerSettlementRatios) {
      FeeRatio.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.removeFeeBuyerSettlementRatios) {
      FeeRatio.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.addFeeCreateCommitmentFlat) {
      Coin.encode(v!, writer.uint32(122).fork()).join();
    }
    for (const v of message.removeFeeCreateCommitmentFlat) {
      Coin.encode(v!, writer.uint32(130).fork()).join();
    }
    if (message.setFeeCommitmentSettlementBips !== 0) {
      writer.uint32(136).uint32(message.setFeeCommitmentSettlementBips);
    }
    if (message.unsetFeeCommitmentSettlementBips !== false) {
      writer.uint32(144).bool(message.unsetFeeCommitmentSettlementBips);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGovManageFeesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGovManageFeesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.addFeeCreateAskFlat.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.removeFeeCreateAskFlat.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.addFeeCreateBidFlat.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.removeFeeCreateBidFlat.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.addFeeSellerSettlementFlat.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.removeFeeSellerSettlementFlat.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.addFeeSellerSettlementRatios.push(FeeRatio.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.removeFeeSellerSettlementRatios.push(FeeRatio.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.addFeeBuyerSettlementFlat.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.removeFeeBuyerSettlementFlat.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.addFeeBuyerSettlementRatios.push(FeeRatio.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.removeFeeBuyerSettlementRatios.push(FeeRatio.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.addFeeCreateCommitmentFlat.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.removeFeeCreateCommitmentFlat.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.setFeeCommitmentSettlementBips = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.unsetFeeCommitmentSettlementBips = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGovManageFeesRequest {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      addFeeCreateAskFlat: globalThis.Array.isArray(object?.addFeeCreateAskFlat)
        ? object.addFeeCreateAskFlat.map((e: any) => Coin.fromJSON(e))
        : [],
      removeFeeCreateAskFlat: globalThis.Array.isArray(object?.removeFeeCreateAskFlat)
        ? object.removeFeeCreateAskFlat.map((e: any) => Coin.fromJSON(e))
        : [],
      addFeeCreateBidFlat: globalThis.Array.isArray(object?.addFeeCreateBidFlat)
        ? object.addFeeCreateBidFlat.map((e: any) => Coin.fromJSON(e))
        : [],
      removeFeeCreateBidFlat: globalThis.Array.isArray(object?.removeFeeCreateBidFlat)
        ? object.removeFeeCreateBidFlat.map((e: any) => Coin.fromJSON(e))
        : [],
      addFeeSellerSettlementFlat: globalThis.Array.isArray(object?.addFeeSellerSettlementFlat)
        ? object.addFeeSellerSettlementFlat.map((e: any) => Coin.fromJSON(e))
        : [],
      removeFeeSellerSettlementFlat: globalThis.Array.isArray(object?.removeFeeSellerSettlementFlat)
        ? object.removeFeeSellerSettlementFlat.map((e: any) => Coin.fromJSON(e))
        : [],
      addFeeSellerSettlementRatios: globalThis.Array.isArray(object?.addFeeSellerSettlementRatios)
        ? object.addFeeSellerSettlementRatios.map((e: any) => FeeRatio.fromJSON(e))
        : [],
      removeFeeSellerSettlementRatios: globalThis.Array.isArray(object?.removeFeeSellerSettlementRatios)
        ? object.removeFeeSellerSettlementRatios.map((e: any) => FeeRatio.fromJSON(e))
        : [],
      addFeeBuyerSettlementFlat: globalThis.Array.isArray(object?.addFeeBuyerSettlementFlat)
        ? object.addFeeBuyerSettlementFlat.map((e: any) => Coin.fromJSON(e))
        : [],
      removeFeeBuyerSettlementFlat: globalThis.Array.isArray(object?.removeFeeBuyerSettlementFlat)
        ? object.removeFeeBuyerSettlementFlat.map((e: any) => Coin.fromJSON(e))
        : [],
      addFeeBuyerSettlementRatios: globalThis.Array.isArray(object?.addFeeBuyerSettlementRatios)
        ? object.addFeeBuyerSettlementRatios.map((e: any) => FeeRatio.fromJSON(e))
        : [],
      removeFeeBuyerSettlementRatios: globalThis.Array.isArray(object?.removeFeeBuyerSettlementRatios)
        ? object.removeFeeBuyerSettlementRatios.map((e: any) => FeeRatio.fromJSON(e))
        : [],
      addFeeCreateCommitmentFlat: globalThis.Array.isArray(object?.addFeeCreateCommitmentFlat)
        ? object.addFeeCreateCommitmentFlat.map((e: any) => Coin.fromJSON(e))
        : [],
      removeFeeCreateCommitmentFlat: globalThis.Array.isArray(object?.removeFeeCreateCommitmentFlat)
        ? object.removeFeeCreateCommitmentFlat.map((e: any) => Coin.fromJSON(e))
        : [],
      setFeeCommitmentSettlementBips: isSet(object.setFeeCommitmentSettlementBips)
        ? globalThis.Number(object.setFeeCommitmentSettlementBips)
        : 0,
      unsetFeeCommitmentSettlementBips: isSet(object.unsetFeeCommitmentSettlementBips)
        ? globalThis.Boolean(object.unsetFeeCommitmentSettlementBips)
        : false,
    };
  },

  toJSON(message: MsgGovManageFeesRequest): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.addFeeCreateAskFlat?.length) {
      obj.addFeeCreateAskFlat = message.addFeeCreateAskFlat.map((e) => Coin.toJSON(e));
    }
    if (message.removeFeeCreateAskFlat?.length) {
      obj.removeFeeCreateAskFlat = message.removeFeeCreateAskFlat.map((e) => Coin.toJSON(e));
    }
    if (message.addFeeCreateBidFlat?.length) {
      obj.addFeeCreateBidFlat = message.addFeeCreateBidFlat.map((e) => Coin.toJSON(e));
    }
    if (message.removeFeeCreateBidFlat?.length) {
      obj.removeFeeCreateBidFlat = message.removeFeeCreateBidFlat.map((e) => Coin.toJSON(e));
    }
    if (message.addFeeSellerSettlementFlat?.length) {
      obj.addFeeSellerSettlementFlat = message.addFeeSellerSettlementFlat.map((e) => Coin.toJSON(e));
    }
    if (message.removeFeeSellerSettlementFlat?.length) {
      obj.removeFeeSellerSettlementFlat = message.removeFeeSellerSettlementFlat.map((e) => Coin.toJSON(e));
    }
    if (message.addFeeSellerSettlementRatios?.length) {
      obj.addFeeSellerSettlementRatios = message.addFeeSellerSettlementRatios.map((e) => FeeRatio.toJSON(e));
    }
    if (message.removeFeeSellerSettlementRatios?.length) {
      obj.removeFeeSellerSettlementRatios = message.removeFeeSellerSettlementRatios.map((e) => FeeRatio.toJSON(e));
    }
    if (message.addFeeBuyerSettlementFlat?.length) {
      obj.addFeeBuyerSettlementFlat = message.addFeeBuyerSettlementFlat.map((e) => Coin.toJSON(e));
    }
    if (message.removeFeeBuyerSettlementFlat?.length) {
      obj.removeFeeBuyerSettlementFlat = message.removeFeeBuyerSettlementFlat.map((e) => Coin.toJSON(e));
    }
    if (message.addFeeBuyerSettlementRatios?.length) {
      obj.addFeeBuyerSettlementRatios = message.addFeeBuyerSettlementRatios.map((e) => FeeRatio.toJSON(e));
    }
    if (message.removeFeeBuyerSettlementRatios?.length) {
      obj.removeFeeBuyerSettlementRatios = message.removeFeeBuyerSettlementRatios.map((e) => FeeRatio.toJSON(e));
    }
    if (message.addFeeCreateCommitmentFlat?.length) {
      obj.addFeeCreateCommitmentFlat = message.addFeeCreateCommitmentFlat.map((e) => Coin.toJSON(e));
    }
    if (message.removeFeeCreateCommitmentFlat?.length) {
      obj.removeFeeCreateCommitmentFlat = message.removeFeeCreateCommitmentFlat.map((e) => Coin.toJSON(e));
    }
    if (message.setFeeCommitmentSettlementBips !== 0) {
      obj.setFeeCommitmentSettlementBips = Math.round(message.setFeeCommitmentSettlementBips);
    }
    if (message.unsetFeeCommitmentSettlementBips !== false) {
      obj.unsetFeeCommitmentSettlementBips = message.unsetFeeCommitmentSettlementBips;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGovManageFeesRequest>, I>>(base?: I): MsgGovManageFeesRequest {
    return MsgGovManageFeesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGovManageFeesRequest>, I>>(object: I): MsgGovManageFeesRequest {
    const message = createBaseMsgGovManageFeesRequest();
    message.authority = object.authority ?? "";
    message.marketId = object.marketId ?? 0;
    message.addFeeCreateAskFlat = object.addFeeCreateAskFlat?.map((e) => Coin.fromPartial(e)) || [];
    message.removeFeeCreateAskFlat = object.removeFeeCreateAskFlat?.map((e) => Coin.fromPartial(e)) || [];
    message.addFeeCreateBidFlat = object.addFeeCreateBidFlat?.map((e) => Coin.fromPartial(e)) || [];
    message.removeFeeCreateBidFlat = object.removeFeeCreateBidFlat?.map((e) => Coin.fromPartial(e)) || [];
    message.addFeeSellerSettlementFlat = object.addFeeSellerSettlementFlat?.map((e) => Coin.fromPartial(e)) || [];
    message.removeFeeSellerSettlementFlat = object.removeFeeSellerSettlementFlat?.map((e) => Coin.fromPartial(e)) || [];
    message.addFeeSellerSettlementRatios = object.addFeeSellerSettlementRatios?.map((e) => FeeRatio.fromPartial(e)) ||
      [];
    message.removeFeeSellerSettlementRatios =
      object.removeFeeSellerSettlementRatios?.map((e) => FeeRatio.fromPartial(e)) || [];
    message.addFeeBuyerSettlementFlat = object.addFeeBuyerSettlementFlat?.map((e) => Coin.fromPartial(e)) || [];
    message.removeFeeBuyerSettlementFlat = object.removeFeeBuyerSettlementFlat?.map((e) => Coin.fromPartial(e)) || [];
    message.addFeeBuyerSettlementRatios = object.addFeeBuyerSettlementRatios?.map((e) => FeeRatio.fromPartial(e)) || [];
    message.removeFeeBuyerSettlementRatios =
      object.removeFeeBuyerSettlementRatios?.map((e) => FeeRatio.fromPartial(e)) || [];
    message.addFeeCreateCommitmentFlat = object.addFeeCreateCommitmentFlat?.map((e) => Coin.fromPartial(e)) || [];
    message.removeFeeCreateCommitmentFlat = object.removeFeeCreateCommitmentFlat?.map((e) => Coin.fromPartial(e)) || [];
    message.setFeeCommitmentSettlementBips = object.setFeeCommitmentSettlementBips ?? 0;
    message.unsetFeeCommitmentSettlementBips = object.unsetFeeCommitmentSettlementBips ?? false;
    return message;
  },
};

function createBaseMsgGovManageFeesResponse(): MsgGovManageFeesResponse {
  return {};
}

export const MsgGovManageFeesResponse: MessageFns<MsgGovManageFeesResponse> = {
  encode(_: MsgGovManageFeesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGovManageFeesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGovManageFeesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgGovManageFeesResponse {
    return {};
  },

  toJSON(_: MsgGovManageFeesResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGovManageFeesResponse>, I>>(base?: I): MsgGovManageFeesResponse {
    return MsgGovManageFeesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGovManageFeesResponse>, I>>(_: I): MsgGovManageFeesResponse {
    const message = createBaseMsgGovManageFeesResponse();
    return message;
  },
};

function createBaseMsgGovCloseMarketRequest(): MsgGovCloseMarketRequest {
  return { authority: "", marketId: 0 };
}

export const MsgGovCloseMarketRequest: MessageFns<MsgGovCloseMarketRequest> = {
  encode(message: MsgGovCloseMarketRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGovCloseMarketRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGovCloseMarketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGovCloseMarketRequest {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
    };
  },

  toJSON(message: MsgGovCloseMarketRequest): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGovCloseMarketRequest>, I>>(base?: I): MsgGovCloseMarketRequest {
    return MsgGovCloseMarketRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGovCloseMarketRequest>, I>>(object: I): MsgGovCloseMarketRequest {
    const message = createBaseMsgGovCloseMarketRequest();
    message.authority = object.authority ?? "";
    message.marketId = object.marketId ?? 0;
    return message;
  },
};

function createBaseMsgGovCloseMarketResponse(): MsgGovCloseMarketResponse {
  return {};
}

export const MsgGovCloseMarketResponse: MessageFns<MsgGovCloseMarketResponse> = {
  encode(_: MsgGovCloseMarketResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGovCloseMarketResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGovCloseMarketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgGovCloseMarketResponse {
    return {};
  },

  toJSON(_: MsgGovCloseMarketResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGovCloseMarketResponse>, I>>(base?: I): MsgGovCloseMarketResponse {
    return MsgGovCloseMarketResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGovCloseMarketResponse>, I>>(_: I): MsgGovCloseMarketResponse {
    const message = createBaseMsgGovCloseMarketResponse();
    return message;
  },
};

function createBaseMsgGovUpdateParamsRequest(): MsgGovUpdateParamsRequest {
  return { authority: "", params: undefined };
}

export const MsgGovUpdateParamsRequest: MessageFns<MsgGovUpdateParamsRequest> = {
  encode(message: MsgGovUpdateParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGovUpdateParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGovUpdateParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGovUpdateParamsRequest {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgGovUpdateParamsRequest): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGovUpdateParamsRequest>, I>>(base?: I): MsgGovUpdateParamsRequest {
    return MsgGovUpdateParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGovUpdateParamsRequest>, I>>(object: I): MsgGovUpdateParamsRequest {
    const message = createBaseMsgGovUpdateParamsRequest();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgGovUpdateParamsResponse(): MsgGovUpdateParamsResponse {
  return {};
}

export const MsgGovUpdateParamsResponse: MessageFns<MsgGovUpdateParamsResponse> = {
  encode(_: MsgGovUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGovUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGovUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgGovUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgGovUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGovUpdateParamsResponse>, I>>(base?: I): MsgGovUpdateParamsResponse {
    return MsgGovUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGovUpdateParamsResponse>, I>>(_: I): MsgGovUpdateParamsResponse {
    const message = createBaseMsgGovUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgUpdateParamsRequest(): MsgUpdateParamsRequest {
  return { authority: "", params: undefined };
}

export const MsgUpdateParamsRequest: MessageFns<MsgUpdateParamsRequest> = {
  encode(message: MsgUpdateParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParamsRequest {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParamsRequest): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsRequest>, I>>(base?: I): MsgUpdateParamsRequest {
    return MsgUpdateParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsRequest>, I>>(object: I): MsgUpdateParamsRequest {
    const message = createBaseMsgUpdateParamsRequest();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(base?: I): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(_: I): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

/** Msg is the service for exchange module's tx endpoints. */
export interface Msg {
  /** CreateAsk creates an ask order (to sell something you own). */
  CreateAsk(request: MsgCreateAskRequest): Promise<MsgCreateAskResponse>;
  /** CreateBid creates a bid order (to buy something you want). */
  CreateBid(request: MsgCreateBidRequest): Promise<MsgCreateBidResponse>;
  /** CommitFunds marks funds in an account as manageable by a market. */
  CommitFunds(request: MsgCommitFundsRequest): Promise<MsgCommitFundsResponse>;
  /** CancelOrder cancels an order. */
  CancelOrder(request: MsgCancelOrderRequest): Promise<MsgCancelOrderResponse>;
  /** FillBids uses the assets in your account to fulfill one or more bids (similar to a fill-or-cancel ask). */
  FillBids(request: MsgFillBidsRequest): Promise<MsgFillBidsResponse>;
  /** FillAsks uses the funds in your account to fulfill one or more asks (similar to a fill-or-cancel bid). */
  FillAsks(request: MsgFillAsksRequest): Promise<MsgFillAsksResponse>;
  /** MarketSettle is a market endpoint to trigger the settlement of orders. */
  MarketSettle(request: MsgMarketSettleRequest): Promise<MsgMarketSettleResponse>;
  /** MarketCommitmentSettle is a market endpoint to transfer committed funds. */
  MarketCommitmentSettle(request: MsgMarketCommitmentSettleRequest): Promise<MsgMarketCommitmentSettleResponse>;
  /** MarketReleaseCommitments is a market endpoint return control of funds back to the account owner(s). */
  MarketReleaseCommitments(request: MsgMarketReleaseCommitmentsRequest): Promise<MsgMarketReleaseCommitmentsResponse>;
  /** MarketSetOrderExternalID updates an order's external id field. */
  MarketSetOrderExternalID(request: MsgMarketSetOrderExternalIDRequest): Promise<MsgMarketSetOrderExternalIDResponse>;
  /** MarketWithdraw is a market endpoint to withdraw fees that have been collected. */
  MarketWithdraw(request: MsgMarketWithdrawRequest): Promise<MsgMarketWithdrawResponse>;
  /** MarketUpdateDetails is a market endpoint to update its details. */
  MarketUpdateDetails(request: MsgMarketUpdateDetailsRequest): Promise<MsgMarketUpdateDetailsResponse>;
  /**
   * MarketUpdateEnabled is a market endpoint to update whether its accepting orders.
   * Deprecated: This endpoint is no longer usable. It is replaced by MarketUpdateAcceptingOrders.
   *
   * @deprecated
   */
  MarketUpdateEnabled(request: MsgMarketUpdateEnabledRequest): Promise<MsgMarketUpdateEnabledResponse>;
  /** MarketUpdateAcceptingOrders is a market endpoint to update whether its accepting orders. */
  MarketUpdateAcceptingOrders(
    request: MsgMarketUpdateAcceptingOrdersRequest,
  ): Promise<MsgMarketUpdateAcceptingOrdersResponse>;
  /** MarketUpdateUserSettle is a market endpoint to update whether it allows user-initiated settlement. */
  MarketUpdateUserSettle(request: MsgMarketUpdateUserSettleRequest): Promise<MsgMarketUpdateUserSettleResponse>;
  /** MarketUpdateAcceptingCommitments is a market endpoint to update whether it accepts commitments. */
  MarketUpdateAcceptingCommitments(
    request: MsgMarketUpdateAcceptingCommitmentsRequest,
  ): Promise<MsgMarketUpdateAcceptingCommitmentsResponse>;
  /** MarketUpdateIntermediaryDenom sets a market's intermediary denom. */
  MarketUpdateIntermediaryDenom(
    request: MsgMarketUpdateIntermediaryDenomRequest,
  ): Promise<MsgMarketUpdateIntermediaryDenomResponse>;
  /** MarketManagePermissions is a market endpoint to manage a market's user permissions. */
  MarketManagePermissions(request: MsgMarketManagePermissionsRequest): Promise<MsgMarketManagePermissionsResponse>;
  /** MarketManageReqAttrs is a market endpoint to manage the attributes required to interact with it. */
  MarketManageReqAttrs(request: MsgMarketManageReqAttrsRequest): Promise<MsgMarketManageReqAttrsResponse>;
  /** CreatePayment creates a payment to facilitate a trade between two accounts. */
  CreatePayment(request: MsgCreatePaymentRequest): Promise<MsgCreatePaymentResponse>;
  /** AcceptPayment is used by a target to accept a payment. */
  AcceptPayment(request: MsgAcceptPaymentRequest): Promise<MsgAcceptPaymentResponse>;
  /** RejectPayment can be used by a target to reject a payment. */
  RejectPayment(request: MsgRejectPaymentRequest): Promise<MsgRejectPaymentResponse>;
  /** RejectPayments can be used by a target to reject all payments from one or more sources. */
  RejectPayments(request: MsgRejectPaymentsRequest): Promise<MsgRejectPaymentsResponse>;
  /** CancelPayments can be used by a source to cancel one or more payments. */
  CancelPayments(request: MsgCancelPaymentsRequest): Promise<MsgCancelPaymentsResponse>;
  /** ChangePaymentTarget can be used by a source to change the target in one of their payments. */
  ChangePaymentTarget(request: MsgChangePaymentTargetRequest): Promise<MsgChangePaymentTargetResponse>;
  /** GovCreateMarket is a governance proposal endpoint for creating a market. */
  GovCreateMarket(request: MsgGovCreateMarketRequest): Promise<MsgGovCreateMarketResponse>;
  /** GovManageFees is a governance proposal endpoint for updating a market's fees. */
  GovManageFees(request: MsgGovManageFeesRequest): Promise<MsgGovManageFeesResponse>;
  /**
   * GovCloseMarket is a governance proposal endpoint that will disable order and commitment creation,
   * cancel all orders, and release all commitments.
   */
  GovCloseMarket(request: MsgGovCloseMarketRequest): Promise<MsgGovCloseMarketResponse>;
  /**
   * GovUpdateParams is a governance proposal endpoint for updating the exchange module's params.
   * Deprecated: Use UpdateParams instead.
   *
   * @deprecated
   */
  GovUpdateParams(request: MsgGovUpdateParamsRequest): Promise<MsgGovUpdateParamsResponse>;
  /** UpdateParams is a governance proposal endpoint for updating the exchange module's params. */
  UpdateParams(request: MsgUpdateParamsRequest): Promise<MsgUpdateParamsResponse>;
}

export const MsgServiceName = "provenance.exchange.v1.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.CreateAsk = this.CreateAsk.bind(this);
    this.CreateBid = this.CreateBid.bind(this);
    this.CommitFunds = this.CommitFunds.bind(this);
    this.CancelOrder = this.CancelOrder.bind(this);
    this.FillBids = this.FillBids.bind(this);
    this.FillAsks = this.FillAsks.bind(this);
    this.MarketSettle = this.MarketSettle.bind(this);
    this.MarketCommitmentSettle = this.MarketCommitmentSettle.bind(this);
    this.MarketReleaseCommitments = this.MarketReleaseCommitments.bind(this);
    this.MarketSetOrderExternalID = this.MarketSetOrderExternalID.bind(this);
    this.MarketWithdraw = this.MarketWithdraw.bind(this);
    this.MarketUpdateDetails = this.MarketUpdateDetails.bind(this);
    this.MarketUpdateEnabled = this.MarketUpdateEnabled.bind(this);
    this.MarketUpdateAcceptingOrders = this.MarketUpdateAcceptingOrders.bind(this);
    this.MarketUpdateUserSettle = this.MarketUpdateUserSettle.bind(this);
    this.MarketUpdateAcceptingCommitments = this.MarketUpdateAcceptingCommitments.bind(this);
    this.MarketUpdateIntermediaryDenom = this.MarketUpdateIntermediaryDenom.bind(this);
    this.MarketManagePermissions = this.MarketManagePermissions.bind(this);
    this.MarketManageReqAttrs = this.MarketManageReqAttrs.bind(this);
    this.CreatePayment = this.CreatePayment.bind(this);
    this.AcceptPayment = this.AcceptPayment.bind(this);
    this.RejectPayment = this.RejectPayment.bind(this);
    this.RejectPayments = this.RejectPayments.bind(this);
    this.CancelPayments = this.CancelPayments.bind(this);
    this.ChangePaymentTarget = this.ChangePaymentTarget.bind(this);
    this.GovCreateMarket = this.GovCreateMarket.bind(this);
    this.GovManageFees = this.GovManageFees.bind(this);
    this.GovCloseMarket = this.GovCloseMarket.bind(this);
    this.GovUpdateParams = this.GovUpdateParams.bind(this);
    this.UpdateParams = this.UpdateParams.bind(this);
  }
  CreateAsk(request: MsgCreateAskRequest): Promise<MsgCreateAskResponse> {
    const data = MsgCreateAskRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateAsk", data);
    return promise.then((data) => MsgCreateAskResponse.decode(new BinaryReader(data)));
  }

  CreateBid(request: MsgCreateBidRequest): Promise<MsgCreateBidResponse> {
    const data = MsgCreateBidRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateBid", data);
    return promise.then((data) => MsgCreateBidResponse.decode(new BinaryReader(data)));
  }

  CommitFunds(request: MsgCommitFundsRequest): Promise<MsgCommitFundsResponse> {
    const data = MsgCommitFundsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CommitFunds", data);
    return promise.then((data) => MsgCommitFundsResponse.decode(new BinaryReader(data)));
  }

  CancelOrder(request: MsgCancelOrderRequest): Promise<MsgCancelOrderResponse> {
    const data = MsgCancelOrderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CancelOrder", data);
    return promise.then((data) => MsgCancelOrderResponse.decode(new BinaryReader(data)));
  }

  FillBids(request: MsgFillBidsRequest): Promise<MsgFillBidsResponse> {
    const data = MsgFillBidsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FillBids", data);
    return promise.then((data) => MsgFillBidsResponse.decode(new BinaryReader(data)));
  }

  FillAsks(request: MsgFillAsksRequest): Promise<MsgFillAsksResponse> {
    const data = MsgFillAsksRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FillAsks", data);
    return promise.then((data) => MsgFillAsksResponse.decode(new BinaryReader(data)));
  }

  MarketSettle(request: MsgMarketSettleRequest): Promise<MsgMarketSettleResponse> {
    const data = MsgMarketSettleRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MarketSettle", data);
    return promise.then((data) => MsgMarketSettleResponse.decode(new BinaryReader(data)));
  }

  MarketCommitmentSettle(request: MsgMarketCommitmentSettleRequest): Promise<MsgMarketCommitmentSettleResponse> {
    const data = MsgMarketCommitmentSettleRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MarketCommitmentSettle", data);
    return promise.then((data) => MsgMarketCommitmentSettleResponse.decode(new BinaryReader(data)));
  }

  MarketReleaseCommitments(request: MsgMarketReleaseCommitmentsRequest): Promise<MsgMarketReleaseCommitmentsResponse> {
    const data = MsgMarketReleaseCommitmentsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MarketReleaseCommitments", data);
    return promise.then((data) => MsgMarketReleaseCommitmentsResponse.decode(new BinaryReader(data)));
  }

  MarketSetOrderExternalID(request: MsgMarketSetOrderExternalIDRequest): Promise<MsgMarketSetOrderExternalIDResponse> {
    const data = MsgMarketSetOrderExternalIDRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MarketSetOrderExternalID", data);
    return promise.then((data) => MsgMarketSetOrderExternalIDResponse.decode(new BinaryReader(data)));
  }

  MarketWithdraw(request: MsgMarketWithdrawRequest): Promise<MsgMarketWithdrawResponse> {
    const data = MsgMarketWithdrawRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MarketWithdraw", data);
    return promise.then((data) => MsgMarketWithdrawResponse.decode(new BinaryReader(data)));
  }

  MarketUpdateDetails(request: MsgMarketUpdateDetailsRequest): Promise<MsgMarketUpdateDetailsResponse> {
    const data = MsgMarketUpdateDetailsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MarketUpdateDetails", data);
    return promise.then((data) => MsgMarketUpdateDetailsResponse.decode(new BinaryReader(data)));
  }

  MarketUpdateEnabled(request: MsgMarketUpdateEnabledRequest): Promise<MsgMarketUpdateEnabledResponse> {
    const data = MsgMarketUpdateEnabledRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MarketUpdateEnabled", data);
    return promise.then((data) => MsgMarketUpdateEnabledResponse.decode(new BinaryReader(data)));
  }

  MarketUpdateAcceptingOrders(
    request: MsgMarketUpdateAcceptingOrdersRequest,
  ): Promise<MsgMarketUpdateAcceptingOrdersResponse> {
    const data = MsgMarketUpdateAcceptingOrdersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MarketUpdateAcceptingOrders", data);
    return promise.then((data) => MsgMarketUpdateAcceptingOrdersResponse.decode(new BinaryReader(data)));
  }

  MarketUpdateUserSettle(request: MsgMarketUpdateUserSettleRequest): Promise<MsgMarketUpdateUserSettleResponse> {
    const data = MsgMarketUpdateUserSettleRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MarketUpdateUserSettle", data);
    return promise.then((data) => MsgMarketUpdateUserSettleResponse.decode(new BinaryReader(data)));
  }

  MarketUpdateAcceptingCommitments(
    request: MsgMarketUpdateAcceptingCommitmentsRequest,
  ): Promise<MsgMarketUpdateAcceptingCommitmentsResponse> {
    const data = MsgMarketUpdateAcceptingCommitmentsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MarketUpdateAcceptingCommitments", data);
    return promise.then((data) => MsgMarketUpdateAcceptingCommitmentsResponse.decode(new BinaryReader(data)));
  }

  MarketUpdateIntermediaryDenom(
    request: MsgMarketUpdateIntermediaryDenomRequest,
  ): Promise<MsgMarketUpdateIntermediaryDenomResponse> {
    const data = MsgMarketUpdateIntermediaryDenomRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MarketUpdateIntermediaryDenom", data);
    return promise.then((data) => MsgMarketUpdateIntermediaryDenomResponse.decode(new BinaryReader(data)));
  }

  MarketManagePermissions(request: MsgMarketManagePermissionsRequest): Promise<MsgMarketManagePermissionsResponse> {
    const data = MsgMarketManagePermissionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MarketManagePermissions", data);
    return promise.then((data) => MsgMarketManagePermissionsResponse.decode(new BinaryReader(data)));
  }

  MarketManageReqAttrs(request: MsgMarketManageReqAttrsRequest): Promise<MsgMarketManageReqAttrsResponse> {
    const data = MsgMarketManageReqAttrsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "MarketManageReqAttrs", data);
    return promise.then((data) => MsgMarketManageReqAttrsResponse.decode(new BinaryReader(data)));
  }

  CreatePayment(request: MsgCreatePaymentRequest): Promise<MsgCreatePaymentResponse> {
    const data = MsgCreatePaymentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreatePayment", data);
    return promise.then((data) => MsgCreatePaymentResponse.decode(new BinaryReader(data)));
  }

  AcceptPayment(request: MsgAcceptPaymentRequest): Promise<MsgAcceptPaymentResponse> {
    const data = MsgAcceptPaymentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AcceptPayment", data);
    return promise.then((data) => MsgAcceptPaymentResponse.decode(new BinaryReader(data)));
  }

  RejectPayment(request: MsgRejectPaymentRequest): Promise<MsgRejectPaymentResponse> {
    const data = MsgRejectPaymentRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RejectPayment", data);
    return promise.then((data) => MsgRejectPaymentResponse.decode(new BinaryReader(data)));
  }

  RejectPayments(request: MsgRejectPaymentsRequest): Promise<MsgRejectPaymentsResponse> {
    const data = MsgRejectPaymentsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RejectPayments", data);
    return promise.then((data) => MsgRejectPaymentsResponse.decode(new BinaryReader(data)));
  }

  CancelPayments(request: MsgCancelPaymentsRequest): Promise<MsgCancelPaymentsResponse> {
    const data = MsgCancelPaymentsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CancelPayments", data);
    return promise.then((data) => MsgCancelPaymentsResponse.decode(new BinaryReader(data)));
  }

  ChangePaymentTarget(request: MsgChangePaymentTargetRequest): Promise<MsgChangePaymentTargetResponse> {
    const data = MsgChangePaymentTargetRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ChangePaymentTarget", data);
    return promise.then((data) => MsgChangePaymentTargetResponse.decode(new BinaryReader(data)));
  }

  GovCreateMarket(request: MsgGovCreateMarketRequest): Promise<MsgGovCreateMarketResponse> {
    const data = MsgGovCreateMarketRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GovCreateMarket", data);
    return promise.then((data) => MsgGovCreateMarketResponse.decode(new BinaryReader(data)));
  }

  GovManageFees(request: MsgGovManageFeesRequest): Promise<MsgGovManageFeesResponse> {
    const data = MsgGovManageFeesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GovManageFees", data);
    return promise.then((data) => MsgGovManageFeesResponse.decode(new BinaryReader(data)));
  }

  GovCloseMarket(request: MsgGovCloseMarketRequest): Promise<MsgGovCloseMarketResponse> {
    const data = MsgGovCloseMarketRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GovCloseMarket", data);
    return promise.then((data) => MsgGovCloseMarketResponse.decode(new BinaryReader(data)));
  }

  GovUpdateParams(request: MsgGovUpdateParamsRequest): Promise<MsgGovUpdateParamsResponse> {
    const data = MsgGovUpdateParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GovUpdateParams", data);
    return promise.then((data) => MsgGovUpdateParamsResponse.decode(new BinaryReader(data)));
  }

  UpdateParams(request: MsgUpdateParamsRequest): Promise<MsgUpdateParamsResponse> {
    const data = MsgUpdateParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateParams", data);
    return promise.then((data) => MsgUpdateParamsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
