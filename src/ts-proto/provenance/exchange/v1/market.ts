// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: provenance/exchange/v1/market.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { BaseAccount } from "../../../cosmos/auth/v1beta1/auth";
import { Coin } from "../../../cosmos/base/v1beta1/coin";

export const protobufPackage = "provenance.exchange.v1";

/** Permission defines the different types of permission that can be given to an account for a market. */
export enum Permission {
  /** PERMISSION_UNSPECIFIED - PERMISSION_UNSPECIFIED is the zero-value Permission; it is an error to use it. */
  PERMISSION_UNSPECIFIED = 0,
  /** PERMISSION_SETTLE - PERMISSION_SETTLE is the ability to use the Settle Tx endpoint on behalf of a market. */
  PERMISSION_SETTLE = 1,
  /** PERMISSION_SET_IDS - PERMISSION_SET_IDS is the ability to use the SetOrderExternalID Tx endpoint on behalf of a market. */
  PERMISSION_SET_IDS = 2,
  /** PERMISSION_CANCEL - PERMISSION_CANCEL is the ability to use the Cancel Tx endpoint on behalf of a market. */
  PERMISSION_CANCEL = 3,
  /** PERMISSION_WITHDRAW - PERMISSION_WITHDRAW is the ability to use the MarketWithdraw Tx endpoint. */
  PERMISSION_WITHDRAW = 4,
  /** PERMISSION_UPDATE - PERMISSION_UPDATE is the ability to use the MarketUpdate* Tx endpoints. */
  PERMISSION_UPDATE = 5,
  /** PERMISSION_PERMISSIONS - PERMISSION_PERMISSIONS is the ability to use the MarketManagePermissions Tx endpoint. */
  PERMISSION_PERMISSIONS = 6,
  /** PERMISSION_ATTRIBUTES - PERMISSION_ATTRIBUTES is the ability to use the MarketManageReqAttrs Tx endpoint. */
  PERMISSION_ATTRIBUTES = 7,
  UNRECOGNIZED = -1,
}

export function permissionFromJSON(object: any): Permission {
  switch (object) {
    case 0:
    case "PERMISSION_UNSPECIFIED":
      return Permission.PERMISSION_UNSPECIFIED;
    case 1:
    case "PERMISSION_SETTLE":
      return Permission.PERMISSION_SETTLE;
    case 2:
    case "PERMISSION_SET_IDS":
      return Permission.PERMISSION_SET_IDS;
    case 3:
    case "PERMISSION_CANCEL":
      return Permission.PERMISSION_CANCEL;
    case 4:
    case "PERMISSION_WITHDRAW":
      return Permission.PERMISSION_WITHDRAW;
    case 5:
    case "PERMISSION_UPDATE":
      return Permission.PERMISSION_UPDATE;
    case 6:
    case "PERMISSION_PERMISSIONS":
      return Permission.PERMISSION_PERMISSIONS;
    case 7:
    case "PERMISSION_ATTRIBUTES":
      return Permission.PERMISSION_ATTRIBUTES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Permission.UNRECOGNIZED;
  }
}

export function permissionToJSON(object: Permission): string {
  switch (object) {
    case Permission.PERMISSION_UNSPECIFIED:
      return "PERMISSION_UNSPECIFIED";
    case Permission.PERMISSION_SETTLE:
      return "PERMISSION_SETTLE";
    case Permission.PERMISSION_SET_IDS:
      return "PERMISSION_SET_IDS";
    case Permission.PERMISSION_CANCEL:
      return "PERMISSION_CANCEL";
    case Permission.PERMISSION_WITHDRAW:
      return "PERMISSION_WITHDRAW";
    case Permission.PERMISSION_UPDATE:
      return "PERMISSION_UPDATE";
    case Permission.PERMISSION_PERMISSIONS:
      return "PERMISSION_PERMISSIONS";
    case Permission.PERMISSION_ATTRIBUTES:
      return "PERMISSION_ATTRIBUTES";
    case Permission.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** MarketAccount is an account type for use with the accounts module to hold some basic information about a market. */
export interface MarketAccount {
  /** base_account is the base cosmos account information. */
  baseAccount?:
    | BaseAccount
    | undefined;
  /** market_id is the numerical identifier for this market. */
  marketId: number;
  /** market_details is some human-consumable information about this market. */
  marketDetails?: MarketDetails | undefined;
}

/** MarketDetails contains information about a market. */
export interface MarketDetails {
  /** name is a moniker that people can use to refer to this market. */
  name: string;
  /** description extra information about this market. The field is meant to be human-readable. */
  description: string;
  /** website_url is a url people can use to get to this market, or at least get more information about this market. */
  websiteUrl: string;
  /** icon_uri is a uri for an icon to associate with this market. */
  iconUri: string;
}

/** MarketBrief is a message containing brief, superficial information about a market. */
export interface MarketBrief {
  /** market_id is the numerical identifier for this market. */
  marketId: number;
  /** market_address is the bech32 address string of this market's account. */
  marketAddress: string;
  /** market_details is some information about this market. */
  marketDetails?: MarketDetails | undefined;
}

/** Market contains all information about a market. */
export interface Market {
  /** market_id is the numerical identifier for this market. */
  marketId: number;
  /** market_details is some information about this market. */
  marketDetails?:
    | MarketDetails
    | undefined;
  /**
   * fee_create_ask_flat is the flat fee charged for creating an ask order.
   * Each coin entry is a separate option. When an ask is created, one of these must be paid.
   * If empty, no fee is required to create an ask order.
   */
  feeCreateAskFlat: Coin[];
  /**
   * fee_create_bid_flat is the flat fee charged for creating a bid order.
   * Each coin entry is a separate option. When a bid is created, one of these must be paid.
   * If empty, no fee is required to create a bid order.
   */
  feeCreateBidFlat: Coin[];
  /**
   * fee_seller_settlement_flat is the flat fee charged to the seller during settlement.
   * Each coin entry is a separate option.
   * When an ask is settled, the seller will pay the amount in the denom that matches the price they received.
   */
  feeSellerSettlementFlat: Coin[];
  /**
   * fee_seller_settlement_ratios is the fee to charge a seller during settlement based on the price they are receiving.
   * The price and fee denoms must be equal for each entry, and only one entry for any given denom is allowed.
   */
  feeSellerSettlementRatios: FeeRatio[];
  /**
   * fee_buyer_settlement_flat is the flat fee charged to the buyer during settlement.
   * Each coin entry is a separate option.
   * When a bid is created, the settlement fees provided must contain one of these.
   */
  feeBuyerSettlementFlat: Coin[];
  /**
   * fee_buyer_settlement_ratios is the fee to charge a buyer during settlement based on the price they are spending.
   * The price and fee denoms do not have to equal. Multiple entries for any given price or fee denom are allowed, but
   * each price denom to fee denom pair can only have one entry.
   */
  feeBuyerSettlementRatios: FeeRatio[];
  /** accepting_orders is whether this market is allowing orders to be created for it. */
  acceptingOrders: boolean;
  /**
   * allow_user_settlement is whether this market allows users to initiate their own settlements.
   * For example, the FillBids and FillAsks endpoints are available if and only if this is true.
   * The MarketSettle endpoint is only available to market actors regardless of the value of this field.
   */
  allowUserSettlement: boolean;
  /** access_grants is the list of addresses and permissions granted for this market. */
  accessGrants: AccessGrant[];
  /**
   * req_attr_create_ask is a list of attributes required on an account for it to be allowed to create an ask order.
   * An account must have all of these attributes in order to create an ask order in this market.
   * If the list is empty, any account can create ask orders in this market.
   *
   * An entry that starts with "*." will match any attributes that end with the rest of it.
   * E.g. "*.b.a" will match all of "c.b.a", "x.b.a", and "e.d.c.b.a"; but not "b.a", "xb.a", "b.x.a", or "c.b.a.x".
   */
  reqAttrCreateAsk: string[];
  /**
   * req_attr_create_ask is a list of attributes required on an account for it to be allowed to create a bid order.
   * An account must have all of these attributes in order to create a bid order in this market.
   * If the list is empty, any account can create bid orders in this market.
   *
   * An entry that starts with "*." will match any attributes that end with the rest of it.
   * E.g. "*.b.a" will match all of "c.b.a", "x.b.a", and "e.d.c.b.a"; but not "b.a", "xb.a", "c.b.x.a", or "c.b.a.x".
   */
  reqAttrCreateBid: string[];
  /** accepting_commitments is whether the market is allowing users to commit funds to it. */
  acceptingCommitments: boolean;
  /**
   * fee_create_commitment_flat is the flat fee charged for creating a commitment.
   * Each coin entry is a separate option. When a commitment is created, one of these must be paid.
   * If empty, no fee is required to create a commitment.
   */
  feeCreateCommitmentFlat: Coin[];
  /**
   * commitment_settlement_bips is the fraction of a commitment settlement that will be paid to the exchange.
   * It is represented in basis points (1/100th of 1%, e.g. 0.0001) and is limited to 0 to 10,000 inclusive.
   * During a commitment settlement, the inputs are summed and NAVs are used to convert that total to the
   * intermediary denom, then to the fee denom. That is then multiplied by this value to get the fee amount
   * that will be transferred out of the market's account into the exchange for that settlement.
   *
   * Summing the inputs effectively doubles the value of the settlement from what what is usually thought of
   * as the value of a trade. That should be taken into account when setting this value.
   * E.g. if two accounts are trading 10apples for 100grapes, the inputs total will be 10apples,100grapes
   * (which might then be converted to USD then nhash before applying this ratio); Usually, though, the value
   * of that trade would be viewed as either just 10apples or just 100grapes.
   */
  commitmentSettlementBips: number;
  /**
   * intermediary_denom is the denom that funds get converted to (before being converted to the chain's fee denom)
   * when calculating the fees that are paid to the exchange. NAVs are used for this conversion and actions will fail
   * if a NAV is needed but not available.
   */
  intermediaryDenom: string;
  /**
   * req_attr_create_commitment is a list of attributes required on an account for it to be allowed to create a
   * commitment. An account must have all of these attributes in order to create a commitment in this market.
   * If the list is empty, any account can create commitments in this market.
   *
   * An entry that starts with "*." will match any attributes that end with the rest of it.
   * E.g. "*.b.a" will match all of "c.b.a", "x.b.a", and "e.d.c.b.a"; but not "b.a", "xb.a", "c.b.x.a", or "c.b.a.x".
   */
  reqAttrCreateCommitment: string[];
}

/**
 * FeeRatio defines a ratio of price amount to fee amount.
 * For an order to be valid, its price must be evenly divisible by a FeeRatio's price.
 */
export interface FeeRatio {
  /** price is the unit the order price is divided by to get how much of the fee should apply. */
  price?:
    | Coin
    | undefined;
  /** fee is the amount to charge per price unit. */
  fee?: Coin | undefined;
}

/** AddrPermissions associates an address with a list of permissions available for that address. */
export interface AccessGrant {
  /** address is the address that these permissions apply to. */
  address: string;
  /** allowed is the list of permissions available for the address. */
  permissions: Permission[];
}

function createBaseMarketAccount(): MarketAccount {
  return { baseAccount: undefined, marketId: 0, marketDetails: undefined };
}

export const MarketAccount: MessageFns<MarketAccount> = {
  encode(message: MarketAccount, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseAccount !== undefined) {
      BaseAccount.encode(message.baseAccount, writer.uint32(10).fork()).join();
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    if (message.marketDetails !== undefined) {
      MarketDetails.encode(message.marketDetails, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketAccount {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketAccount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseAccount = BaseAccount.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.marketDetails = MarketDetails.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarketAccount {
    return {
      baseAccount: isSet(object.baseAccount) ? BaseAccount.fromJSON(object.baseAccount) : undefined,
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      marketDetails: isSet(object.marketDetails) ? MarketDetails.fromJSON(object.marketDetails) : undefined,
    };
  },

  toJSON(message: MarketAccount): unknown {
    const obj: any = {};
    if (message.baseAccount !== undefined) {
      obj.baseAccount = BaseAccount.toJSON(message.baseAccount);
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.marketDetails !== undefined) {
      obj.marketDetails = MarketDetails.toJSON(message.marketDetails);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketAccount>, I>>(base?: I): MarketAccount {
    return MarketAccount.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketAccount>, I>>(object: I): MarketAccount {
    const message = createBaseMarketAccount();
    message.baseAccount = (object.baseAccount !== undefined && object.baseAccount !== null)
      ? BaseAccount.fromPartial(object.baseAccount)
      : undefined;
    message.marketId = object.marketId ?? 0;
    message.marketDetails = (object.marketDetails !== undefined && object.marketDetails !== null)
      ? MarketDetails.fromPartial(object.marketDetails)
      : undefined;
    return message;
  },
};

function createBaseMarketDetails(): MarketDetails {
  return { name: "", description: "", websiteUrl: "", iconUri: "" };
}

export const MarketDetails: MessageFns<MarketDetails> = {
  encode(message: MarketDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.websiteUrl !== "") {
      writer.uint32(26).string(message.websiteUrl);
    }
    if (message.iconUri !== "") {
      writer.uint32(34).string(message.iconUri);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.websiteUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.iconUri = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarketDetails {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      websiteUrl: isSet(object.websiteUrl) ? globalThis.String(object.websiteUrl) : "",
      iconUri: isSet(object.iconUri) ? globalThis.String(object.iconUri) : "",
    };
  },

  toJSON(message: MarketDetails): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.websiteUrl !== "") {
      obj.websiteUrl = message.websiteUrl;
    }
    if (message.iconUri !== "") {
      obj.iconUri = message.iconUri;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketDetails>, I>>(base?: I): MarketDetails {
    return MarketDetails.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketDetails>, I>>(object: I): MarketDetails {
    const message = createBaseMarketDetails();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.websiteUrl = object.websiteUrl ?? "";
    message.iconUri = object.iconUri ?? "";
    return message;
  },
};

function createBaseMarketBrief(): MarketBrief {
  return { marketId: 0, marketAddress: "", marketDetails: undefined };
}

export const MarketBrief: MessageFns<MarketBrief> = {
  encode(message: MarketBrief, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.marketAddress !== "") {
      writer.uint32(18).string(message.marketAddress);
    }
    if (message.marketDetails !== undefined) {
      MarketDetails.encode(message.marketDetails, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketBrief {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketBrief();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.marketAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.marketDetails = MarketDetails.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarketBrief {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      marketAddress: isSet(object.marketAddress) ? globalThis.String(object.marketAddress) : "",
      marketDetails: isSet(object.marketDetails) ? MarketDetails.fromJSON(object.marketDetails) : undefined,
    };
  },

  toJSON(message: MarketBrief): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.marketAddress !== "") {
      obj.marketAddress = message.marketAddress;
    }
    if (message.marketDetails !== undefined) {
      obj.marketDetails = MarketDetails.toJSON(message.marketDetails);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarketBrief>, I>>(base?: I): MarketBrief {
    return MarketBrief.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarketBrief>, I>>(object: I): MarketBrief {
    const message = createBaseMarketBrief();
    message.marketId = object.marketId ?? 0;
    message.marketAddress = object.marketAddress ?? "";
    message.marketDetails = (object.marketDetails !== undefined && object.marketDetails !== null)
      ? MarketDetails.fromPartial(object.marketDetails)
      : undefined;
    return message;
  },
};

function createBaseMarket(): Market {
  return {
    marketId: 0,
    marketDetails: undefined,
    feeCreateAskFlat: [],
    feeCreateBidFlat: [],
    feeSellerSettlementFlat: [],
    feeSellerSettlementRatios: [],
    feeBuyerSettlementFlat: [],
    feeBuyerSettlementRatios: [],
    acceptingOrders: false,
    allowUserSettlement: false,
    accessGrants: [],
    reqAttrCreateAsk: [],
    reqAttrCreateBid: [],
    acceptingCommitments: false,
    feeCreateCommitmentFlat: [],
    commitmentSettlementBips: 0,
    intermediaryDenom: "",
    reqAttrCreateCommitment: [],
  };
}

export const Market: MessageFns<Market> = {
  encode(message: Market, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.marketDetails !== undefined) {
      MarketDetails.encode(message.marketDetails, writer.uint32(18).fork()).join();
    }
    for (const v of message.feeCreateAskFlat) {
      Coin.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.feeCreateBidFlat) {
      Coin.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.feeSellerSettlementFlat) {
      Coin.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.feeSellerSettlementRatios) {
      FeeRatio.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.feeBuyerSettlementFlat) {
      Coin.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.feeBuyerSettlementRatios) {
      FeeRatio.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.acceptingOrders !== false) {
      writer.uint32(72).bool(message.acceptingOrders);
    }
    if (message.allowUserSettlement !== false) {
      writer.uint32(80).bool(message.allowUserSettlement);
    }
    for (const v of message.accessGrants) {
      AccessGrant.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.reqAttrCreateAsk) {
      writer.uint32(98).string(v!);
    }
    for (const v of message.reqAttrCreateBid) {
      writer.uint32(106).string(v!);
    }
    if (message.acceptingCommitments !== false) {
      writer.uint32(112).bool(message.acceptingCommitments);
    }
    for (const v of message.feeCreateCommitmentFlat) {
      Coin.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.commitmentSettlementBips !== 0) {
      writer.uint32(128).uint32(message.commitmentSettlementBips);
    }
    if (message.intermediaryDenom !== "") {
      writer.uint32(138).string(message.intermediaryDenom);
    }
    for (const v of message.reqAttrCreateCommitment) {
      writer.uint32(146).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Market {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarket();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.marketDetails = MarketDetails.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.feeCreateAskFlat.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.feeCreateBidFlat.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.feeSellerSettlementFlat.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.feeSellerSettlementRatios.push(FeeRatio.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.feeBuyerSettlementFlat.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.feeBuyerSettlementRatios.push(FeeRatio.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.acceptingOrders = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.allowUserSettlement = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.accessGrants.push(AccessGrant.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.reqAttrCreateAsk.push(reader.string());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.reqAttrCreateBid.push(reader.string());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.acceptingCommitments = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.feeCreateCommitmentFlat.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.commitmentSettlementBips = reader.uint32();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.intermediaryDenom = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.reqAttrCreateCommitment.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Market {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      marketDetails: isSet(object.marketDetails) ? MarketDetails.fromJSON(object.marketDetails) : undefined,
      feeCreateAskFlat: globalThis.Array.isArray(object?.feeCreateAskFlat)
        ? object.feeCreateAskFlat.map((e: any) => Coin.fromJSON(e))
        : [],
      feeCreateBidFlat: globalThis.Array.isArray(object?.feeCreateBidFlat)
        ? object.feeCreateBidFlat.map((e: any) => Coin.fromJSON(e))
        : [],
      feeSellerSettlementFlat: globalThis.Array.isArray(object?.feeSellerSettlementFlat)
        ? object.feeSellerSettlementFlat.map((e: any) => Coin.fromJSON(e))
        : [],
      feeSellerSettlementRatios: globalThis.Array.isArray(object?.feeSellerSettlementRatios)
        ? object.feeSellerSettlementRatios.map((e: any) => FeeRatio.fromJSON(e))
        : [],
      feeBuyerSettlementFlat: globalThis.Array.isArray(object?.feeBuyerSettlementFlat)
        ? object.feeBuyerSettlementFlat.map((e: any) => Coin.fromJSON(e))
        : [],
      feeBuyerSettlementRatios: globalThis.Array.isArray(object?.feeBuyerSettlementRatios)
        ? object.feeBuyerSettlementRatios.map((e: any) => FeeRatio.fromJSON(e))
        : [],
      acceptingOrders: isSet(object.acceptingOrders) ? globalThis.Boolean(object.acceptingOrders) : false,
      allowUserSettlement: isSet(object.allowUserSettlement) ? globalThis.Boolean(object.allowUserSettlement) : false,
      accessGrants: globalThis.Array.isArray(object?.accessGrants)
        ? object.accessGrants.map((e: any) => AccessGrant.fromJSON(e))
        : [],
      reqAttrCreateAsk: globalThis.Array.isArray(object?.reqAttrCreateAsk)
        ? object.reqAttrCreateAsk.map((e: any) => globalThis.String(e))
        : [],
      reqAttrCreateBid: globalThis.Array.isArray(object?.reqAttrCreateBid)
        ? object.reqAttrCreateBid.map((e: any) => globalThis.String(e))
        : [],
      acceptingCommitments: isSet(object.acceptingCommitments)
        ? globalThis.Boolean(object.acceptingCommitments)
        : false,
      feeCreateCommitmentFlat: globalThis.Array.isArray(object?.feeCreateCommitmentFlat)
        ? object.feeCreateCommitmentFlat.map((e: any) => Coin.fromJSON(e))
        : [],
      commitmentSettlementBips: isSet(object.commitmentSettlementBips)
        ? globalThis.Number(object.commitmentSettlementBips)
        : 0,
      intermediaryDenom: isSet(object.intermediaryDenom) ? globalThis.String(object.intermediaryDenom) : "",
      reqAttrCreateCommitment: globalThis.Array.isArray(object?.reqAttrCreateCommitment)
        ? object.reqAttrCreateCommitment.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Market): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.marketDetails !== undefined) {
      obj.marketDetails = MarketDetails.toJSON(message.marketDetails);
    }
    if (message.feeCreateAskFlat?.length) {
      obj.feeCreateAskFlat = message.feeCreateAskFlat.map((e) => Coin.toJSON(e));
    }
    if (message.feeCreateBidFlat?.length) {
      obj.feeCreateBidFlat = message.feeCreateBidFlat.map((e) => Coin.toJSON(e));
    }
    if (message.feeSellerSettlementFlat?.length) {
      obj.feeSellerSettlementFlat = message.feeSellerSettlementFlat.map((e) => Coin.toJSON(e));
    }
    if (message.feeSellerSettlementRatios?.length) {
      obj.feeSellerSettlementRatios = message.feeSellerSettlementRatios.map((e) => FeeRatio.toJSON(e));
    }
    if (message.feeBuyerSettlementFlat?.length) {
      obj.feeBuyerSettlementFlat = message.feeBuyerSettlementFlat.map((e) => Coin.toJSON(e));
    }
    if (message.feeBuyerSettlementRatios?.length) {
      obj.feeBuyerSettlementRatios = message.feeBuyerSettlementRatios.map((e) => FeeRatio.toJSON(e));
    }
    if (message.acceptingOrders !== false) {
      obj.acceptingOrders = message.acceptingOrders;
    }
    if (message.allowUserSettlement !== false) {
      obj.allowUserSettlement = message.allowUserSettlement;
    }
    if (message.accessGrants?.length) {
      obj.accessGrants = message.accessGrants.map((e) => AccessGrant.toJSON(e));
    }
    if (message.reqAttrCreateAsk?.length) {
      obj.reqAttrCreateAsk = message.reqAttrCreateAsk;
    }
    if (message.reqAttrCreateBid?.length) {
      obj.reqAttrCreateBid = message.reqAttrCreateBid;
    }
    if (message.acceptingCommitments !== false) {
      obj.acceptingCommitments = message.acceptingCommitments;
    }
    if (message.feeCreateCommitmentFlat?.length) {
      obj.feeCreateCommitmentFlat = message.feeCreateCommitmentFlat.map((e) => Coin.toJSON(e));
    }
    if (message.commitmentSettlementBips !== 0) {
      obj.commitmentSettlementBips = Math.round(message.commitmentSettlementBips);
    }
    if (message.intermediaryDenom !== "") {
      obj.intermediaryDenom = message.intermediaryDenom;
    }
    if (message.reqAttrCreateCommitment?.length) {
      obj.reqAttrCreateCommitment = message.reqAttrCreateCommitment;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Market>, I>>(base?: I): Market {
    return Market.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Market>, I>>(object: I): Market {
    const message = createBaseMarket();
    message.marketId = object.marketId ?? 0;
    message.marketDetails = (object.marketDetails !== undefined && object.marketDetails !== null)
      ? MarketDetails.fromPartial(object.marketDetails)
      : undefined;
    message.feeCreateAskFlat = object.feeCreateAskFlat?.map((e) => Coin.fromPartial(e)) || [];
    message.feeCreateBidFlat = object.feeCreateBidFlat?.map((e) => Coin.fromPartial(e)) || [];
    message.feeSellerSettlementFlat = object.feeSellerSettlementFlat?.map((e) => Coin.fromPartial(e)) || [];
    message.feeSellerSettlementRatios = object.feeSellerSettlementRatios?.map((e) => FeeRatio.fromPartial(e)) || [];
    message.feeBuyerSettlementFlat = object.feeBuyerSettlementFlat?.map((e) => Coin.fromPartial(e)) || [];
    message.feeBuyerSettlementRatios = object.feeBuyerSettlementRatios?.map((e) => FeeRatio.fromPartial(e)) || [];
    message.acceptingOrders = object.acceptingOrders ?? false;
    message.allowUserSettlement = object.allowUserSettlement ?? false;
    message.accessGrants = object.accessGrants?.map((e) => AccessGrant.fromPartial(e)) || [];
    message.reqAttrCreateAsk = object.reqAttrCreateAsk?.map((e) => e) || [];
    message.reqAttrCreateBid = object.reqAttrCreateBid?.map((e) => e) || [];
    message.acceptingCommitments = object.acceptingCommitments ?? false;
    message.feeCreateCommitmentFlat = object.feeCreateCommitmentFlat?.map((e) => Coin.fromPartial(e)) || [];
    message.commitmentSettlementBips = object.commitmentSettlementBips ?? 0;
    message.intermediaryDenom = object.intermediaryDenom ?? "";
    message.reqAttrCreateCommitment = object.reqAttrCreateCommitment?.map((e) => e) || [];
    return message;
  },
};

function createBaseFeeRatio(): FeeRatio {
  return { price: undefined, fee: undefined };
}

export const FeeRatio: MessageFns<FeeRatio> = {
  encode(message: FeeRatio, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.price !== undefined) {
      Coin.encode(message.price, writer.uint32(10).fork()).join();
    }
    if (message.fee !== undefined) {
      Coin.encode(message.fee, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FeeRatio {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFeeRatio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.price = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fee = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FeeRatio {
    return {
      price: isSet(object.price) ? Coin.fromJSON(object.price) : undefined,
      fee: isSet(object.fee) ? Coin.fromJSON(object.fee) : undefined,
    };
  },

  toJSON(message: FeeRatio): unknown {
    const obj: any = {};
    if (message.price !== undefined) {
      obj.price = Coin.toJSON(message.price);
    }
    if (message.fee !== undefined) {
      obj.fee = Coin.toJSON(message.fee);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FeeRatio>, I>>(base?: I): FeeRatio {
    return FeeRatio.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FeeRatio>, I>>(object: I): FeeRatio {
    const message = createBaseFeeRatio();
    message.price = (object.price !== undefined && object.price !== null) ? Coin.fromPartial(object.price) : undefined;
    message.fee = (object.fee !== undefined && object.fee !== null) ? Coin.fromPartial(object.fee) : undefined;
    return message;
  },
};

function createBaseAccessGrant(): AccessGrant {
  return { address: "", permissions: [] };
}

export const AccessGrant: MessageFns<AccessGrant> = {
  encode(message: AccessGrant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    writer.uint32(18).fork();
    for (const v of message.permissions) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccessGrant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccessGrant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.permissions.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.permissions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccessGrant {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      permissions: globalThis.Array.isArray(object?.permissions)
        ? object.permissions.map((e: any) => permissionFromJSON(e))
        : [],
    };
  },

  toJSON(message: AccessGrant): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.permissions?.length) {
      obj.permissions = message.permissions.map((e) => permissionToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccessGrant>, I>>(base?: I): AccessGrant {
    return AccessGrant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccessGrant>, I>>(object: I): AccessGrant {
    const message = createBaseAccessGrant();
    message.address = object.address ?? "";
    message.permissions = object.permissions?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
