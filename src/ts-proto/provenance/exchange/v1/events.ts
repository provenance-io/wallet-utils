// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: provenance/exchange/v1/events.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "provenance.exchange.v1";

/** EventOrderCreated is an event emitted when an order is created. */
export interface EventOrderCreated {
  /** order_id is the numerical identifier of the order created. */
  orderId: Long;
  /** order_type is the type of order, e.g. "ask" or "bid". */
  orderType: string;
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** external_id is the order's external id. */
  externalId: string;
}

/** EventOrderCancelled is an event emitted when an order is cancelled. */
export interface EventOrderCancelled {
  /** order_id is the numerical identifier of the order cancelled. */
  orderId: Long;
  /** cancelled_by is the account that triggered the cancellation of the order. */
  cancelledBy: string;
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** external_id is the order's external id. */
  externalId: string;
}

/**
 * EventOrderFilled is an event emitted when an order has been filled in full.
 * This event is also used for orders that were previously partially filled, but have now been filled in full.
 */
export interface EventOrderFilled {
  /** order_id is the numerical identifier of the order filled. */
  orderId: Long;
  /** assets is the coins amount string of assets bought/sold for this order. */
  assets: string;
  /** price is the coins amount string of the price payed/received for this order. */
  price: string;
  /** fees is the coins amount string of settlement fees paid with this order. */
  fees: string;
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** external_id is the order's external id. */
  externalId: string;
}

/** EventOrderPartiallyFilled is an event emitted when an order filled in part and still has more left to fill. */
export interface EventOrderPartiallyFilled {
  /** order_id is the numerical identifier of the order partially filled. */
  orderId: Long;
  /** assets is the coins amount string of assets that were filled and removed from the order. */
  assets: string;
  /**
   * price is the coins amount string of the price payed/received for this order.
   * For ask orders, this might be more than the amount that was removed from the order's price.
   */
  price: string;
  /**
   * fees is the coins amount string of settlement fees paid with this partial order.
   * For ask orders, this might be more than the amount that was removed from the order's settlement fees.
   */
  fees: string;
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** external_id is the order's external id. */
  externalId: string;
}

/** EventOrderExternalIDUpdated is an event emitted when an order's external id is updated. */
export interface EventOrderExternalIDUpdated {
  /** order_id is the numerical identifier of the order partially filled. */
  orderId: Long;
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** external_id is the order's new external id. */
  externalId: string;
}

/** EventFundsCommitted is an event emitted when funds are committed to a market. */
export interface EventFundsCommitted {
  /** account is the bech32 address string of the account. */
  account: string;
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** amount is the coins string of the newly committed funds. */
  amount: string;
  /** tag is the string provided in the message causing this event. */
  tag: string;
}

/** EventCommitmentReleased is an event emitted when funds are released from their commitment. */
export interface EventCommitmentReleased {
  /** account is the bech32 address string of the account. */
  account: string;
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** amount is the coins string of the funds that were released from commitment. */
  amount: string;
  /** tag is the string provided in the message causing this event. */
  tag: string;
}

/** EventMarketWithdraw is an event emitted when a withdrawal of a market's collected fees is made. */
export interface EventMarketWithdraw {
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** amount is the coins amount string of funds withdrawn from the market account. */
  amount: string;
  /** destination is the account that received the funds. */
  destination: string;
  /** withdrawn_by is the account that requested the withdrawal. */
  withdrawnBy: string;
}

/** EventMarketDetailsUpdated is an event emitted when a market's details are updated. */
export interface EventMarketDetailsUpdated {
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** updated_by is the account that updated the details. */
  updatedBy: string;
}

/**
 * EventMarketEnabled is an event emitted when a market is enabled.
 * Deprecated: This event is no longer used. It is replaced with EventMarketOrdersEnabled.
 *
 * @deprecated
 */
export interface EventMarketEnabled {
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** updated_by is the account that enabled the market. */
  updatedBy: string;
}

/**
 * EventMarketDisabled is an event emitted when a market is disabled.
 * Deprecated: This event is no longer used. It is replaced with EventMarketOrdersDisabled.
 *
 * @deprecated
 */
export interface EventMarketDisabled {
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** updated_by is the account that disabled the market. */
  updatedBy: string;
}

/** EventMarketOrdersEnabled is an event emitted when a market enables order creation. */
export interface EventMarketOrdersEnabled {
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** updated_by is the account that updated the accepting_orders option. */
  updatedBy: string;
}

/** EventMarketOrdersEnabled is an event emitted when a market disables order creation. */
export interface EventMarketOrdersDisabled {
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** updated_by is the account that updated the accepting_orders option. */
  updatedBy: string;
}

/** EventMarketUserSettleEnabled is an event emitted when a market's user_settle option is enabled. */
export interface EventMarketUserSettleEnabled {
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** updated_by is the account that updated the user_settle option. */
  updatedBy: string;
}

/** EventMarketUserSettleDisabled is an event emitted when a market's user_settle option is disabled. */
export interface EventMarketUserSettleDisabled {
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** updated_by is the account that updated the user_settle option. */
  updatedBy: string;
}

/** EventMarketCommitmentsEnabled is an event emitted when a market's accepting_commitments option is enabled. */
export interface EventMarketCommitmentsEnabled {
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** updated_by is the account that updated the accepting_commitments option. */
  updatedBy: string;
}

/** EventMarketCommitmentsDisabled is an event emitted when a market's accepting_commitments option is disabled. */
export interface EventMarketCommitmentsDisabled {
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** updated_by is the account that updated the accepting_commitments option. */
  updatedBy: string;
}

/**
 * EventMarketIntermediaryDenomUpdated is an event emitted when a market updates its
 * commitment_settlement_intermediary_denom field.
 */
export interface EventMarketIntermediaryDenomUpdated {
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** updated_by is the account that updated the intermediary denom. */
  updatedBy: string;
}

/** EventMarketPermissionsUpdated is an event emitted when a market's permissions are updated. */
export interface EventMarketPermissionsUpdated {
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** updated_by is the account that updated the permissions. */
  updatedBy: string;
}

/** EventMarketReqAttrUpdated is an event emitted when a market's required attributes are updated. */
export interface EventMarketReqAttrUpdated {
  /** market_id is the numerical identifier of the market. */
  marketId: number;
  /** updated_by is the account that updated the required attributes. */
  updatedBy: string;
}

/** EventMarketCreated is an event emitted when a market has been created. */
export interface EventMarketCreated {
  /** market_id is the numerical identifier of the market. */
  marketId: number;
}

/** EventMarketFeesUpdated is an event emitted when a market's fees have been updated. */
export interface EventMarketFeesUpdated {
  /** market_id is the numerical identifier of the market. */
  marketId: number;
}

/** EventParamsUpdated is an event emitted when the exchange module's params have been updated. */
export interface EventParamsUpdated {
}

/** EventPaymentCreated is an event emitted when a payment is created. */
export interface EventPaymentCreated {
  /** source is the account that created the Payment. */
  source: string;
  /** source_amount is the coins amount string of the funds that the source will pay (to the target). */
  sourceAmount: string;
  /** target is the account that can accept the Payment. */
  target: string;
  /** target_amount is the coins amount string of the funds that the target will pay (to the source). */
  targetAmount: string;
  /** external_id is used along with the source to uniquely identify this Payment. */
  externalId: string;
}

/** EventPaymentUpdated is an event emitted when a payment is updated. */
export interface EventPaymentUpdated {
  /** source is the account that updated (and previously created) the Payment. */
  source: string;
  /** source_amount is the coins amount string of the funds that the source will pay (to the target). */
  sourceAmount: string;
  /** old_target is the account that used to be able to accept the Payment (but not any more). */
  oldTarget: string;
  /** new_target is the account that is now able to accept the Payment. */
  newTarget: string;
  /** target_amount is the coins amount string of the funds that the target will pay (to the source). */
  targetAmount: string;
  /** external_id is used along with the source to uniquely identify this Payment. */
  externalId: string;
}

/** EventPaymentAccepted is an event emitted when a payment is accepted. */
export interface EventPaymentAccepted {
  /** source is the account that created the Payment. */
  source: string;
  /** source_amount is the coins amount string of the funds that the source will pay (to the target). */
  sourceAmount: string;
  /** target is the account that accepted the Payment. */
  target: string;
  /** target_amount is the coins amount string of the funds that the target will pay (to the source). */
  targetAmount: string;
  /** external_id is used along with the source to uniquely identify this Payment. */
  externalId: string;
}

/** EventPaymentRejected is an event emitted when a payment is rejected (by the target). */
export interface EventPaymentRejected {
  /** source is the account that created the Payment. */
  source: string;
  /** target is the account that rejected the Payment. */
  target: string;
  /** external_id is used along with the source to uniquely identify this Payment. */
  externalId: string;
}

/** EventPaymentCancelled is an event emitted when a payment is cancelled (by the source). */
export interface EventPaymentCancelled {
  /** source is the account that cancelled (and created) the Payment. */
  source: string;
  /** target is the account that could have accepted the Payment. */
  target: string;
  /** external_id is used along with the source to uniquely identify this Payment. */
  externalId: string;
}

function createBaseEventOrderCreated(): EventOrderCreated {
  return { orderId: Long.UZERO, orderType: "", marketId: 0, externalId: "" };
}

export const EventOrderCreated: MessageFns<EventOrderCreated> = {
  encode(message: EventOrderCreated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.orderId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.orderId.toString());
    }
    if (message.orderType !== "") {
      writer.uint32(18).string(message.orderType);
    }
    if (message.marketId !== 0) {
      writer.uint32(24).uint32(message.marketId);
    }
    if (message.externalId !== "") {
      writer.uint32(34).string(message.externalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOrderCreated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOrderCreated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.orderId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOrderCreated {
    return {
      orderId: isSet(object.orderId) ? Long.fromValue(object.orderId) : Long.UZERO,
      orderType: isSet(object.orderType) ? globalThis.String(object.orderType) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
    };
  },

  toJSON(message: EventOrderCreated): unknown {
    const obj: any = {};
    if (!message.orderId.equals(Long.UZERO)) {
      obj.orderId = (message.orderId || Long.UZERO).toString();
    }
    if (message.orderType !== "") {
      obj.orderType = message.orderType;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOrderCreated>, I>>(base?: I): EventOrderCreated {
    return EventOrderCreated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOrderCreated>, I>>(object: I): EventOrderCreated {
    const message = createBaseEventOrderCreated();
    message.orderId = (object.orderId !== undefined && object.orderId !== null)
      ? Long.fromValue(object.orderId)
      : Long.UZERO;
    message.orderType = object.orderType ?? "";
    message.marketId = object.marketId ?? 0;
    message.externalId = object.externalId ?? "";
    return message;
  },
};

function createBaseEventOrderCancelled(): EventOrderCancelled {
  return { orderId: Long.UZERO, cancelledBy: "", marketId: 0, externalId: "" };
}

export const EventOrderCancelled: MessageFns<EventOrderCancelled> = {
  encode(message: EventOrderCancelled, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.orderId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.orderId.toString());
    }
    if (message.cancelledBy !== "") {
      writer.uint32(18).string(message.cancelledBy);
    }
    if (message.marketId !== 0) {
      writer.uint32(24).uint32(message.marketId);
    }
    if (message.externalId !== "") {
      writer.uint32(34).string(message.externalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOrderCancelled {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOrderCancelled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.orderId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cancelledBy = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOrderCancelled {
    return {
      orderId: isSet(object.orderId) ? Long.fromValue(object.orderId) : Long.UZERO,
      cancelledBy: isSet(object.cancelledBy) ? globalThis.String(object.cancelledBy) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
    };
  },

  toJSON(message: EventOrderCancelled): unknown {
    const obj: any = {};
    if (!message.orderId.equals(Long.UZERO)) {
      obj.orderId = (message.orderId || Long.UZERO).toString();
    }
    if (message.cancelledBy !== "") {
      obj.cancelledBy = message.cancelledBy;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOrderCancelled>, I>>(base?: I): EventOrderCancelled {
    return EventOrderCancelled.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOrderCancelled>, I>>(object: I): EventOrderCancelled {
    const message = createBaseEventOrderCancelled();
    message.orderId = (object.orderId !== undefined && object.orderId !== null)
      ? Long.fromValue(object.orderId)
      : Long.UZERO;
    message.cancelledBy = object.cancelledBy ?? "";
    message.marketId = object.marketId ?? 0;
    message.externalId = object.externalId ?? "";
    return message;
  },
};

function createBaseEventOrderFilled(): EventOrderFilled {
  return { orderId: Long.UZERO, assets: "", price: "", fees: "", marketId: 0, externalId: "" };
}

export const EventOrderFilled: MessageFns<EventOrderFilled> = {
  encode(message: EventOrderFilled, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.orderId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.orderId.toString());
    }
    if (message.assets !== "") {
      writer.uint32(18).string(message.assets);
    }
    if (message.price !== "") {
      writer.uint32(26).string(message.price);
    }
    if (message.fees !== "") {
      writer.uint32(34).string(message.fees);
    }
    if (message.marketId !== 0) {
      writer.uint32(40).uint32(message.marketId);
    }
    if (message.externalId !== "") {
      writer.uint32(50).string(message.externalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOrderFilled {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOrderFilled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.orderId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assets = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.price = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fees = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOrderFilled {
    return {
      orderId: isSet(object.orderId) ? Long.fromValue(object.orderId) : Long.UZERO,
      assets: isSet(object.assets) ? globalThis.String(object.assets) : "",
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      fees: isSet(object.fees) ? globalThis.String(object.fees) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
    };
  },

  toJSON(message: EventOrderFilled): unknown {
    const obj: any = {};
    if (!message.orderId.equals(Long.UZERO)) {
      obj.orderId = (message.orderId || Long.UZERO).toString();
    }
    if (message.assets !== "") {
      obj.assets = message.assets;
    }
    if (message.price !== "") {
      obj.price = message.price;
    }
    if (message.fees !== "") {
      obj.fees = message.fees;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOrderFilled>, I>>(base?: I): EventOrderFilled {
    return EventOrderFilled.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOrderFilled>, I>>(object: I): EventOrderFilled {
    const message = createBaseEventOrderFilled();
    message.orderId = (object.orderId !== undefined && object.orderId !== null)
      ? Long.fromValue(object.orderId)
      : Long.UZERO;
    message.assets = object.assets ?? "";
    message.price = object.price ?? "";
    message.fees = object.fees ?? "";
    message.marketId = object.marketId ?? 0;
    message.externalId = object.externalId ?? "";
    return message;
  },
};

function createBaseEventOrderPartiallyFilled(): EventOrderPartiallyFilled {
  return { orderId: Long.UZERO, assets: "", price: "", fees: "", marketId: 0, externalId: "" };
}

export const EventOrderPartiallyFilled: MessageFns<EventOrderPartiallyFilled> = {
  encode(message: EventOrderPartiallyFilled, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.orderId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.orderId.toString());
    }
    if (message.assets !== "") {
      writer.uint32(18).string(message.assets);
    }
    if (message.price !== "") {
      writer.uint32(26).string(message.price);
    }
    if (message.fees !== "") {
      writer.uint32(34).string(message.fees);
    }
    if (message.marketId !== 0) {
      writer.uint32(40).uint32(message.marketId);
    }
    if (message.externalId !== "") {
      writer.uint32(50).string(message.externalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOrderPartiallyFilled {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOrderPartiallyFilled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.orderId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assets = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.price = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.fees = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOrderPartiallyFilled {
    return {
      orderId: isSet(object.orderId) ? Long.fromValue(object.orderId) : Long.UZERO,
      assets: isSet(object.assets) ? globalThis.String(object.assets) : "",
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      fees: isSet(object.fees) ? globalThis.String(object.fees) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
    };
  },

  toJSON(message: EventOrderPartiallyFilled): unknown {
    const obj: any = {};
    if (!message.orderId.equals(Long.UZERO)) {
      obj.orderId = (message.orderId || Long.UZERO).toString();
    }
    if (message.assets !== "") {
      obj.assets = message.assets;
    }
    if (message.price !== "") {
      obj.price = message.price;
    }
    if (message.fees !== "") {
      obj.fees = message.fees;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOrderPartiallyFilled>, I>>(base?: I): EventOrderPartiallyFilled {
    return EventOrderPartiallyFilled.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOrderPartiallyFilled>, I>>(object: I): EventOrderPartiallyFilled {
    const message = createBaseEventOrderPartiallyFilled();
    message.orderId = (object.orderId !== undefined && object.orderId !== null)
      ? Long.fromValue(object.orderId)
      : Long.UZERO;
    message.assets = object.assets ?? "";
    message.price = object.price ?? "";
    message.fees = object.fees ?? "";
    message.marketId = object.marketId ?? 0;
    message.externalId = object.externalId ?? "";
    return message;
  },
};

function createBaseEventOrderExternalIDUpdated(): EventOrderExternalIDUpdated {
  return { orderId: Long.UZERO, marketId: 0, externalId: "" };
}

export const EventOrderExternalIDUpdated: MessageFns<EventOrderExternalIDUpdated> = {
  encode(message: EventOrderExternalIDUpdated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.orderId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.orderId.toString());
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    if (message.externalId !== "") {
      writer.uint32(26).string(message.externalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventOrderExternalIDUpdated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventOrderExternalIDUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.orderId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventOrderExternalIDUpdated {
    return {
      orderId: isSet(object.orderId) ? Long.fromValue(object.orderId) : Long.UZERO,
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
    };
  },

  toJSON(message: EventOrderExternalIDUpdated): unknown {
    const obj: any = {};
    if (!message.orderId.equals(Long.UZERO)) {
      obj.orderId = (message.orderId || Long.UZERO).toString();
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventOrderExternalIDUpdated>, I>>(base?: I): EventOrderExternalIDUpdated {
    return EventOrderExternalIDUpdated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventOrderExternalIDUpdated>, I>>(object: I): EventOrderExternalIDUpdated {
    const message = createBaseEventOrderExternalIDUpdated();
    message.orderId = (object.orderId !== undefined && object.orderId !== null)
      ? Long.fromValue(object.orderId)
      : Long.UZERO;
    message.marketId = object.marketId ?? 0;
    message.externalId = object.externalId ?? "";
    return message;
  },
};

function createBaseEventFundsCommitted(): EventFundsCommitted {
  return { account: "", marketId: 0, amount: "", tag: "" };
}

export const EventFundsCommitted: MessageFns<EventFundsCommitted> = {
  encode(message: EventFundsCommitted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.tag !== "") {
      writer.uint32(34).string(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventFundsCommitted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventFundsCommitted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventFundsCommitted {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
    };
  },

  toJSON(message: EventFundsCommitted): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventFundsCommitted>, I>>(base?: I): EventFundsCommitted {
    return EventFundsCommitted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventFundsCommitted>, I>>(object: I): EventFundsCommitted {
    const message = createBaseEventFundsCommitted();
    message.account = object.account ?? "";
    message.marketId = object.marketId ?? 0;
    message.amount = object.amount ?? "";
    message.tag = object.tag ?? "";
    return message;
  },
};

function createBaseEventCommitmentReleased(): EventCommitmentReleased {
  return { account: "", marketId: 0, amount: "", tag: "" };
}

export const EventCommitmentReleased: MessageFns<EventCommitmentReleased> = {
  encode(message: EventCommitmentReleased, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.account !== "") {
      writer.uint32(10).string(message.account);
    }
    if (message.marketId !== 0) {
      writer.uint32(16).uint32(message.marketId);
    }
    if (message.amount !== "") {
      writer.uint32(26).string(message.amount);
    }
    if (message.tag !== "") {
      writer.uint32(34).string(message.tag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventCommitmentReleased {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventCommitmentReleased();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.account = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventCommitmentReleased {
    return {
      account: isSet(object.account) ? globalThis.String(object.account) : "",
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
    };
  },

  toJSON(message: EventCommitmentReleased): unknown {
    const obj: any = {};
    if (message.account !== "") {
      obj.account = message.account;
    }
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventCommitmentReleased>, I>>(base?: I): EventCommitmentReleased {
    return EventCommitmentReleased.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventCommitmentReleased>, I>>(object: I): EventCommitmentReleased {
    const message = createBaseEventCommitmentReleased();
    message.account = object.account ?? "";
    message.marketId = object.marketId ?? 0;
    message.amount = object.amount ?? "";
    message.tag = object.tag ?? "";
    return message;
  },
};

function createBaseEventMarketWithdraw(): EventMarketWithdraw {
  return { marketId: 0, amount: "", destination: "", withdrawnBy: "" };
}

export const EventMarketWithdraw: MessageFns<EventMarketWithdraw> = {
  encode(message: EventMarketWithdraw, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.amount !== "") {
      writer.uint32(18).string(message.amount);
    }
    if (message.destination !== "") {
      writer.uint32(26).string(message.destination);
    }
    if (message.withdrawnBy !== "") {
      writer.uint32(34).string(message.withdrawnBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarketWithdraw {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarketWithdraw();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destination = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.withdrawnBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarketWithdraw {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      amount: isSet(object.amount) ? globalThis.String(object.amount) : "",
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
      withdrawnBy: isSet(object.withdrawnBy) ? globalThis.String(object.withdrawnBy) : "",
    };
  },

  toJSON(message: EventMarketWithdraw): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.amount !== "") {
      obj.amount = message.amount;
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    if (message.withdrawnBy !== "") {
      obj.withdrawnBy = message.withdrawnBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarketWithdraw>, I>>(base?: I): EventMarketWithdraw {
    return EventMarketWithdraw.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarketWithdraw>, I>>(object: I): EventMarketWithdraw {
    const message = createBaseEventMarketWithdraw();
    message.marketId = object.marketId ?? 0;
    message.amount = object.amount ?? "";
    message.destination = object.destination ?? "";
    message.withdrawnBy = object.withdrawnBy ?? "";
    return message;
  },
};

function createBaseEventMarketDetailsUpdated(): EventMarketDetailsUpdated {
  return { marketId: 0, updatedBy: "" };
}

export const EventMarketDetailsUpdated: MessageFns<EventMarketDetailsUpdated> = {
  encode(message: EventMarketDetailsUpdated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.updatedBy !== "") {
      writer.uint32(18).string(message.updatedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarketDetailsUpdated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarketDetailsUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updatedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarketDetailsUpdated {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      updatedBy: isSet(object.updatedBy) ? globalThis.String(object.updatedBy) : "",
    };
  },

  toJSON(message: EventMarketDetailsUpdated): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.updatedBy !== "") {
      obj.updatedBy = message.updatedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarketDetailsUpdated>, I>>(base?: I): EventMarketDetailsUpdated {
    return EventMarketDetailsUpdated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarketDetailsUpdated>, I>>(object: I): EventMarketDetailsUpdated {
    const message = createBaseEventMarketDetailsUpdated();
    message.marketId = object.marketId ?? 0;
    message.updatedBy = object.updatedBy ?? "";
    return message;
  },
};

function createBaseEventMarketEnabled(): EventMarketEnabled {
  return { marketId: 0, updatedBy: "" };
}

export const EventMarketEnabled: MessageFns<EventMarketEnabled> = {
  encode(message: EventMarketEnabled, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.updatedBy !== "") {
      writer.uint32(18).string(message.updatedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarketEnabled {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarketEnabled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updatedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarketEnabled {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      updatedBy: isSet(object.updatedBy) ? globalThis.String(object.updatedBy) : "",
    };
  },

  toJSON(message: EventMarketEnabled): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.updatedBy !== "") {
      obj.updatedBy = message.updatedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarketEnabled>, I>>(base?: I): EventMarketEnabled {
    return EventMarketEnabled.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarketEnabled>, I>>(object: I): EventMarketEnabled {
    const message = createBaseEventMarketEnabled();
    message.marketId = object.marketId ?? 0;
    message.updatedBy = object.updatedBy ?? "";
    return message;
  },
};

function createBaseEventMarketDisabled(): EventMarketDisabled {
  return { marketId: 0, updatedBy: "" };
}

export const EventMarketDisabled: MessageFns<EventMarketDisabled> = {
  encode(message: EventMarketDisabled, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.updatedBy !== "") {
      writer.uint32(18).string(message.updatedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarketDisabled {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarketDisabled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updatedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarketDisabled {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      updatedBy: isSet(object.updatedBy) ? globalThis.String(object.updatedBy) : "",
    };
  },

  toJSON(message: EventMarketDisabled): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.updatedBy !== "") {
      obj.updatedBy = message.updatedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarketDisabled>, I>>(base?: I): EventMarketDisabled {
    return EventMarketDisabled.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarketDisabled>, I>>(object: I): EventMarketDisabled {
    const message = createBaseEventMarketDisabled();
    message.marketId = object.marketId ?? 0;
    message.updatedBy = object.updatedBy ?? "";
    return message;
  },
};

function createBaseEventMarketOrdersEnabled(): EventMarketOrdersEnabled {
  return { marketId: 0, updatedBy: "" };
}

export const EventMarketOrdersEnabled: MessageFns<EventMarketOrdersEnabled> = {
  encode(message: EventMarketOrdersEnabled, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.updatedBy !== "") {
      writer.uint32(18).string(message.updatedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarketOrdersEnabled {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarketOrdersEnabled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updatedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarketOrdersEnabled {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      updatedBy: isSet(object.updatedBy) ? globalThis.String(object.updatedBy) : "",
    };
  },

  toJSON(message: EventMarketOrdersEnabled): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.updatedBy !== "") {
      obj.updatedBy = message.updatedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarketOrdersEnabled>, I>>(base?: I): EventMarketOrdersEnabled {
    return EventMarketOrdersEnabled.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarketOrdersEnabled>, I>>(object: I): EventMarketOrdersEnabled {
    const message = createBaseEventMarketOrdersEnabled();
    message.marketId = object.marketId ?? 0;
    message.updatedBy = object.updatedBy ?? "";
    return message;
  },
};

function createBaseEventMarketOrdersDisabled(): EventMarketOrdersDisabled {
  return { marketId: 0, updatedBy: "" };
}

export const EventMarketOrdersDisabled: MessageFns<EventMarketOrdersDisabled> = {
  encode(message: EventMarketOrdersDisabled, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.updatedBy !== "") {
      writer.uint32(18).string(message.updatedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarketOrdersDisabled {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarketOrdersDisabled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updatedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarketOrdersDisabled {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      updatedBy: isSet(object.updatedBy) ? globalThis.String(object.updatedBy) : "",
    };
  },

  toJSON(message: EventMarketOrdersDisabled): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.updatedBy !== "") {
      obj.updatedBy = message.updatedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarketOrdersDisabled>, I>>(base?: I): EventMarketOrdersDisabled {
    return EventMarketOrdersDisabled.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarketOrdersDisabled>, I>>(object: I): EventMarketOrdersDisabled {
    const message = createBaseEventMarketOrdersDisabled();
    message.marketId = object.marketId ?? 0;
    message.updatedBy = object.updatedBy ?? "";
    return message;
  },
};

function createBaseEventMarketUserSettleEnabled(): EventMarketUserSettleEnabled {
  return { marketId: 0, updatedBy: "" };
}

export const EventMarketUserSettleEnabled: MessageFns<EventMarketUserSettleEnabled> = {
  encode(message: EventMarketUserSettleEnabled, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.updatedBy !== "") {
      writer.uint32(18).string(message.updatedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarketUserSettleEnabled {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarketUserSettleEnabled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updatedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarketUserSettleEnabled {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      updatedBy: isSet(object.updatedBy) ? globalThis.String(object.updatedBy) : "",
    };
  },

  toJSON(message: EventMarketUserSettleEnabled): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.updatedBy !== "") {
      obj.updatedBy = message.updatedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarketUserSettleEnabled>, I>>(base?: I): EventMarketUserSettleEnabled {
    return EventMarketUserSettleEnabled.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarketUserSettleEnabled>, I>>(object: I): EventMarketUserSettleEnabled {
    const message = createBaseEventMarketUserSettleEnabled();
    message.marketId = object.marketId ?? 0;
    message.updatedBy = object.updatedBy ?? "";
    return message;
  },
};

function createBaseEventMarketUserSettleDisabled(): EventMarketUserSettleDisabled {
  return { marketId: 0, updatedBy: "" };
}

export const EventMarketUserSettleDisabled: MessageFns<EventMarketUserSettleDisabled> = {
  encode(message: EventMarketUserSettleDisabled, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.updatedBy !== "") {
      writer.uint32(18).string(message.updatedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarketUserSettleDisabled {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarketUserSettleDisabled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updatedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarketUserSettleDisabled {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      updatedBy: isSet(object.updatedBy) ? globalThis.String(object.updatedBy) : "",
    };
  },

  toJSON(message: EventMarketUserSettleDisabled): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.updatedBy !== "") {
      obj.updatedBy = message.updatedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarketUserSettleDisabled>, I>>(base?: I): EventMarketUserSettleDisabled {
    return EventMarketUserSettleDisabled.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarketUserSettleDisabled>, I>>(
    object: I,
  ): EventMarketUserSettleDisabled {
    const message = createBaseEventMarketUserSettleDisabled();
    message.marketId = object.marketId ?? 0;
    message.updatedBy = object.updatedBy ?? "";
    return message;
  },
};

function createBaseEventMarketCommitmentsEnabled(): EventMarketCommitmentsEnabled {
  return { marketId: 0, updatedBy: "" };
}

export const EventMarketCommitmentsEnabled: MessageFns<EventMarketCommitmentsEnabled> = {
  encode(message: EventMarketCommitmentsEnabled, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.updatedBy !== "") {
      writer.uint32(18).string(message.updatedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarketCommitmentsEnabled {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarketCommitmentsEnabled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updatedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarketCommitmentsEnabled {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      updatedBy: isSet(object.updatedBy) ? globalThis.String(object.updatedBy) : "",
    };
  },

  toJSON(message: EventMarketCommitmentsEnabled): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.updatedBy !== "") {
      obj.updatedBy = message.updatedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarketCommitmentsEnabled>, I>>(base?: I): EventMarketCommitmentsEnabled {
    return EventMarketCommitmentsEnabled.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarketCommitmentsEnabled>, I>>(
    object: I,
  ): EventMarketCommitmentsEnabled {
    const message = createBaseEventMarketCommitmentsEnabled();
    message.marketId = object.marketId ?? 0;
    message.updatedBy = object.updatedBy ?? "";
    return message;
  },
};

function createBaseEventMarketCommitmentsDisabled(): EventMarketCommitmentsDisabled {
  return { marketId: 0, updatedBy: "" };
}

export const EventMarketCommitmentsDisabled: MessageFns<EventMarketCommitmentsDisabled> = {
  encode(message: EventMarketCommitmentsDisabled, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.updatedBy !== "") {
      writer.uint32(18).string(message.updatedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarketCommitmentsDisabled {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarketCommitmentsDisabled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updatedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarketCommitmentsDisabled {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      updatedBy: isSet(object.updatedBy) ? globalThis.String(object.updatedBy) : "",
    };
  },

  toJSON(message: EventMarketCommitmentsDisabled): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.updatedBy !== "") {
      obj.updatedBy = message.updatedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarketCommitmentsDisabled>, I>>(base?: I): EventMarketCommitmentsDisabled {
    return EventMarketCommitmentsDisabled.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarketCommitmentsDisabled>, I>>(
    object: I,
  ): EventMarketCommitmentsDisabled {
    const message = createBaseEventMarketCommitmentsDisabled();
    message.marketId = object.marketId ?? 0;
    message.updatedBy = object.updatedBy ?? "";
    return message;
  },
};

function createBaseEventMarketIntermediaryDenomUpdated(): EventMarketIntermediaryDenomUpdated {
  return { marketId: 0, updatedBy: "" };
}

export const EventMarketIntermediaryDenomUpdated: MessageFns<EventMarketIntermediaryDenomUpdated> = {
  encode(message: EventMarketIntermediaryDenomUpdated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.updatedBy !== "") {
      writer.uint32(18).string(message.updatedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarketIntermediaryDenomUpdated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarketIntermediaryDenomUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updatedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarketIntermediaryDenomUpdated {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      updatedBy: isSet(object.updatedBy) ? globalThis.String(object.updatedBy) : "",
    };
  },

  toJSON(message: EventMarketIntermediaryDenomUpdated): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.updatedBy !== "") {
      obj.updatedBy = message.updatedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarketIntermediaryDenomUpdated>, I>>(
    base?: I,
  ): EventMarketIntermediaryDenomUpdated {
    return EventMarketIntermediaryDenomUpdated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarketIntermediaryDenomUpdated>, I>>(
    object: I,
  ): EventMarketIntermediaryDenomUpdated {
    const message = createBaseEventMarketIntermediaryDenomUpdated();
    message.marketId = object.marketId ?? 0;
    message.updatedBy = object.updatedBy ?? "";
    return message;
  },
};

function createBaseEventMarketPermissionsUpdated(): EventMarketPermissionsUpdated {
  return { marketId: 0, updatedBy: "" };
}

export const EventMarketPermissionsUpdated: MessageFns<EventMarketPermissionsUpdated> = {
  encode(message: EventMarketPermissionsUpdated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.updatedBy !== "") {
      writer.uint32(18).string(message.updatedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarketPermissionsUpdated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarketPermissionsUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updatedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarketPermissionsUpdated {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      updatedBy: isSet(object.updatedBy) ? globalThis.String(object.updatedBy) : "",
    };
  },

  toJSON(message: EventMarketPermissionsUpdated): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.updatedBy !== "") {
      obj.updatedBy = message.updatedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarketPermissionsUpdated>, I>>(base?: I): EventMarketPermissionsUpdated {
    return EventMarketPermissionsUpdated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarketPermissionsUpdated>, I>>(
    object: I,
  ): EventMarketPermissionsUpdated {
    const message = createBaseEventMarketPermissionsUpdated();
    message.marketId = object.marketId ?? 0;
    message.updatedBy = object.updatedBy ?? "";
    return message;
  },
};

function createBaseEventMarketReqAttrUpdated(): EventMarketReqAttrUpdated {
  return { marketId: 0, updatedBy: "" };
}

export const EventMarketReqAttrUpdated: MessageFns<EventMarketReqAttrUpdated> = {
  encode(message: EventMarketReqAttrUpdated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    if (message.updatedBy !== "") {
      writer.uint32(18).string(message.updatedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarketReqAttrUpdated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarketReqAttrUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updatedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarketReqAttrUpdated {
    return {
      marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0,
      updatedBy: isSet(object.updatedBy) ? globalThis.String(object.updatedBy) : "",
    };
  },

  toJSON(message: EventMarketReqAttrUpdated): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    if (message.updatedBy !== "") {
      obj.updatedBy = message.updatedBy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarketReqAttrUpdated>, I>>(base?: I): EventMarketReqAttrUpdated {
    return EventMarketReqAttrUpdated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarketReqAttrUpdated>, I>>(object: I): EventMarketReqAttrUpdated {
    const message = createBaseEventMarketReqAttrUpdated();
    message.marketId = object.marketId ?? 0;
    message.updatedBy = object.updatedBy ?? "";
    return message;
  },
};

function createBaseEventMarketCreated(): EventMarketCreated {
  return { marketId: 0 };
}

export const EventMarketCreated: MessageFns<EventMarketCreated> = {
  encode(message: EventMarketCreated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarketCreated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarketCreated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarketCreated {
    return { marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0 };
  },

  toJSON(message: EventMarketCreated): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarketCreated>, I>>(base?: I): EventMarketCreated {
    return EventMarketCreated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarketCreated>, I>>(object: I): EventMarketCreated {
    const message = createBaseEventMarketCreated();
    message.marketId = object.marketId ?? 0;
    return message;
  },
};

function createBaseEventMarketFeesUpdated(): EventMarketFeesUpdated {
  return { marketId: 0 };
}

export const EventMarketFeesUpdated: MessageFns<EventMarketFeesUpdated> = {
  encode(message: EventMarketFeesUpdated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.marketId !== 0) {
      writer.uint32(8).uint32(message.marketId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMarketFeesUpdated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMarketFeesUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.marketId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMarketFeesUpdated {
    return { marketId: isSet(object.marketId) ? globalThis.Number(object.marketId) : 0 };
  },

  toJSON(message: EventMarketFeesUpdated): unknown {
    const obj: any = {};
    if (message.marketId !== 0) {
      obj.marketId = Math.round(message.marketId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventMarketFeesUpdated>, I>>(base?: I): EventMarketFeesUpdated {
    return EventMarketFeesUpdated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventMarketFeesUpdated>, I>>(object: I): EventMarketFeesUpdated {
    const message = createBaseEventMarketFeesUpdated();
    message.marketId = object.marketId ?? 0;
    return message;
  },
};

function createBaseEventParamsUpdated(): EventParamsUpdated {
  return {};
}

export const EventParamsUpdated: MessageFns<EventParamsUpdated> = {
  encode(_: EventParamsUpdated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventParamsUpdated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventParamsUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EventParamsUpdated {
    return {};
  },

  toJSON(_: EventParamsUpdated): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<EventParamsUpdated>, I>>(base?: I): EventParamsUpdated {
    return EventParamsUpdated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventParamsUpdated>, I>>(_: I): EventParamsUpdated {
    const message = createBaseEventParamsUpdated();
    return message;
  },
};

function createBaseEventPaymentCreated(): EventPaymentCreated {
  return { source: "", sourceAmount: "", target: "", targetAmount: "", externalId: "" };
}

export const EventPaymentCreated: MessageFns<EventPaymentCreated> = {
  encode(message: EventPaymentCreated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.sourceAmount !== "") {
      writer.uint32(18).string(message.sourceAmount);
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.targetAmount !== "") {
      writer.uint32(34).string(message.targetAmount);
    }
    if (message.externalId !== "") {
      writer.uint32(42).string(message.externalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventPaymentCreated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventPaymentCreated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourceAmount = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.targetAmount = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventPaymentCreated {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      sourceAmount: isSet(object.sourceAmount) ? globalThis.String(object.sourceAmount) : "",
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      targetAmount: isSet(object.targetAmount) ? globalThis.String(object.targetAmount) : "",
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
    };
  },

  toJSON(message: EventPaymentCreated): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.sourceAmount !== "") {
      obj.sourceAmount = message.sourceAmount;
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.targetAmount !== "") {
      obj.targetAmount = message.targetAmount;
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventPaymentCreated>, I>>(base?: I): EventPaymentCreated {
    return EventPaymentCreated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventPaymentCreated>, I>>(object: I): EventPaymentCreated {
    const message = createBaseEventPaymentCreated();
    message.source = object.source ?? "";
    message.sourceAmount = object.sourceAmount ?? "";
    message.target = object.target ?? "";
    message.targetAmount = object.targetAmount ?? "";
    message.externalId = object.externalId ?? "";
    return message;
  },
};

function createBaseEventPaymentUpdated(): EventPaymentUpdated {
  return { source: "", sourceAmount: "", oldTarget: "", newTarget: "", targetAmount: "", externalId: "" };
}

export const EventPaymentUpdated: MessageFns<EventPaymentUpdated> = {
  encode(message: EventPaymentUpdated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.sourceAmount !== "") {
      writer.uint32(18).string(message.sourceAmount);
    }
    if (message.oldTarget !== "") {
      writer.uint32(26).string(message.oldTarget);
    }
    if (message.newTarget !== "") {
      writer.uint32(34).string(message.newTarget);
    }
    if (message.targetAmount !== "") {
      writer.uint32(42).string(message.targetAmount);
    }
    if (message.externalId !== "") {
      writer.uint32(50).string(message.externalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventPaymentUpdated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventPaymentUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourceAmount = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.oldTarget = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.newTarget = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.targetAmount = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventPaymentUpdated {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      sourceAmount: isSet(object.sourceAmount) ? globalThis.String(object.sourceAmount) : "",
      oldTarget: isSet(object.oldTarget) ? globalThis.String(object.oldTarget) : "",
      newTarget: isSet(object.newTarget) ? globalThis.String(object.newTarget) : "",
      targetAmount: isSet(object.targetAmount) ? globalThis.String(object.targetAmount) : "",
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
    };
  },

  toJSON(message: EventPaymentUpdated): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.sourceAmount !== "") {
      obj.sourceAmount = message.sourceAmount;
    }
    if (message.oldTarget !== "") {
      obj.oldTarget = message.oldTarget;
    }
    if (message.newTarget !== "") {
      obj.newTarget = message.newTarget;
    }
    if (message.targetAmount !== "") {
      obj.targetAmount = message.targetAmount;
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventPaymentUpdated>, I>>(base?: I): EventPaymentUpdated {
    return EventPaymentUpdated.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventPaymentUpdated>, I>>(object: I): EventPaymentUpdated {
    const message = createBaseEventPaymentUpdated();
    message.source = object.source ?? "";
    message.sourceAmount = object.sourceAmount ?? "";
    message.oldTarget = object.oldTarget ?? "";
    message.newTarget = object.newTarget ?? "";
    message.targetAmount = object.targetAmount ?? "";
    message.externalId = object.externalId ?? "";
    return message;
  },
};

function createBaseEventPaymentAccepted(): EventPaymentAccepted {
  return { source: "", sourceAmount: "", target: "", targetAmount: "", externalId: "" };
}

export const EventPaymentAccepted: MessageFns<EventPaymentAccepted> = {
  encode(message: EventPaymentAccepted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.sourceAmount !== "") {
      writer.uint32(18).string(message.sourceAmount);
    }
    if (message.target !== "") {
      writer.uint32(26).string(message.target);
    }
    if (message.targetAmount !== "") {
      writer.uint32(34).string(message.targetAmount);
    }
    if (message.externalId !== "") {
      writer.uint32(42).string(message.externalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventPaymentAccepted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventPaymentAccepted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sourceAmount = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.target = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.targetAmount = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventPaymentAccepted {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      sourceAmount: isSet(object.sourceAmount) ? globalThis.String(object.sourceAmount) : "",
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      targetAmount: isSet(object.targetAmount) ? globalThis.String(object.targetAmount) : "",
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
    };
  },

  toJSON(message: EventPaymentAccepted): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.sourceAmount !== "") {
      obj.sourceAmount = message.sourceAmount;
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.targetAmount !== "") {
      obj.targetAmount = message.targetAmount;
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventPaymentAccepted>, I>>(base?: I): EventPaymentAccepted {
    return EventPaymentAccepted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventPaymentAccepted>, I>>(object: I): EventPaymentAccepted {
    const message = createBaseEventPaymentAccepted();
    message.source = object.source ?? "";
    message.sourceAmount = object.sourceAmount ?? "";
    message.target = object.target ?? "";
    message.targetAmount = object.targetAmount ?? "";
    message.externalId = object.externalId ?? "";
    return message;
  },
};

function createBaseEventPaymentRejected(): EventPaymentRejected {
  return { source: "", target: "", externalId: "" };
}

export const EventPaymentRejected: MessageFns<EventPaymentRejected> = {
  encode(message: EventPaymentRejected, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.target !== "") {
      writer.uint32(18).string(message.target);
    }
    if (message.externalId !== "") {
      writer.uint32(26).string(message.externalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventPaymentRejected {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventPaymentRejected();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.target = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventPaymentRejected {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
    };
  },

  toJSON(message: EventPaymentRejected): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventPaymentRejected>, I>>(base?: I): EventPaymentRejected {
    return EventPaymentRejected.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventPaymentRejected>, I>>(object: I): EventPaymentRejected {
    const message = createBaseEventPaymentRejected();
    message.source = object.source ?? "";
    message.target = object.target ?? "";
    message.externalId = object.externalId ?? "";
    return message;
  },
};

function createBaseEventPaymentCancelled(): EventPaymentCancelled {
  return { source: "", target: "", externalId: "" };
}

export const EventPaymentCancelled: MessageFns<EventPaymentCancelled> = {
  encode(message: EventPaymentCancelled, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== "") {
      writer.uint32(10).string(message.source);
    }
    if (message.target !== "") {
      writer.uint32(18).string(message.target);
    }
    if (message.externalId !== "") {
      writer.uint32(26).string(message.externalId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventPaymentCancelled {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventPaymentCancelled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.target = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventPaymentCancelled {
    return {
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
    };
  },

  toJSON(message: EventPaymentCancelled): unknown {
    const obj: any = {};
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EventPaymentCancelled>, I>>(base?: I): EventPaymentCancelled {
    return EventPaymentCancelled.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EventPaymentCancelled>, I>>(object: I): EventPaymentCancelled {
    const message = createBaseEventPaymentCancelled();
    message.source = object.source ?? "";
    message.target = object.target ?? "";
    message.externalId = object.externalId ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
